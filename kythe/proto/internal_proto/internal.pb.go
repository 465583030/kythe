// Code generated by protoc-gen-gogo.
// source: kythe/proto/internal.proto
// DO NOT EDIT!

/*
	Package internal_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/internal.proto

	It has these top-level messages:
		Source
		PageToken
		CrossReference
		SortedKeyValue
		Path
*/
package internal_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_serving "kythe.io/kythe/proto/serving_proto"

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// Source is a collection of facts and edges with a common source.
type Source struct {
	// Ticket of the source node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Fact name -> fact value
	Facts map[string][]byte `protobuf:"bytes,2,rep,name=facts" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Edge kind -> EdgeGroup
	EdgeGroups map[string]*Source_EdgeGroup `protobuf:"bytes,3,rep,name=edge_groups,json=edgeGroups" json:"edge_groups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Source) Reset()                    { *m = Source{} }
func (m *Source) String() string            { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()               {}
func (*Source) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{0} }

func (m *Source) GetFacts() map[string][]byte {
	if m != nil {
		return m.Facts
	}
	return nil
}

func (m *Source) GetEdgeGroups() map[string]*Source_EdgeGroup {
	if m != nil {
		return m.EdgeGroups
	}
	return nil
}

type Source_Edge struct {
	// Target ticket of the edge
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Ordinal of the edge
	Ordinal int32 `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *Source_Edge) Reset()                    { *m = Source_Edge{} }
func (m *Source_Edge) String() string            { return proto.CompactTextString(m) }
func (*Source_Edge) ProtoMessage()               {}
func (*Source_Edge) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{0, 0} }

type Source_EdgeGroup struct {
	// Set of Edges sharing the same kind and source
	Edges []*Source_Edge `protobuf:"bytes,1,rep,name=edges" json:"edges,omitempty"`
}

func (m *Source_EdgeGroup) Reset()                    { *m = Source_EdgeGroup{} }
func (m *Source_EdgeGroup) String() string            { return proto.CompactTextString(m) }
func (*Source_EdgeGroup) ProtoMessage()               {}
func (*Source_EdgeGroup) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{0, 1} }

func (m *Source_EdgeGroup) GetEdges() []*Source_Edge {
	if m != nil {
		return m.Edges
	}
	return nil
}

// Internal encoding for an EdgesReply/CrossReferencesReply page_token
type PageToken struct {
	// Index into the primary reply sequence.
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// Secondary page token for reply sub-query.
	SecondaryToken string `protobuf:"bytes,2,opt,name=secondary_token,json=secondaryToken,proto3" json:"secondary_token,omitempty"`
}

func (m *PageToken) Reset()                    { *m = PageToken{} }
func (m *PageToken) String() string            { return proto.CompactTextString(m) }
func (*PageToken) ProtoMessage()               {}
func (*PageToken) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{1} }

// A CrossReference represents a path between two anchors, crossing between a
// single common node.  Abstractly this a
// (file, anchor, kind, node, kind', anchor', file') tuple where the two
// (file, anchor, kind) sub-components have been named Decorations.
//
// This structure can be used to represent the intermediary* structures needed
// to build pre-cached responses to the Decorations and CrossReferences service
// methods.
//
// * where only a subset of this structure is known at that moment in time
type CrossReference struct {
	SourceDecoration *CrossReference_Decoration          `protobuf:"bytes,1,opt,name=source_decoration,json=sourceDecoration" json:"source_decoration,omitempty"`
	Referent         *kythe_proto_serving.Node           `protobuf:"bytes,2,opt,name=referent" json:"referent,omitempty"`
	TargetDecoration *CrossReference_Decoration          `protobuf:"bytes,3,opt,name=target_decoration,json=targetDecoration" json:"target_decoration,omitempty"`
	SourceAnchor     *kythe_proto_serving.ExpandedAnchor `protobuf:"bytes,4,opt,name=source_anchor,json=sourceAnchor" json:"source_anchor,omitempty"`
	TargetAnchor     *kythe_proto_serving.ExpandedAnchor `protobuf:"bytes,5,opt,name=target_anchor,json=targetAnchor" json:"target_anchor,omitempty"`
}

func (m *CrossReference) Reset()                    { *m = CrossReference{} }
func (m *CrossReference) String() string            { return proto.CompactTextString(m) }
func (*CrossReference) ProtoMessage()               {}
func (*CrossReference) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{2} }

func (m *CrossReference) GetSourceDecoration() *CrossReference_Decoration {
	if m != nil {
		return m.SourceDecoration
	}
	return nil
}

func (m *CrossReference) GetReferent() *kythe_proto_serving.Node {
	if m != nil {
		return m.Referent
	}
	return nil
}

func (m *CrossReference) GetTargetDecoration() *CrossReference_Decoration {
	if m != nil {
		return m.TargetDecoration
	}
	return nil
}

func (m *CrossReference) GetSourceAnchor() *kythe_proto_serving.ExpandedAnchor {
	if m != nil {
		return m.SourceAnchor
	}
	return nil
}

func (m *CrossReference) GetTargetAnchor() *kythe_proto_serving.ExpandedAnchor {
	if m != nil {
		return m.TargetAnchor
	}
	return nil
}

// A Decoration is specialized partial edge with an anchor on one end, stored
// along side its parent file node.  The partial edge's other end is stored in
// the referent field of the parent CrossReference.
type CrossReference_Decoration struct {
	File   *kythe_proto_serving.File      `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Anchor *kythe_proto_serving.RawAnchor `protobuf:"bytes,2,opt,name=anchor" json:"anchor,omitempty"`
	Kind   string                         `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *CrossReference_Decoration) Reset()         { *m = CrossReference_Decoration{} }
func (m *CrossReference_Decoration) String() string { return proto.CompactTextString(m) }
func (*CrossReference_Decoration) ProtoMessage()    {}
func (*CrossReference_Decoration) Descriptor() ([]byte, []int) {
	return fileDescriptorInternal, []int{2, 0}
}

func (m *CrossReference_Decoration) GetFile() *kythe_proto_serving.File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *CrossReference_Decoration) GetAnchor() *kythe_proto_serving.RawAnchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

type SortedKeyValue struct {
	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	SortKey string `protobuf:"bytes,2,opt,name=sort_key,json=sortKey,proto3" json:"sort_key,omitempty"`
	Value   []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SortedKeyValue) Reset()                    { *m = SortedKeyValue{} }
func (m *SortedKeyValue) String() string            { return proto.CompactTextString(m) }
func (*SortedKeyValue) ProtoMessage()               {}
func (*SortedKeyValue) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{3} }

// A Path represents a chain of Kythe edges starting from a particular node
// known as the Path's pivot node.
//
// Example Path representing a FileDecorations_Decoration:
//    pivot: <
//      file: <
//        ticket: "kythe://kythe?path=kythe/java/com/google/devtools/kythe/analyzers/base/EntrySet.java"
//        text: "..."
//        encoding: "UTF-8"
//      >
//      ticket: "kythe://kythe?path=kythe/java/com/google/devtools/kythe/analyzers/base/EntrySet.java"
//      node_kind: "file"
//    >
//    edges: <
//      kind: "%/kythe/edge/childof"
//      target: <
//        expanded_anchor: <
//          ticket: "kythe://kythe?lang=java?path=kythe/java/com/google/devtools/kythe/analyzers/base/EntrySet.java#b2b44a5e5d4b7f521b192a99ab6172ad24bf055db0c3e6353775a31f83e4e8b9"
//          kind: "%/kythe/edge/childof"
//          parent: "kythe://kythe?path=kythe/java/com/google/devtools/kythe/analyzers/base/EntrySet.java"
//          text: "edgeOrdinal"
//          span: <...>
//          snippet: "this.edgeOrdinal = -1"
//          snippet_span: <...>
//        >
//        ticket: "kythe://kythe?lang=java?path=kythe/java/com/google/devtools/kythe/analyzers/base/EntrySet.java#b2b44a5e5d4b7f521b192a99ab6172ad24bf055db0c3e6353775a31f83e4e8b9"
//        node_kind: "anchor"
//      >
//    >
//    edges: <
//      kind: "/kythe/edge/ref"
//      target: <
//        ticket: "kythe://kythe?lang=java?path=kythe/java/com/google/devtools/kythe/analyzers/base/EntrySet.java#3397da0c78948141fc85aa634e6d42e4461968ad33409c104e3a5e566306b8c5"
//        node_kind: "variable"
//        original: <...>
//      >
//    >
type Path struct {
	// The central node of this Path.
	Pivot *Path_Node `protobuf:"bytes,1,opt,name=pivot" json:"pivot,omitempty"`
	// A sequence of edges leading from the pivot node.
	Edges []*Path_Edge `protobuf:"bytes,2,rep,name=edges" json:"edges,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{4} }

func (m *Path) GetPivot() *Path_Node {
	if m != nil {
		return m.Pivot
	}
	return nil
}

func (m *Path) GetEdges() []*Path_Edge {
	if m != nil {
		return m.Edges
	}
	return nil
}

// A serving node with a possible specialization that unwraps/parses the
// original node's facts.
type Path_Node struct {
	// Types that are valid to be assigned to Specialization:
	//	*Path_Node_RawAnchor
	//	*Path_Node_ExpandedAnchor
	//	*Path_Node_File
	Specialization isPath_Node_Specialization `protobuf_oneof:"specialization"`
	Ticket         string                     `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	NodeKind       string                     `protobuf:"bytes,2,opt,name=node_kind,json=nodeKind,proto3" json:"node_kind,omitempty"`
	Original       *kythe_proto_serving.Node  `protobuf:"bytes,3,opt,name=original" json:"original,omitempty"`
}

func (m *Path_Node) Reset()                    { *m = Path_Node{} }
func (m *Path_Node) String() string            { return proto.CompactTextString(m) }
func (*Path_Node) ProtoMessage()               {}
func (*Path_Node) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{4, 0} }

type isPath_Node_Specialization interface {
	isPath_Node_Specialization()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Path_Node_RawAnchor struct {
	RawAnchor *kythe_proto_serving.RawAnchor `protobuf:"bytes,10,opt,name=raw_anchor,json=rawAnchor,oneof"`
}
type Path_Node_ExpandedAnchor struct {
	ExpandedAnchor *kythe_proto_serving.ExpandedAnchor `protobuf:"bytes,11,opt,name=expanded_anchor,json=expandedAnchor,oneof"`
}
type Path_Node_File struct {
	File *kythe_proto_serving.File `protobuf:"bytes,12,opt,name=file,oneof"`
}

func (*Path_Node_RawAnchor) isPath_Node_Specialization()      {}
func (*Path_Node_ExpandedAnchor) isPath_Node_Specialization() {}
func (*Path_Node_File) isPath_Node_Specialization()           {}

func (m *Path_Node) GetSpecialization() isPath_Node_Specialization {
	if m != nil {
		return m.Specialization
	}
	return nil
}

func (m *Path_Node) GetRawAnchor() *kythe_proto_serving.RawAnchor {
	if x, ok := m.GetSpecialization().(*Path_Node_RawAnchor); ok {
		return x.RawAnchor
	}
	return nil
}

func (m *Path_Node) GetExpandedAnchor() *kythe_proto_serving.ExpandedAnchor {
	if x, ok := m.GetSpecialization().(*Path_Node_ExpandedAnchor); ok {
		return x.ExpandedAnchor
	}
	return nil
}

func (m *Path_Node) GetFile() *kythe_proto_serving.File {
	if x, ok := m.GetSpecialization().(*Path_Node_File); ok {
		return x.File
	}
	return nil
}

func (m *Path_Node) GetOriginal() *kythe_proto_serving.Node {
	if m != nil {
		return m.Original
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Path_Node) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Path_Node_OneofMarshaler, _Path_Node_OneofUnmarshaler, _Path_Node_OneofSizer, []interface{}{
		(*Path_Node_RawAnchor)(nil),
		(*Path_Node_ExpandedAnchor)(nil),
		(*Path_Node_File)(nil),
	}
}

func _Path_Node_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Path_Node)
	// specialization
	switch x := m.Specialization.(type) {
	case *Path_Node_RawAnchor:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RawAnchor); err != nil {
			return err
		}
	case *Path_Node_ExpandedAnchor:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExpandedAnchor); err != nil {
			return err
		}
	case *Path_Node_File:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.File); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Path_Node.Specialization has unexpected type %T", x)
	}
	return nil
}

func _Path_Node_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Path_Node)
	switch tag {
	case 10: // specialization.raw_anchor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(kythe_proto_serving.RawAnchor)
		err := b.DecodeMessage(msg)
		m.Specialization = &Path_Node_RawAnchor{msg}
		return true, err
	case 11: // specialization.expanded_anchor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(kythe_proto_serving.ExpandedAnchor)
		err := b.DecodeMessage(msg)
		m.Specialization = &Path_Node_ExpandedAnchor{msg}
		return true, err
	case 12: // specialization.file
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(kythe_proto_serving.File)
		err := b.DecodeMessage(msg)
		m.Specialization = &Path_Node_File{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Path_Node_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Path_Node)
	// specialization
	switch x := m.Specialization.(type) {
	case *Path_Node_RawAnchor:
		s := proto.Size(x.RawAnchor)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Path_Node_ExpandedAnchor:
		s := proto.Size(x.ExpandedAnchor)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Path_Node_File:
		s := proto.Size(x.File)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Path_Edge struct {
	Kind    string     `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Ordinal int32      `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	Target  *Path_Node `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
}

func (m *Path_Edge) Reset()                    { *m = Path_Edge{} }
func (m *Path_Edge) String() string            { return proto.CompactTextString(m) }
func (*Path_Edge) ProtoMessage()               {}
func (*Path_Edge) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{4, 1} }

func (m *Path_Edge) GetTarget() *Path_Node {
	if m != nil {
		return m.Target
	}
	return nil
}

func init() {
	proto.RegisterType((*Source)(nil), "kythe.proto.internal.Source")
	proto.RegisterType((*Source_Edge)(nil), "kythe.proto.internal.Source.Edge")
	proto.RegisterType((*Source_EdgeGroup)(nil), "kythe.proto.internal.Source.EdgeGroup")
	proto.RegisterType((*PageToken)(nil), "kythe.proto.internal.PageToken")
	proto.RegisterType((*CrossReference)(nil), "kythe.proto.internal.CrossReference")
	proto.RegisterType((*CrossReference_Decoration)(nil), "kythe.proto.internal.CrossReference.Decoration")
	proto.RegisterType((*SortedKeyValue)(nil), "kythe.proto.internal.SortedKeyValue")
	proto.RegisterType((*Path)(nil), "kythe.proto.internal.Path")
	proto.RegisterType((*Path_Node)(nil), "kythe.proto.internal.Path.Node")
	proto.RegisterType((*Path_Edge)(nil), "kythe.proto.internal.Path.Edge")
}
func (m *Source) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Source) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Facts) > 0 {
		for k, _ := range m.Facts {
			data[i] = 0x12
			i++
			v := m.Facts[k]
			mapSize := 1 + len(k) + sovInternal(uint64(len(k))) + 1 + len(v) + sovInternal(uint64(len(v)))
			i = encodeVarintInternal(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintInternal(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintInternal(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.EdgeGroups) > 0 {
		for k, _ := range m.EdgeGroups {
			data[i] = 0x1a
			i++
			v := m.EdgeGroups[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovInternal(uint64(len(k))) + 1 + msgSize + sovInternal(uint64(msgSize))
			i = encodeVarintInternal(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintInternal(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintInternal(data, i, uint64(v.Size()))
			n1, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n1
		}
	}
	return i, nil
}

func (m *Source_Edge) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Source_Edge) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Ordinal != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintInternal(data, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *Source_EdgeGroup) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Source_EdgeGroup) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Edges) > 0 {
		for _, msg := range m.Edges {
			data[i] = 0xa
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PageToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PageToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintInternal(data, i, uint64(m.Index))
	}
	if len(m.SecondaryToken) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.SecondaryToken)))
		i += copy(data[i:], m.SecondaryToken)
	}
	return i, nil
}

func (m *CrossReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceDecoration != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.SourceDecoration.Size()))
		n2, err := m.SourceDecoration.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Referent != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.Referent.Size()))
		n3, err := m.Referent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TargetDecoration != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.TargetDecoration.Size()))
		n4, err := m.TargetDecoration.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SourceAnchor != nil {
		data[i] = 0x22
		i++
		i = encodeVarintInternal(data, i, uint64(m.SourceAnchor.Size()))
		n5, err := m.SourceAnchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TargetAnchor != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintInternal(data, i, uint64(m.TargetAnchor.Size()))
		n6, err := m.TargetAnchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CrossReference_Decoration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReference_Decoration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.File.Size()))
		n7, err := m.File.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Anchor != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.Anchor.Size()))
		n8, err := m.Anchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Kind) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	return i, nil
}

func (m *SortedKeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SortedKeyValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.SortKey) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.SortKey)))
		i += copy(data[i:], m.SortKey)
	}
	if len(m.Value) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *Path) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Path) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pivot != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.Pivot.Size()))
		n9, err := m.Pivot.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Edges) > 0 {
		for _, msg := range m.Edges {
			data[i] = 0x12
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Path_Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Path_Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.NodeKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.NodeKind)))
		i += copy(data[i:], m.NodeKind)
	}
	if m.Original != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Original.Size()))
		n10, err := m.Original.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Specialization != nil {
		nn11, err := m.Specialization.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *Path_Node_RawAnchor) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.RawAnchor != nil {
		data[i] = 0x52
		i++
		i = encodeVarintInternal(data, i, uint64(m.RawAnchor.Size()))
		n12, err := m.RawAnchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Path_Node_ExpandedAnchor) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ExpandedAnchor != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintInternal(data, i, uint64(m.ExpandedAnchor.Size()))
		n13, err := m.ExpandedAnchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Path_Node_File) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.File != nil {
		data[i] = 0x62
		i++
		i = encodeVarintInternal(data, i, uint64(m.File.Size()))
		n14, err := m.File.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *Path_Edge) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Path_Edge) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if m.Ordinal != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintInternal(data, i, uint64(m.Ordinal))
	}
	if m.Target != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Target.Size()))
		n15, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func encodeFixed64Internal(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Internal(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintInternal(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Source) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Facts) > 0 {
		for k, v := range m.Facts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovInternal(uint64(len(k))) + 1 + len(v) + sovInternal(uint64(len(v)))
			n += mapEntrySize + 1 + sovInternal(uint64(mapEntrySize))
		}
	}
	if len(m.EdgeGroups) > 0 {
		for k, v := range m.EdgeGroups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovInternal(uint64(len(k))) + 1 + l + sovInternal(uint64(l))
			n += mapEntrySize + 1 + sovInternal(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Source_Edge) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovInternal(uint64(m.Ordinal))
	}
	return n
}

func (m *Source_EdgeGroup) Size() (n int) {
	var l int
	_ = l
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	return n
}

func (m *PageToken) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovInternal(uint64(m.Index))
	}
	l = len(m.SecondaryToken)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func (m *CrossReference) Size() (n int) {
	var l int
	_ = l
	if m.SourceDecoration != nil {
		l = m.SourceDecoration.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Referent != nil {
		l = m.Referent.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.TargetDecoration != nil {
		l = m.TargetDecoration.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SourceAnchor != nil {
		l = m.SourceAnchor.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.TargetAnchor != nil {
		l = m.TargetAnchor.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func (m *CrossReference_Decoration) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func (m *SortedKeyValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.SortKey)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func (m *Path) Size() (n int) {
	var l int
	_ = l
	if m.Pivot != nil {
		l = m.Pivot.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	return n
}

func (m *Path_Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.NodeKind)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Original != nil {
		l = m.Original.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Specialization != nil {
		n += m.Specialization.Size()
	}
	return n
}

func (m *Path_Node_RawAnchor) Size() (n int) {
	var l int
	_ = l
	if m.RawAnchor != nil {
		l = m.RawAnchor.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}
func (m *Path_Node_ExpandedAnchor) Size() (n int) {
	var l int
	_ = l
	if m.ExpandedAnchor != nil {
		l = m.ExpandedAnchor.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}
func (m *Path_Node_File) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}
func (m *Path_Edge) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovInternal(uint64(m.Ordinal))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func sovInternal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Source) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthInternal
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthInternal
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Facts == nil {
				m.Facts = make(map[string][]byte)
			}
			m.Facts[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthInternal
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthInternal
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Source_EdgeGroup{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.EdgeGroups == nil {
				m.EdgeGroups = make(map[string]*Source_EdgeGroup)
			}
			m.EdgeGroups[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source_Edge) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source_EdgeGroup) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &Source_Edge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceDecoration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceDecoration == nil {
				m.SourceDecoration = &CrossReference_Decoration{}
			}
			if err := m.SourceDecoration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Referent == nil {
				m.Referent = &kythe_proto_serving.Node{}
			}
			if err := m.Referent.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDecoration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetDecoration == nil {
				m.TargetDecoration = &CrossReference_Decoration{}
			}
			if err := m.TargetDecoration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAnchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceAnchor == nil {
				m.SourceAnchor = &kythe_proto_serving.ExpandedAnchor{}
			}
			if err := m.SourceAnchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAnchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetAnchor == nil {
				m.TargetAnchor = &kythe_proto_serving.ExpandedAnchor{}
			}
			if err := m.TargetAnchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReference_Decoration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decoration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decoration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &kythe_proto_serving.File{}
			}
			if err := m.File.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &kythe_proto_serving.RawAnchor{}
			}
			if err := m.Anchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortedKeyValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortedKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortedKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pivot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pivot == nil {
				m.Pivot = &Path_Node{}
			}
			if err := m.Pivot.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &Path_Edge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path_Node) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Original == nil {
				m.Original = &kythe_proto_serving.Node{}
			}
			if err := m.Original.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAnchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &kythe_proto_serving.RawAnchor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Specialization = &Path_Node_RawAnchor{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandedAnchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &kythe_proto_serving.ExpandedAnchor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Specialization = &Path_Node_ExpandedAnchor{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &kythe_proto_serving.File{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Specialization = &Path_Node_File{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path_Edge) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Path_Node{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInternal(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInternal(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInternal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInternal   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorInternal = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x54, 0xdb, 0x6e, 0xd3, 0x4a,
	0x14, 0x8d, 0x13, 0x27, 0x6d, 0x76, 0x7a, 0xd2, 0x9c, 0x51, 0x75, 0x94, 0xfa, 0x48, 0x39, 0x3d,
	0x41, 0xa2, 0x7d, 0x80, 0x44, 0x2a, 0x2a, 0xad, 0x10, 0x08, 0x51, 0xda, 0x12, 0x51, 0x51, 0x55,
	0x53, 0xc4, 0x13, 0x52, 0x64, 0xec, 0x5d, 0xd7, 0x4a, 0x98, 0x89, 0xc6, 0xd3, 0x4b, 0xf8, 0x01,
	0x7e, 0x81, 0x57, 0xde, 0xf9, 0x0e, 0xc4, 0x1b, 0x7c, 0x02, 0x2a, 0x3f, 0x82, 0xe6, 0xe2, 0xd4,
	0x45, 0x6e, 0x53, 0x78, 0xf3, 0x1e, 0xaf, 0xb5, 0xf6, 0x9a, 0x3d, 0x6b, 0x06, 0xbc, 0xc1, 0x58,
	0x1e, 0x61, 0x77, 0x24, 0xb8, 0xe4, 0xdd, 0x98, 0x49, 0x14, 0xcc, 0x1f, 0x76, 0x74, 0x49, 0x16,
	0xf4, 0x3f, 0x53, 0x74, 0xd2, 0x7f, 0xde, 0x62, 0x96, 0x91, 0xa0, 0x38, 0x89, 0x59, 0x64, 0x30,
	0xed, 0xaf, 0x25, 0xa8, 0x1c, 0xf0, 0x63, 0x11, 0x20, 0xf9, 0x07, 0x2a, 0x32, 0x0e, 0x06, 0x28,
	0x9b, 0xce, 0x92, 0xb3, 0x52, 0xa5, 0xb6, 0x22, 0x8f, 0xa0, 0x7c, 0xe8, 0x07, 0x32, 0x69, 0x16,
	0x97, 0x4a, 0x2b, 0xb5, 0xd5, 0xe5, 0x4e, 0x5e, 0x8f, 0x8e, 0x11, 0xe9, 0xec, 0x28, 0xe4, 0x36,
	0x93, 0x62, 0x4c, 0x0d, 0x8b, 0xbc, 0x80, 0x1a, 0x86, 0x11, 0xf6, 0x23, 0xc1, 0x8f, 0x47, 0x49,
	0xb3, 0xa4, 0x45, 0xee, 0x5c, 0x2b, 0xb2, 0x1d, 0x46, 0xf8, 0x4c, 0xc3, 0x8d, 0x12, 0xe0, 0x64,
	0xc1, 0xdb, 0x00, 0x57, 0xfd, 0xbe, 0xd2, 0x6d, 0x13, 0x66, 0xb8, 0x08, 0x63, 0xe6, 0x0f, 0x9b,
	0xc5, 0x25, 0x67, 0xa5, 0x4c, 0xd3, 0xd2, 0xdb, 0x82, 0xea, 0x44, 0x98, 0xac, 0x43, 0x59, 0x89,
	0x26, 0x4d, 0x47, 0xfb, 0xf9, 0x7f, 0xaa, 0x1f, 0x6a, 0xf0, 0xde, 0x06, 0xc0, 0xc5, 0x1e, 0x49,
	0x03, 0x4a, 0x03, 0x1c, 0x5b, 0x0b, 0xea, 0x93, 0x2c, 0x40, 0xf9, 0xc4, 0x1f, 0x1e, 0xa3, 0xee,
	0x3e, 0x47, 0x4d, 0xf1, 0xa0, 0xb8, 0xe1, 0x78, 0x08, 0xf3, 0xbf, 0x6c, 0x2c, 0x87, 0xfe, 0x30,
	0x4b, 0xaf, 0xad, 0xde, 0xbe, 0xd9, 0x9c, 0x32, 0x6d, 0xda, 0xcf, 0xa1, 0xba, 0xef, 0x47, 0xf8,
	0x92, 0x0f, 0x90, 0x29, 0x37, 0x31, 0x0b, 0xf1, 0x4c, 0xb7, 0x28, 0x53, 0x53, 0x90, 0x65, 0x98,
	0x4f, 0x30, 0xe0, 0x2c, 0xf4, 0xc5, 0xb8, 0x2f, 0x15, 0x50, 0xb7, 0xab, 0xd2, 0xfa, 0x64, 0x59,
	0xd3, 0xdb, 0x1f, 0x5d, 0xa8, 0x3f, 0x15, 0x3c, 0x49, 0x28, 0x1e, 0xa2, 0x40, 0x16, 0x20, 0x79,
	0x0d, 0x7f, 0x27, 0xba, 0x7b, 0x3f, 0xc4, 0x80, 0x0b, 0x5f, 0xc6, 0x9c, 0x69, 0xf5, 0xda, 0x6a,
	0x37, 0xdf, 0xec, 0x65, 0x81, 0xce, 0xd6, 0x84, 0x46, 0x1b, 0x46, 0xe9, 0x62, 0x85, 0xac, 0xc1,
	0xac, 0x30, 0x48, 0x69, 0x27, 0xb0, 0x78, 0x49, 0x34, 0x0d, 0xef, 0x1e, 0x0f, 0x91, 0x4e, 0xa0,
	0xca, 0x94, 0xf4, 0x45, 0x84, 0x32, 0x6b, 0xaa, 0xf4, 0x87, 0xa6, 0x8c, 0x52, 0xc6, 0x54, 0x0f,
	0xfe, 0xb2, 0x5b, 0xf6, 0x59, 0x70, 0xc4, 0x45, 0xd3, 0xd5, 0xca, 0xb7, 0x72, 0x9d, 0x6d, 0x9f,
	0x8d, 0x7c, 0x16, 0x62, 0xf8, 0x44, 0x43, 0xe9, 0x9c, 0x61, 0x9a, 0x4a, 0x29, 0x59, 0x9f, 0x56,
	0xa9, 0xfc, 0x1b, 0x4a, 0x86, 0x69, 0x2a, 0xef, 0xbd, 0x03, 0x90, 0xb1, 0x78, 0x17, 0xdc, 0xc3,
	0x78, 0x88, 0xf6, 0x20, 0xf2, 0x67, 0xb6, 0x13, 0x0f, 0x91, 0x6a, 0x18, 0xb9, 0x0f, 0x15, 0x6b,
	0xc0, 0x0c, 0xb9, 0x95, 0x4b, 0xa0, 0xfe, 0xa9, 0xed, 0x6d, 0xd1, 0x84, 0x80, 0x3b, 0x88, 0x59,
	0xa8, 0x47, 0x5b, 0xa5, 0xfa, 0xbb, 0x7d, 0x00, 0xf5, 0x03, 0x2e, 0x24, 0x86, 0xbb, 0x38, 0x7e,
	0xa5, 0x52, 0x98, 0x93, 0xea, 0x45, 0x98, 0x4d, 0xb8, 0x90, 0x7d, 0xb5, 0x6c, 0x92, 0x36, 0xa3,
	0xea, 0xdd, 0xec, 0x7d, 0x29, 0x65, 0xee, 0x4b, 0xfb, 0x93, 0x0b, 0xee, 0xbe, 0x2f, 0x8f, 0xc8,
	0x1a, 0x94, 0x47, 0xf1, 0x09, 0x97, 0x76, 0x67, 0xff, 0xe5, 0x9f, 0xa6, 0x82, 0x9a, 0x4c, 0x18,
	0xb4, 0xa2, 0x99, 0xeb, 0x6d, 0xde, 0xac, 0xeb, 0x68, 0xd9, 0xcb, 0xfd, 0xb9, 0x08, 0xae, 0x92,
	0xb9, 0xf2, 0x75, 0xf9, 0x17, 0xaa, 0x8c, 0x87, 0xd8, 0xd7, 0x53, 0x30, 0x3b, 0x99, 0x55, 0x0b,
	0xbb, 0x31, 0x0b, 0x55, 0x78, 0xb9, 0x88, 0x23, 0xfd, 0xf6, 0x94, 0xa6, 0x86, 0x37, 0x85, 0x92,
	0xc7, 0x00, 0xc2, 0x3f, 0x4d, 0x13, 0x01, 0x37, 0x39, 0x90, 0x5e, 0x81, 0x56, 0x45, 0x5a, 0x90,
	0x3d, 0x98, 0x47, 0x9b, 0x95, 0x54, 0xa5, 0x76, 0xe3, 0x5c, 0xf5, 0x0a, 0xb4, 0x8e, 0x97, 0x56,
	0x48, 0xd7, 0x86, 0x69, 0x6e, 0x4a, 0x98, 0x7a, 0x05, 0x13, 0xa7, 0xcd, 0x06, 0xd4, 0x93, 0x11,
	0x06, 0xb1, 0x3f, 0x8c, 0xdf, 0xe9, 0x3c, 0x7a, 0x6f, 0xed, 0x2b, 0x9d, 0x06, 0xc6, 0xb9, 0x08,
	0xcc, 0xd5, 0x2f, 0x34, 0x59, 0x87, 0x8a, 0x09, 0xb9, 0x1d, 0xdf, 0xd4, 0xd3, 0xb6, 0xf0, 0xcd,
	0xc6, 0x97, 0xf3, 0x96, 0xf3, 0xed, 0xbc, 0xe5, 0x7c, 0x3f, 0x6f, 0x39, 0x1f, 0x7e, 0xb4, 0x0a,
	0x6f, 0x2a, 0x9a, 0x73, 0xef, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7c, 0xe3, 0x51, 0x17, 0x2d,
	0x07, 0x00, 0x00,
}
