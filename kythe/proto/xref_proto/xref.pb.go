// Code generated by protoc-gen-gogo.
// source: kythe/proto/xref.proto
// DO NOT EDIT!

/*
	Package xref_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/xref.proto

	It has these top-level messages:
		Location
		DecorationsRequest
		DecorationsReply
		CrossReferencesRequest
		Anchor
		Printable
		CrossReferencesReply
		DocumentationRequest
		DocumentationReply
*/
package xref_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_common "kythe.io/kythe/proto/common_proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Which types of snippets to return from a given CrossReferences or Decorations
// RPC.
// TODO(schroederc): extend snippet kinds to be (none, indexer-default, or
// always line-based) instead of (none, all).
type SnippetsKind int32

const (
	// Return no snippets.
	SnippetsKind_NONE SnippetsKind = 0
	// Return the default snippet for each item that has one.
	SnippetsKind_DEFAULT SnippetsKind = 1
)

var SnippetsKind_name = map[int32]string{
	0: "NONE",
	1: "DEFAULT",
}
var SnippetsKind_value = map[string]int32{
	"NONE":    0,
	"DEFAULT": 1,
}

func (x SnippetsKind) String() string {
	return proto.EnumName(SnippetsKind_name, int32(x))
}
func (SnippetsKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorXref, []int{0} }

type Location_Kind int32

const (
	// The entire file; the start and end fields are ignored.
	Location_FILE Location_Kind = 0
	// The point or span of file subtended by start and end.
	Location_SPAN Location_Kind = 1
)

var Location_Kind_name = map[int32]string{
	0: "FILE",
	1: "SPAN",
}
var Location_Kind_value = map[string]int32{
	"FILE": 0,
	"SPAN": 1,
}

func (x Location_Kind) String() string {
	return proto.EnumName(Location_Kind_name, int32(x))
}
func (Location_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorXref, []int{0, 0} }

type DecorationsRequest_SpanKind int32

const (
	// If the location is a SPAN, only decorations contained within the
	// specified window of the file are returned.  This is the default behavior.
	DecorationsRequest_WITHIN_SPAN DecorationsRequest_SpanKind = 0
	// If the location is a SPAN, any decorations that surround it are returned.
	DecorationsRequest_AROUND_SPAN DecorationsRequest_SpanKind = 1
)

var DecorationsRequest_SpanKind_name = map[int32]string{
	0: "WITHIN_SPAN",
	1: "AROUND_SPAN",
}
var DecorationsRequest_SpanKind_value = map[string]int32{
	"WITHIN_SPAN": 0,
	"AROUND_SPAN": 1,
}

func (x DecorationsRequest_SpanKind) String() string {
	return proto.EnumName(DecorationsRequest_SpanKind_name, int32(x))
}
func (DecorationsRequest_SpanKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{1, 0}
}

// What kind of override this is.
type DecorationsReply_Override_Kind int32

const (
	DecorationsReply_Override_OVERRIDES DecorationsReply_Override_Kind = 0
	DecorationsReply_Override_EXTENDS   DecorationsReply_Override_Kind = 1
)

var DecorationsReply_Override_Kind_name = map[int32]string{
	0: "OVERRIDES",
	1: "EXTENDS",
}
var DecorationsReply_Override_Kind_value = map[string]int32{
	"OVERRIDES": 0,
	"EXTENDS":   1,
}

func (x DecorationsReply_Override_Kind) String() string {
	return proto.EnumName(DecorationsReply_Override_Kind_name, int32(x))
}
func (DecorationsReply_Override_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{2, 1, 0}
}

type CrossReferencesRequest_DefinitionKind int32

const (
	// No definitions will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DEFINITIONS CrossReferencesRequest_DefinitionKind = 0
	// All known definition anchors reached by the "/kythe/edge/defines" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 1
	// Only definition anchors reached by the "/kythe/edge/defines" edge kind
	// will be populated in the CrossReferencesReply.
	CrossReferencesRequest_FULL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 2
	// Only definition anchors reached by the "/kythe/edge/defines/binding" edge
	// kind will be populated in the CrossReferencesReply.
	CrossReferencesRequest_BINDING_DEFINITIONS CrossReferencesRequest_DefinitionKind = 3
)

var CrossReferencesRequest_DefinitionKind_name = map[int32]string{
	0: "NO_DEFINITIONS",
	1: "ALL_DEFINITIONS",
	2: "FULL_DEFINITIONS",
	3: "BINDING_DEFINITIONS",
}
var CrossReferencesRequest_DefinitionKind_value = map[string]int32{
	"NO_DEFINITIONS":      0,
	"ALL_DEFINITIONS":     1,
	"FULL_DEFINITIONS":    2,
	"BINDING_DEFINITIONS": 3,
}

func (x CrossReferencesRequest_DefinitionKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DefinitionKind_name, int32(x))
}
func (CrossReferencesRequest_DefinitionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 0}
}

type CrossReferencesRequest_DeclarationKind int32

const (
	// No declarations will be populated in the CrossDeclarationsReply.
	CrossReferencesRequest_NO_DECLARATIONS CrossReferencesRequest_DeclarationKind = 0
	// When the source node is incomplete, all known declaration anchors reached
	// by the "/kythe/edge/defines" edge kind (or its variants) will be
	// populated in the CrossDeclarationsReply.
	CrossReferencesRequest_ALL_DECLARATIONS CrossReferencesRequest_DeclarationKind = 1
)

var CrossReferencesRequest_DeclarationKind_name = map[int32]string{
	0: "NO_DECLARATIONS",
	1: "ALL_DECLARATIONS",
}
var CrossReferencesRequest_DeclarationKind_value = map[string]int32{
	"NO_DECLARATIONS":  0,
	"ALL_DECLARATIONS": 1,
}

func (x CrossReferencesRequest_DeclarationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DeclarationKind_name, int32(x))
}
func (CrossReferencesRequest_DeclarationKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 1}
}

type CrossReferencesRequest_ReferenceKind int32

const (
	// No references will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_REFERENCES CrossReferencesRequest_ReferenceKind = 0
	// Only callgraph-related references as described in
	// http://www.kythe.io/docs/schema/callgraph.html
	CrossReferencesRequest_CALL_REFERENCES CrossReferencesRequest_ReferenceKind = 1
	// All references except those that are related to the callgraph.
	CrossReferencesRequest_NON_CALL_REFERENCES CrossReferencesRequest_ReferenceKind = 2
	// All known reference anchors reached by the "/kythe/edge/ref" edge kind
	// (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_REFERENCES CrossReferencesRequest_ReferenceKind = 3
)

var CrossReferencesRequest_ReferenceKind_name = map[int32]string{
	0: "NO_REFERENCES",
	1: "CALL_REFERENCES",
	2: "NON_CALL_REFERENCES",
	3: "ALL_REFERENCES",
}
var CrossReferencesRequest_ReferenceKind_value = map[string]int32{
	"NO_REFERENCES":       0,
	"CALL_REFERENCES":     1,
	"NON_CALL_REFERENCES": 2,
	"ALL_REFERENCES":      3,
}

func (x CrossReferencesRequest_ReferenceKind) String() string {
	return proto.EnumName(CrossReferencesRequest_ReferenceKind_name, int32(x))
}
func (CrossReferencesRequest_ReferenceKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 2}
}

type CrossReferencesRequest_CallerKind int32

const (
	// No callgraph information will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_CALLERS CrossReferencesRequest_CallerKind = 0
	// Callgraph information will be populated in the CrossReferencesReply.
	CrossReferencesRequest_DIRECT_CALLERS CrossReferencesRequest_CallerKind = 1
	// Callgraph information will be populated in the CrossReferencesReply.
	// Calls to override-related functions will also be considered.
	CrossReferencesRequest_OVERRIDE_CALLERS CrossReferencesRequest_CallerKind = 2
)

var CrossReferencesRequest_CallerKind_name = map[int32]string{
	0: "NO_CALLERS",
	1: "DIRECT_CALLERS",
	2: "OVERRIDE_CALLERS",
}
var CrossReferencesRequest_CallerKind_value = map[string]int32{
	"NO_CALLERS":       0,
	"DIRECT_CALLERS":   1,
	"OVERRIDE_CALLERS": 2,
}

func (x CrossReferencesRequest_CallerKind) String() string {
	return proto.EnumName(CrossReferencesRequest_CallerKind_name, int32(x))
}
func (CrossReferencesRequest_CallerKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 3}
}

// A Location represents a single span of zero or more contiguous bytes of a
// file or buffer.  An empty LOCATION denotes the entirety of the referenced
// file or buffer.
//
type Location struct {
	// The ticket of the file this location belongs to.  If the location
	// represents a memory buffer, the ticket should be omitted.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// What kind of location this is.
	Kind Location_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.Location_Kind" json:"kind,omitempty"`
	// If kind == SPAN, this is the represented span within the file.
	Span *kythe_proto_common.Span `protobuf:"bytes,5,opt,name=span" json:"span,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{0} }

func (m *Location) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *Location) GetKind() Location_Kind {
	if m != nil {
		return m.Kind
	}
	return Location_FILE
}

func (m *Location) GetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.Span
	}
	return nil
}

type DecorationsRequest struct {
	// The location of the file to fetch decorations for.  The ticket of location
	// must be non-empty.  It is an error in any case if location is invalid.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// How to treat SPAN locations.
	SpanKind DecorationsRequest_SpanKind `protobuf:"varint,10,opt,name=span_kind,json=spanKind,proto3,enum=kythe.proto.DecorationsRequest_SpanKind" json:"span_kind,omitempty"`
	// If dirty_buffer is non-empty, the results will be adjusted (patched) to
	// account for the regions of the specified file differing from the contents
	// of the dirty buffer.
	DirtyBuffer []byte `protobuf:"bytes,2,opt,name=dirty_buffer,json=dirtyBuffer,proto3" json:"dirty_buffer,omitempty"`
	// If true, return the encoded source text for the selected window.  Source
	// text is not affected by patching.
	SourceText bool `protobuf:"varint,3,opt,name=source_text,json=sourceText,proto3" json:"source_text,omitempty"`
	// If true, return reference edges whose source nodes are located in the
	// selected window.  References are affected by patching.
	References bool `protobuf:"varint,4,opt,name=references,proto3" json:"references,omitempty"`
	// If true, return definition locations, if possible, for each returned
	// reference target in the DecorationsReply.
	TargetDefinitions bool `protobuf:"varint,6,opt,name=target_definitions,json=targetDefinitions,proto3" json:"target_definitions,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
	// (graph.proto) for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// If true, for every defines/binding Reference in the reply, a NodeInfo
	// will be provided for each node that Reference extends or overrides.
	// Furthermore, if definition_locations is true, the response's
	// definition_locations field will include (where possible) the locations of
	// the definitions of the nodes that are extended or overridden.
	ExtendsOverrides bool `protobuf:"varint,7,opt,name=extends_overrides,json=extendsOverrides,proto3" json:"extends_overrides,omitempty"`
	// If true, return diagnostics for the given file.
	Diagnostics bool `protobuf:"varint,8,opt,name=diagnostics,proto3" json:"diagnostics,omitempty"`
	// What kind of snippets to return (or none).
	Snippets SnippetsKind `protobuf:"varint,9,opt,name=snippets,proto3,enum=kythe.proto.SnippetsKind" json:"snippets,omitempty"`
}

func (m *DecorationsRequest) Reset()                    { *m = DecorationsRequest{} }
func (m *DecorationsRequest) String() string            { return proto.CompactTextString(m) }
func (*DecorationsRequest) ProtoMessage()               {}
func (*DecorationsRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{1} }

func (m *DecorationsRequest) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsRequest) GetSpanKind() DecorationsRequest_SpanKind {
	if m != nil {
		return m.SpanKind
	}
	return DecorationsRequest_WITHIN_SPAN
}

func (m *DecorationsRequest) GetDirtyBuffer() []byte {
	if m != nil {
		return m.DirtyBuffer
	}
	return nil
}

func (m *DecorationsRequest) GetSourceText() bool {
	if m != nil {
		return m.SourceText
	}
	return false
}

func (m *DecorationsRequest) GetReferences() bool {
	if m != nil {
		return m.References
	}
	return false
}

func (m *DecorationsRequest) GetTargetDefinitions() bool {
	if m != nil {
		return m.TargetDefinitions
	}
	return false
}

func (m *DecorationsRequest) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *DecorationsRequest) GetExtendsOverrides() bool {
	if m != nil {
		return m.ExtendsOverrides
	}
	return false
}

func (m *DecorationsRequest) GetDiagnostics() bool {
	if m != nil {
		return m.Diagnostics
	}
	return false
}

func (m *DecorationsRequest) GetSnippets() SnippetsKind {
	if m != nil {
		return m.Snippets
	}
	return SnippetsKind_NONE
}

type DecorationsReply struct {
	// The normalized location for which decorations are returned.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The encoded source text for the selected window.
	SourceText []byte `protobuf:"bytes,2,opt,name=source_text,json=sourceText,proto3" json:"source_text,omitempty"`
	Encoding   string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// The reference edges located in the specified window.
	Reference []*DecorationsReply_Reference `protobuf:"bytes,4,rep,name=reference" json:"reference,omitempty"`
	// If requested, a list of diagnostics applying to the requested file location.
	Diagnostic []*kythe_proto_common.Diagnostic `protobuf:"bytes,5,rep,name=diagnostic" json:"diagnostic,omitempty"`
	// This field will contain one entry, keyed by ticket, for each distinct node
	// referenced by a reference edge that has at least 1 non-filtered fact.
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,15,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Each anchor cited as a target definition in the references/overrides.  The
	// map is keyed by each anchor's ticket.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,16,rep,name=definition_locations,json=definitionLocations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Maps from semantic nodes on the right-hand side of defines/binding
	// references to the list of their overrides.
	ExtendsOverrides map[string]*DecorationsReply_Overrides `protobuf:"bytes,17,rep,name=extends_overrides,json=extendsOverrides" json:"extends_overrides,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DecorationsReply) Reset()                    { *m = DecorationsReply{} }
func (m *DecorationsReply) String() string            { return proto.CompactTextString(m) }
func (*DecorationsReply) ProtoMessage()               {}
func (*DecorationsReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{2} }

func (m *DecorationsReply) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsReply) GetSourceText() []byte {
	if m != nil {
		return m.SourceText
	}
	return nil
}

func (m *DecorationsReply) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *DecorationsReply) GetReference() []*DecorationsReply_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *DecorationsReply) GetDiagnostic() []*kythe_proto_common.Diagnostic {
	if m != nil {
		return m.Diagnostic
	}
	return nil
}

func (m *DecorationsReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DecorationsReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

func (m *DecorationsReply) GetExtendsOverrides() map[string]*DecorationsReply_Overrides {
	if m != nil {
		return m.ExtendsOverrides
	}
	return nil
}

// Represents a reference edge source ---KIND---> target.  Each source is an
// anchor within the requested source location.
type DecorationsReply_Reference struct {
	TargetTicket string `protobuf:"bytes,2,opt,name=target_ticket,json=targetTicket,proto3" json:"target_ticket,omitempty"`
	Kind         string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Anchor ticket of the target's definition.  Populated only if
	// target_definitions is true in the DecorationsRequest and the target has
	// a single unambiguous definition.  For each ticket, an Anchor will be
	// populated in the top-level definition_locations map.
	TargetDefinition string `protobuf:"bytes,4,opt,name=target_definition,json=targetDefinition,proto3" json:"target_definition,omitempty"`
	// The reference's span within the source file.
	Span *kythe_proto_common.Span `protobuf:"bytes,5,opt,name=span" json:"span,omitempty"`
}

func (m *DecorationsReply_Reference) Reset()         { *m = DecorationsReply_Reference{} }
func (m *DecorationsReply_Reference) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Reference) ProtoMessage()    {}
func (*DecorationsReply_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{2, 0}
}

func (m *DecorationsReply_Reference) GetTargetTicket() string {
	if m != nil {
		return m.TargetTicket
	}
	return ""
}

func (m *DecorationsReply_Reference) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *DecorationsReply_Reference) GetTargetDefinition() string {
	if m != nil {
		return m.TargetDefinition
	}
	return ""
}

func (m *DecorationsReply_Reference) GetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.Span
	}
	return nil
}

type DecorationsReply_Override struct {
	// The target of the override.
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// Anchor ticket of the override target's definition.  Populated only if
	// target_definitions is true in the DecorationsRequest and the target has
	// a single unambiguous definition.  For each ticket, an Anchor will be
	// populated in the top-level definition_locations map.
	TargetDefinition string `protobuf:"bytes,5,opt,name=target_definition,json=targetDefinition,proto3" json:"target_definition,omitempty"`
	// The kind of override.
	Kind DecorationsReply_Override_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.DecorationsReply_Override_Kind" json:"kind,omitempty"`
	// A display name for the object at ticket.
	MarkedSource *kythe_proto_common.MarkedSource `protobuf:"bytes,4,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
}

func (m *DecorationsReply_Override) Reset()                    { *m = DecorationsReply_Override{} }
func (m *DecorationsReply_Override) String() string            { return proto.CompactTextString(m) }
func (*DecorationsReply_Override) ProtoMessage()               {}
func (*DecorationsReply_Override) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{2, 1} }

func (m *DecorationsReply_Override) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *DecorationsReply_Override) GetTargetDefinition() string {
	if m != nil {
		return m.TargetDefinition
	}
	return ""
}

func (m *DecorationsReply_Override) GetKind() DecorationsReply_Override_Kind {
	if m != nil {
		return m.Kind
	}
	return DecorationsReply_Override_OVERRIDES
}

func (m *DecorationsReply_Override) GetMarkedSource() *kythe_proto_common.MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

type DecorationsReply_Overrides struct {
	Override []*DecorationsReply_Override `protobuf:"bytes,1,rep,name=override" json:"override,omitempty"`
}

func (m *DecorationsReply_Overrides) Reset()         { *m = DecorationsReply_Overrides{} }
func (m *DecorationsReply_Overrides) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Overrides) ProtoMessage()    {}
func (*DecorationsReply_Overrides) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{2, 2}
}

func (m *DecorationsReply_Overrides) GetOverride() []*DecorationsReply_Override {
	if m != nil {
		return m.Override
	}
	return nil
}

type CrossReferencesRequest struct {
	// Set of nodes for which to return their cross-references.  Must be
	// non-empty.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// Determines what kind of definition anchors, if any, should be returned in
	// the response.  See the documentation for each DefinitionKind for more
	// information.
	DefinitionKind CrossReferencesRequest_DefinitionKind `protobuf:"varint,2,opt,name=definition_kind,json=definitionKind,proto3,enum=kythe.proto.CrossReferencesRequest_DefinitionKind" json:"definition_kind,omitempty"`
	// Determines what kind of declaration anchors, if any, should be returned in
	// the response.  See the documentation for each DeclarationKind for more
	// information.
	DeclarationKind CrossReferencesRequest_DeclarationKind `protobuf:"varint,7,opt,name=declaration_kind,json=declarationKind,proto3,enum=kythe.proto.CrossReferencesRequest_DeclarationKind" json:"declaration_kind,omitempty"`
	// Determines what kind of reference anchors, if any, should be returned in
	// the response.  See the documentation for each ReferenceKind for more
	// information.
	ReferenceKind CrossReferencesRequest_ReferenceKind `protobuf:"varint,3,opt,name=reference_kind,json=referenceKind,proto3,enum=kythe.proto.CrossReferencesRequest_ReferenceKind" json:"reference_kind,omitempty"`
	// Determines what kind of callgraph information, if any, should be returned
	// in the response.  See the documentation for each CallerKind for more
	// information.
	CallerKind CrossReferencesRequest_CallerKind `protobuf:"varint,12,opt,name=caller_kind,json=callerKind,proto3,enum=kythe.proto.CrossReferencesRequest_CallerKind" json:"caller_kind,omitempty"`
	// Collection of filter globs that determines which facts will be returned for
	// the related nodes of each requested node.  If filter is empty or unset, no
	// node facts or related nodes are returned.  See EdgesRequest (graph.proto)
	// for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// Determines whether each Anchor in the response should have its text field
	// populated.
	AnchorText bool `protobuf:"varint,6,opt,name=anchor_text,json=anchorText,proto3" json:"anchor_text,omitempty"`
	// Determines whether each NodeInfo matching the above filters will have its
	// definition location populated, if known.
	NodeDefinitions bool `protobuf:"varint,8,opt,name=node_definitions,json=nodeDefinitions,proto3" json:"node_definitions,omitempty"`
	// Enable the experimental generation of signatures in the
	// CrossReferencesReply.  Enabling this currently causes multiple lookups and
	// can significantly impact latency.  Once latency concerns have been
	// addressed, this field will be removed and signatures will be returned by
	// default.
	// TODO(T156): remove this flag; always enable feature
	ExperimentalSignatures bool `protobuf:"varint,100,opt,name=experimental_signatures,json=experimentalSignatures,proto3" json:"experimental_signatures,omitempty"`
	// The cross-references matching a request are organized into logical pages.
	// The size of each page is a number of distinct cross-references
	// (definitions, references, documentation, and related nodes).
	//
	// If page_token is empty, cross-references will be returned starting at the
	// beginning of the sequence; otherwise the starting point named by the
	// page_token will be used.  Legal values of page_token are returned by the
	// server in the next_page_token field of the CrossReferencesReply.  A page
	// token should be treated as an opaque value by the client, and is valid only
	// relative to a particular CrossReferencesRequest.  If an invalid page token
	// is requested, the server will return an error.
	//
	// If page_size > 0, at most that number of cross-references will be returned
	// by the service for this request (see ReferenceSet and CrossReferencesReply
	// below).  If page_size = 0, the default, the server will assume a reasonable
	// default page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer cross-references than the requested
	// page_size, even if more are available, save that it must return at least 1
	// edge if any are available at all.
	PageSize  int32  `protobuf:"varint,10,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,11,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// What kind of snippets to return (or none).
	Snippets SnippetsKind `protobuf:"varint,13,opt,name=snippets,proto3,enum=kythe.proto.SnippetsKind" json:"snippets,omitempty"`
}

func (m *CrossReferencesRequest) Reset()                    { *m = CrossReferencesRequest{} }
func (m *CrossReferencesRequest) String() string            { return proto.CompactTextString(m) }
func (*CrossReferencesRequest) ProtoMessage()               {}
func (*CrossReferencesRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{3} }

func (m *CrossReferencesRequest) GetTicket() []string {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *CrossReferencesRequest) GetDefinitionKind() CrossReferencesRequest_DefinitionKind {
	if m != nil {
		return m.DefinitionKind
	}
	return CrossReferencesRequest_NO_DEFINITIONS
}

func (m *CrossReferencesRequest) GetDeclarationKind() CrossReferencesRequest_DeclarationKind {
	if m != nil {
		return m.DeclarationKind
	}
	return CrossReferencesRequest_NO_DECLARATIONS
}

func (m *CrossReferencesRequest) GetReferenceKind() CrossReferencesRequest_ReferenceKind {
	if m != nil {
		return m.ReferenceKind
	}
	return CrossReferencesRequest_NO_REFERENCES
}

func (m *CrossReferencesRequest) GetCallerKind() CrossReferencesRequest_CallerKind {
	if m != nil {
		return m.CallerKind
	}
	return CrossReferencesRequest_NO_CALLERS
}

func (m *CrossReferencesRequest) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *CrossReferencesRequest) GetAnchorText() bool {
	if m != nil {
		return m.AnchorText
	}
	return false
}

func (m *CrossReferencesRequest) GetNodeDefinitions() bool {
	if m != nil {
		return m.NodeDefinitions
	}
	return false
}

func (m *CrossReferencesRequest) GetExperimentalSignatures() bool {
	if m != nil {
		return m.ExperimentalSignatures
	}
	return false
}

func (m *CrossReferencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *CrossReferencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *CrossReferencesRequest) GetSnippets() SnippetsKind {
	if m != nil {
		return m.Snippets
	}
	return SnippetsKind_NONE
}

type Anchor struct {
	// Ticket of the anchor node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the anchor's relationship with its referenced node
	Kind string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	// Parent ticket of the anchor; this is the file containing the anchor
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// Span of the anchor within its parent's text
	Span *kythe_proto_common.Span `protobuf:"bytes,10,opt,name=span" json:"span,omitempty"`
	// The anchor's spanning text within the anchor parent's text
	Text string `protobuf:"bytes,6,opt,name=text,proto3" json:"text,omitempty"`
	// User-readable snippet of the anchor parent's text at the location of this
	// anchor
	Snippet string `protobuf:"bytes,7,opt,name=snippet,proto3" json:"snippet,omitempty"`
	// Span of the anchor's snippet within its parent's text
	SnippetSpan *kythe_proto_common.Span `protobuf:"bytes,11,opt,name=snippet_span,json=snippetSpan" json:"snippet_span,omitempty"`
}

func (m *Anchor) Reset()                    { *m = Anchor{} }
func (m *Anchor) String() string            { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()               {}
func (*Anchor) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{4} }

func (m *Anchor) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *Anchor) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Anchor) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *Anchor) GetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Anchor) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Anchor) GetSnippet() string {
	if m != nil {
		return m.Snippet
	}
	return ""
}

func (m *Anchor) GetSnippetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.SnippetSpan
	}
	return nil
}

type Printable struct {
	// Raw text that can be displayed to the user (but may also contain
	// markup that can be interpreted, like Doxygen comments). Links are
	// marked using []. \ is an escape character (where possible escape
	// sequences are \[, \], and \\).
	RawText string `protobuf:"bytes,1,opt,name=raw_text,json=rawText,proto3" json:"raw_text,omitempty"`
	// Annotations for spans in raw_text. The ith Link corresponds to the span
	// starting at the ith [.
	Link []*kythe_proto_common.Link `protobuf:"bytes,2,rep,name=link" json:"link,omitempty"`
}

func (m *Printable) Reset()                    { *m = Printable{} }
func (m *Printable) String() string            { return proto.CompactTextString(m) }
func (*Printable) ProtoMessage()               {}
func (*Printable) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{5} }

func (m *Printable) GetRawText() string {
	if m != nil {
		return m.RawText
	}
	return ""
}

func (m *Printable) GetLink() []*kythe_proto_common.Link {
	if m != nil {
		return m.Link
	}
	return nil
}

type CrossReferencesReply struct {
	// Total number of cross-references on all pages matching requested filters.
	Total *CrossReferencesReply_Total `protobuf:"bytes,5,opt,name=total" json:"total,omitempty"`
	// Sets of cross-references for each requested node
	CrossReferences map[string]*CrossReferencesReply_CrossReferenceSet `protobuf:"bytes,1,rep,name=cross_references,json=crossReferences" json:"cross_references,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// The facts left from the requested filters of the related node facts
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Map from the definition tickets referred to in each NodeInfo to their
	// Anchor.  This map will only be returned if the
	// CrossReferencesRequest.node_definitions switch is true.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,3,rep,name=definition_locations,json=definitionLocations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// If there are additional pages of cross-references after the ones returned
	// in this reply, next_page_token is the page token that may be passed to
	// fetch the next page in sequence after this one.  If there are no additional
	// cross-references, this field will be empty.
	NextPageToken string `protobuf:"bytes,10,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *CrossReferencesReply) Reset()                    { *m = CrossReferencesReply{} }
func (m *CrossReferencesReply) String() string            { return proto.CompactTextString(m) }
func (*CrossReferencesReply) ProtoMessage()               {}
func (*CrossReferencesReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{6} }

func (m *CrossReferencesReply) GetTotal() *CrossReferencesReply_Total {
	if m != nil {
		return m.Total
	}
	return nil
}

func (m *CrossReferencesReply) GetCrossReferences() map[string]*CrossReferencesReply_CrossReferenceSet {
	if m != nil {
		return m.CrossReferences
	}
	return nil
}

func (m *CrossReferencesReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CrossReferencesReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

func (m *CrossReferencesReply) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CrossReferencesReply_RelatedNode struct {
	// Ticket of the node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the node's relation
	RelationKind string `protobuf:"bytes,2,opt,name=relation_kind,json=relationKind,proto3" json:"relation_kind,omitempty"`
	// Optional ordinal for edges of the same relation_kind.
	Ordinal int32 `protobuf:"varint,3,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *CrossReferencesReply_RelatedNode) Reset()         { *m = CrossReferencesReply_RelatedNode{} }
func (m *CrossReferencesReply_RelatedNode) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedNode) ProtoMessage()    {}
func (*CrossReferencesReply_RelatedNode) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{6, 0}
}

func (m *CrossReferencesReply_RelatedNode) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *CrossReferencesReply_RelatedNode) GetRelationKind() string {
	if m != nil {
		return m.RelationKind
	}
	return ""
}

func (m *CrossReferencesReply_RelatedNode) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

type CrossReferencesReply_RelatedAnchor struct {
	// The anchor covering the related object.
	Anchor *Anchor `protobuf:"bytes,1,opt,name=anchor" json:"anchor,omitempty"`
	// A name for the related object.
	MarkedSource *kythe_proto_common.MarkedSource `protobuf:"bytes,5,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
	// Specific locations, usually within the related object, that caused
	// the relationship to exist. This field is relevant to caller sets.
	Site []*Anchor `protobuf:"bytes,3,rep,name=site" json:"site,omitempty"`
	// The relevant semantic object. Populated for callers.
	Ticket string `protobuf:"bytes,4,opt,name=ticket,proto3" json:"ticket,omitempty"`
}

func (m *CrossReferencesReply_RelatedAnchor) Reset()         { *m = CrossReferencesReply_RelatedAnchor{} }
func (m *CrossReferencesReply_RelatedAnchor) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedAnchor) ProtoMessage()    {}
func (*CrossReferencesReply_RelatedAnchor) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{6, 1}
}

func (m *CrossReferencesReply_RelatedAnchor) GetAnchor() *Anchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *CrossReferencesReply_RelatedAnchor) GetMarkedSource() *kythe_proto_common.MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

func (m *CrossReferencesReply_RelatedAnchor) GetSite() []*Anchor {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *CrossReferencesReply_RelatedAnchor) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

type CrossReferencesReply_CrossReferenceSet struct {
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// A name for the given node.
	MarkedSource *kythe_proto_common.MarkedSource `protobuf:"bytes,8,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
	// The set of definitions for the given node.
	Definition []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,2,rep,name=definition" json:"definition,omitempty"`
	// The set of declarations for the given node.
	Declaration []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,5,rep,name=declaration" json:"declaration,omitempty"`
	// The set of simple references for the given node.
	Reference []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,3,rep,name=reference" json:"reference,omitempty"`
	// The set of callers for the given node.
	Caller []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,6,rep,name=caller" json:"caller,omitempty"`
	// The set of related nodes to the given node.
	RelatedNode []*CrossReferencesReply_RelatedNode `protobuf:"bytes,10,rep,name=related_node,json=relatedNode" json:"related_node,omitempty"`
}

func (m *CrossReferencesReply_CrossReferenceSet) Reset() {
	*m = CrossReferencesReply_CrossReferenceSet{}
}
func (m *CrossReferencesReply_CrossReferenceSet) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_CrossReferenceSet) ProtoMessage()    {}
func (*CrossReferencesReply_CrossReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{6, 2}
}

func (m *CrossReferencesReply_CrossReferenceSet) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *CrossReferencesReply_CrossReferenceSet) GetMarkedSource() *kythe_proto_common.MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDefinition() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDeclaration() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Declaration
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetReference() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetCaller() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Caller
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetRelatedNode() []*CrossReferencesReply_RelatedNode {
	if m != nil {
		return m.RelatedNode
	}
	return nil
}

type CrossReferencesReply_Total struct {
	Definitions            int64            `protobuf:"varint,1,opt,name=definitions,proto3" json:"definitions,omitempty"`
	Declarations           int64            `protobuf:"varint,2,opt,name=declarations,proto3" json:"declarations,omitempty"`
	References             int64            `protobuf:"varint,3,opt,name=references,proto3" json:"references,omitempty"`
	Documentation          int64            `protobuf:"varint,4,opt,name=documentation,proto3" json:"documentation,omitempty"`
	Callers                int64            `protobuf:"varint,5,opt,name=callers,proto3" json:"callers,omitempty"`
	RelatedNodesByRelation map[string]int64 `protobuf:"bytes,6,rep,name=related_nodes_by_relation,json=relatedNodesByRelation" json:"related_nodes_by_relation,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *CrossReferencesReply_Total) Reset()         { *m = CrossReferencesReply_Total{} }
func (m *CrossReferencesReply_Total) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_Total) ProtoMessage()    {}
func (*CrossReferencesReply_Total) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{6, 3}
}

func (m *CrossReferencesReply_Total) GetDefinitions() int64 {
	if m != nil {
		return m.Definitions
	}
	return 0
}

func (m *CrossReferencesReply_Total) GetDeclarations() int64 {
	if m != nil {
		return m.Declarations
	}
	return 0
}

func (m *CrossReferencesReply_Total) GetReferences() int64 {
	if m != nil {
		return m.References
	}
	return 0
}

func (m *CrossReferencesReply_Total) GetDocumentation() int64 {
	if m != nil {
		return m.Documentation
	}
	return 0
}

func (m *CrossReferencesReply_Total) GetCallers() int64 {
	if m != nil {
		return m.Callers
	}
	return 0
}

func (m *CrossReferencesReply_Total) GetRelatedNodesByRelation() map[string]int64 {
	if m != nil {
		return m.RelatedNodesByRelation
	}
	return nil
}

type DocumentationRequest struct {
	// Semantic tickets about which documentation is sought.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned. The filter applies to ALL documented and linked nodes.
	// See EdgesRequest (graph.proto) for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
	// If set, this DocumentationRequest will return documents for the requested
	// tickets as well as their immediate semantic descendants.
	IncludeChildren bool `protobuf:"varint,3,opt,name=include_children,json=includeChildren,proto3" json:"include_children,omitempty"`
}

func (m *DocumentationRequest) Reset()                    { *m = DocumentationRequest{} }
func (m *DocumentationRequest) String() string            { return proto.CompactTextString(m) }
func (*DocumentationRequest) ProtoMessage()               {}
func (*DocumentationRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{7} }

func (m *DocumentationRequest) GetTicket() []string {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *DocumentationRequest) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *DocumentationRequest) GetIncludeChildren() bool {
	if m != nil {
		return m.IncludeChildren
	}
	return false
}

type DocumentationReply struct {
	Document []*DocumentationReply_Document `protobuf:"bytes,1,rep,name=document" json:"document,omitempty"`
	// The facts left from the requested filters of the documented node facts.
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Map from the definition anchor tickets referred to in each NodeInfo to
	// their corresponding Anchor data.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,3,rep,name=definition_locations,json=definitionLocations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DocumentationReply) Reset()                    { *m = DocumentationReply{} }
func (m *DocumentationReply) String() string            { return proto.CompactTextString(m) }
func (*DocumentationReply) ProtoMessage()               {}
func (*DocumentationReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{8} }

func (m *DocumentationReply) GetDocument() []*DocumentationReply_Document {
	if m != nil {
		return m.Document
	}
	return nil
}

func (m *DocumentationReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DocumentationReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

type DocumentationReply_Document struct {
	// The ticket to which this Document refers.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Documentation that can be displayed to the user.
	Text *Printable `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// A signature that can be displayed to the user. For variables, this
	// may just be the variable name; for functions, this may be some version
	// of the function prototype.
	Signature    *Printable                       `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	Type         *Printable                       `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	Initializer  *Printable                       `protobuf:"bytes,5,opt,name=initializer" json:"initializer,omitempty"`
	DefinedBy    *Printable                       `protobuf:"bytes,6,opt,name=defined_by,json=definedBy" json:"defined_by,omitempty"`
	MarkedSource *kythe_proto_common.MarkedSource `protobuf:"bytes,8,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
	// The children of this Document. This relationship may be distinct from the
	// `childof` relationship.
	Children []*DocumentationReply_Document `protobuf:"bytes,9,rep,name=children" json:"children,omitempty"`
}

func (m *DocumentationReply_Document) Reset()         { *m = DocumentationReply_Document{} }
func (m *DocumentationReply_Document) String() string { return proto.CompactTextString(m) }
func (*DocumentationReply_Document) ProtoMessage()    {}
func (*DocumentationReply_Document) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{8, 0}
}

func (m *DocumentationReply_Document) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *DocumentationReply_Document) GetText() *Printable {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *DocumentationReply_Document) GetSignature() *Printable {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DocumentationReply_Document) GetType() *Printable {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DocumentationReply_Document) GetInitializer() *Printable {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *DocumentationReply_Document) GetDefinedBy() *Printable {
	if m != nil {
		return m.DefinedBy
	}
	return nil
}

func (m *DocumentationReply_Document) GetMarkedSource() *kythe_proto_common.MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

func (m *DocumentationReply_Document) GetChildren() []*DocumentationReply_Document {
	if m != nil {
		return m.Children
	}
	return nil
}

func init() {
	proto.RegisterType((*Location)(nil), "kythe.proto.Location")
	proto.RegisterType((*DecorationsRequest)(nil), "kythe.proto.DecorationsRequest")
	proto.RegisterType((*DecorationsReply)(nil), "kythe.proto.DecorationsReply")
	proto.RegisterType((*DecorationsReply_Reference)(nil), "kythe.proto.DecorationsReply.Reference")
	proto.RegisterType((*DecorationsReply_Override)(nil), "kythe.proto.DecorationsReply.Override")
	proto.RegisterType((*DecorationsReply_Overrides)(nil), "kythe.proto.DecorationsReply.Overrides")
	proto.RegisterType((*CrossReferencesRequest)(nil), "kythe.proto.CrossReferencesRequest")
	proto.RegisterType((*Anchor)(nil), "kythe.proto.Anchor")
	proto.RegisterType((*Printable)(nil), "kythe.proto.Printable")
	proto.RegisterType((*CrossReferencesReply)(nil), "kythe.proto.CrossReferencesReply")
	proto.RegisterType((*CrossReferencesReply_RelatedNode)(nil), "kythe.proto.CrossReferencesReply.RelatedNode")
	proto.RegisterType((*CrossReferencesReply_RelatedAnchor)(nil), "kythe.proto.CrossReferencesReply.RelatedAnchor")
	proto.RegisterType((*CrossReferencesReply_CrossReferenceSet)(nil), "kythe.proto.CrossReferencesReply.CrossReferenceSet")
	proto.RegisterType((*CrossReferencesReply_Total)(nil), "kythe.proto.CrossReferencesReply.Total")
	proto.RegisterType((*DocumentationRequest)(nil), "kythe.proto.DocumentationRequest")
	proto.RegisterType((*DocumentationReply)(nil), "kythe.proto.DocumentationReply")
	proto.RegisterType((*DocumentationReply_Document)(nil), "kythe.proto.DocumentationReply.Document")
	proto.RegisterEnum("kythe.proto.SnippetsKind", SnippetsKind_name, SnippetsKind_value)
	proto.RegisterEnum("kythe.proto.Location_Kind", Location_Kind_name, Location_Kind_value)
	proto.RegisterEnum("kythe.proto.DecorationsRequest_SpanKind", DecorationsRequest_SpanKind_name, DecorationsRequest_SpanKind_value)
	proto.RegisterEnum("kythe.proto.DecorationsReply_Override_Kind", DecorationsReply_Override_Kind_name, DecorationsReply_Override_Kind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DefinitionKind", CrossReferencesRequest_DefinitionKind_name, CrossReferencesRequest_DefinitionKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DeclarationKind", CrossReferencesRequest_DeclarationKind_name, CrossReferencesRequest_DeclarationKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_ReferenceKind", CrossReferencesRequest_ReferenceKind_name, CrossReferencesRequest_ReferenceKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_CallerKind", CrossReferencesRequest_CallerKind_name, CrossReferencesRequest_CallerKind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for XRefService service

type XRefServiceClient interface {
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error)
	// Documentation takes a set of tickets for semantic objects and returns
	// documentation about them, including generated signatures and
	// user-provided text. The documentation may refer to tickets for other
	// nodes in the graph.
	Documentation(ctx context.Context, in *DocumentationRequest, opts ...grpc.CallOption) (*DocumentationReply, error)
}

type xRefServiceClient struct {
	cc *grpc.ClientConn
}

func NewXRefServiceClient(cc *grpc.ClientConn) XRefServiceClient {
	return &xRefServiceClient{cc}
}

func (c *xRefServiceClient) Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error) {
	out := new(DecorationsReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Decorations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error) {
	out := new(CrossReferencesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/CrossReferences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Documentation(ctx context.Context, in *DocumentationRequest, opts ...grpc.CallOption) (*DocumentationReply, error) {
	out := new(DocumentationReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Documentation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XRefService service

type XRefServiceServer interface {
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(context.Context, *DecorationsRequest) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(context.Context, *CrossReferencesRequest) (*CrossReferencesReply, error)
	// Documentation takes a set of tickets for semantic objects and returns
	// documentation about them, including generated signatures and
	// user-provided text. The documentation may refer to tickets for other
	// nodes in the graph.
	Documentation(context.Context, *DocumentationRequest) (*DocumentationReply, error)
}

func RegisterXRefServiceServer(s *grpc.Server, srv XRefServiceServer) {
	s.RegisterService(&_XRefService_serviceDesc, srv)
}

func _XRefService_Decorations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecorationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Decorations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Decorations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Decorations(ctx, req.(*DecorationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_CrossReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CrossReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).CrossReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/CrossReferences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).CrossReferences(ctx, req.(*CrossReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Documentation(ctx, req.(*DocumentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _XRefService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.XRefService",
	HandlerType: (*XRefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Decorations",
			Handler:    _XRefService_Decorations_Handler,
		},
		{
			MethodName: "CrossReferences",
			Handler:    _XRefService_CrossReferences_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _XRefService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kythe/proto/xref.proto",
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Kind))
	}
	if m.Span != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Span.Size()))
		n1, err := m.Span.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *DecorationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecorationsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Location.Size()))
		n2, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.DirtyBuffer) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.DirtyBuffer)))
		i += copy(dAtA[i:], m.DirtyBuffer)
	}
	if m.SourceText {
		dAtA[i] = 0x18
		i++
		if m.SourceText {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.References {
		dAtA[i] = 0x20
		i++
		if m.References {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TargetDefinitions {
		dAtA[i] = 0x30
		i++
		if m.TargetDefinitions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExtendsOverrides {
		dAtA[i] = 0x38
		i++
		if m.ExtendsOverrides {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Diagnostics {
		dAtA[i] = 0x40
		i++
		if m.Diagnostics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Snippets != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Snippets))
	}
	if m.SpanKind != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.SpanKind))
	}
	return i, nil
}

func (m *DecorationsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecorationsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Location.Size()))
		n3, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.SourceText) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.SourceText)))
		i += copy(dAtA[i:], m.SourceText)
	}
	if len(m.Encoding) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Encoding)))
		i += copy(dAtA[i:], m.Encoding)
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			dAtA[i] = 0x22
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Diagnostic) > 0 {
		for _, msg := range m.Diagnostic {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0x7a
			i++
			v := m.Nodes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.DefinitionLocations[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.ExtendsOverrides) > 0 {
		for k, _ := range m.ExtendsOverrides {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.ExtendsOverrides[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *DecorationsReply_Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecorationsReply_Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TargetTicket) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.TargetTicket)))
		i += copy(dAtA[i:], m.TargetTicket)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.TargetDefinition) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.TargetDefinition)))
		i += copy(dAtA[i:], m.TargetDefinition)
	}
	if m.Span != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Span.Size()))
		n7, err := m.Span.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *DecorationsReply_Override) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecorationsReply_Override) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Kind))
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.MarkedSource.Size()))
		n8, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.TargetDefinition) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.TargetDefinition)))
		i += copy(dAtA[i:], m.TargetDefinition)
	}
	return i, nil
}

func (m *DecorationsReply_Overrides) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecorationsReply_Overrides) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Override) > 0 {
		for _, msg := range m.Override {
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CrossReferencesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossReferencesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DefinitionKind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.ReferenceKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AnchorText {
		dAtA[i] = 0x30
		i++
		if m.AnchorText {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeclarationKind != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.DeclarationKind))
	}
	if m.NodeDefinitions {
		dAtA[i] = 0x40
		i++
		if m.NodeDefinitions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.CallerKind != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.CallerKind))
	}
	if m.Snippets != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Snippets))
	}
	if m.ExperimentalSignatures {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		if m.ExperimentalSignatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Anchor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Anchor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Snippet) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Snippet)))
		i += copy(dAtA[i:], m.Snippet)
	}
	if m.Span != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Span.Size()))
		n9, err := m.Span.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SnippetSpan != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.SnippetSpan.Size()))
		n10, err := m.SnippetSpan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *Printable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Printable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RawText) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.RawText)))
		i += copy(dAtA[i:], m.RawText)
	}
	if len(m.Link) > 0 {
		for _, msg := range m.Link {
			dAtA[i] = 0x12
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CrossReferencesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossReferencesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, _ := range m.CrossReferences {
			dAtA[i] = 0xa
			i++
			v := m.CrossReferences[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0x12
			i++
			v := m.Nodes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			dAtA[i] = 0x1a
			i++
			v := m.DefinitionLocations[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	if m.Total != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Total.Size()))
		n14, err := m.Total.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CrossReferencesReply_RelatedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossReferencesReply_RelatedNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if len(m.RelationKind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.RelationKind)))
		i += copy(dAtA[i:], m.RelationKind)
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *CrossReferencesReply_RelatedAnchor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossReferencesReply_RelatedAnchor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Anchor.Size()))
		n15, err := m.Anchor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Site) > 0 {
		for _, msg := range m.Site {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ticket) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.MarkedSource.Size()))
		n16, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *CrossReferencesReply_CrossReferenceSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossReferencesReply_CrossReferenceSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if len(m.Definition) > 0 {
		for _, msg := range m.Definition {
			dAtA[i] = 0x12
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Declaration) > 0 {
		for _, msg := range m.Declaration {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Caller) > 0 {
		for _, msg := range m.Caller {
			dAtA[i] = 0x32
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.MarkedSource.Size()))
		n17, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.RelatedNode) > 0 {
		for _, msg := range m.RelatedNode {
			dAtA[i] = 0x52
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CrossReferencesReply_Total) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossReferencesReply_Total) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Definitions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Definitions))
	}
	if m.Declarations != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Declarations))
	}
	if m.References != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.References))
	}
	if m.Documentation != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Documentation))
	}
	if m.Callers != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Callers))
	}
	if len(m.RelatedNodesByRelation) > 0 {
		for k, _ := range m.RelatedNodesByRelation {
			dAtA[i] = 0x32
			i++
			v := m.RelatedNodesByRelation[k]
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + sovXref(uint64(v))
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintXref(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DocumentationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IncludeChildren {
		dAtA[i] = 0x18
		i++
		if m.IncludeChildren {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DocumentationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, msg := range m.Document {
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0x12
			i++
			v := m.Nodes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n18, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			dAtA[i] = 0x1a
			i++
			v := m.DefinitionLocations[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovXref(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + msgSize
			i = encodeVarintXref(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintXref(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintXref(dAtA, i, uint64(v.Size()))
				n19, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	return i, nil
}

func (m *DocumentationReply_Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentationReply_Document) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXref(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if m.Text != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Text.Size()))
		n20, err := m.Text.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Signature != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Signature.Size()))
		n21, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Type != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Type.Size()))
		n22, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Initializer != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.Initializer.Size()))
		n23, err := m.Initializer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.DefinedBy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.DefinedBy.Size()))
		n24, err := m.DefinedBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintXref(dAtA, i, uint64(m.MarkedSource.Size()))
		n25, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintXref(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Xref(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Xref(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintXref(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *DecorationsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.DirtyBuffer)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SourceText {
		n += 2
	}
	if m.References {
		n += 2
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.TargetDefinitions {
		n += 2
	}
	if m.ExtendsOverrides {
		n += 2
	}
	if m.Diagnostics {
		n += 2
	}
	if m.Snippets != 0 {
		n += 1 + sovXref(uint64(m.Snippets))
	}
	if m.SpanKind != 0 {
		n += 1 + sovXref(uint64(m.SpanKind))
	}
	return n
}

func (m *DecorationsReply) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SourceText)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Diagnostic) > 0 {
		for _, e := range m.Diagnostic {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.ExtendsOverrides) > 0 {
		for k, v := range m.ExtendsOverrides {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DecorationsReply_Reference) Size() (n int) {
	var l int
	_ = l
	l = len(m.TargetTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetDefinition)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *DecorationsReply_Override) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetDefinition)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *DecorationsReply_Overrides) Size() (n int) {
	var l int
	_ = l
	if len(m.Override) > 0 {
		for _, e := range m.Override {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CrossReferencesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.DefinitionKind != 0 {
		n += 1 + sovXref(uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		n += 1 + sovXref(uint64(m.ReferenceKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.AnchorText {
		n += 2
	}
	if m.DeclarationKind != 0 {
		n += 1 + sovXref(uint64(m.DeclarationKind))
	}
	if m.NodeDefinitions {
		n += 2
	}
	if m.PageSize != 0 {
		n += 1 + sovXref(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.CallerKind != 0 {
		n += 1 + sovXref(uint64(m.CallerKind))
	}
	if m.Snippets != 0 {
		n += 1 + sovXref(uint64(m.Snippets))
	}
	if m.ExperimentalSignatures {
		n += 3
	}
	return n
}

func (m *Anchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Snippet)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetSpan != nil {
		l = m.SnippetSpan.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Printable) Size() (n int) {
	var l int
	_ = l
	l = len(m.RawText)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Link) > 0 {
		for _, e := range m.Link {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CrossReferencesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, v := range m.CrossReferences {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_RelatedNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.RelationKind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovXref(uint64(m.Ordinal))
	}
	return n
}

func (m *CrossReferencesReply_RelatedAnchor) Size() (n int) {
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_CrossReferenceSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Definition) > 0 {
		for _, e := range m.Definition {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Declaration) > 0 {
		for _, e := range m.Declaration {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Caller) > 0 {
		for _, e := range m.Caller {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.RelatedNode) > 0 {
		for _, e := range m.RelatedNode {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CrossReferencesReply_Total) Size() (n int) {
	var l int
	_ = l
	if m.Definitions != 0 {
		n += 1 + sovXref(uint64(m.Definitions))
	}
	if m.Declarations != 0 {
		n += 1 + sovXref(uint64(m.Declarations))
	}
	if m.References != 0 {
		n += 1 + sovXref(uint64(m.References))
	}
	if m.Documentation != 0 {
		n += 1 + sovXref(uint64(m.Documentation))
	}
	if m.Callers != 0 {
		n += 1 + sovXref(uint64(m.Callers))
	}
	if len(m.RelatedNodesByRelation) > 0 {
		for k, v := range m.RelatedNodesByRelation {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + sovXref(uint64(v))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DocumentationRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.IncludeChildren {
		n += 2
	}
	return n
}

func (m *DocumentationReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovXref(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DocumentationReply_Document) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Initializer != nil {
		l = m.Initializer.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.DefinedBy != nil {
		l = m.DefinedBy.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func sovXref(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozXref(x uint64) (n int) {
	return sovXref(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (Location_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Span == nil {
				m.Span = &kythe_proto_common.Span{}
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyBuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirtyBuffer = append(m.DirtyBuffer[:0], dAtA[iNdEx:postIndex]...)
			if m.DirtyBuffer == nil {
				m.DirtyBuffer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceText = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.References = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinitions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetDefinitions = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendsOverrides", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtendsOverrides = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnostics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Diagnostics = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippets", wireType)
			}
			m.Snippets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snippets |= (SnippetsKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanKind", wireType)
			}
			m.SpanKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanKind |= (DecorationsRequest_SpanKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceText = append(m.SourceText[:0], dAtA[iNdEx:postIndex]...)
			if m.SourceText == nil {
				m.SourceText = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &DecorationsReply_Reference{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnostic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Diagnostic = append(m.Diagnostic, &kythe_proto_common.Diagnostic{})
			if err := m.Diagnostic[len(m.Diagnostic)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &kythe_proto_common.NodeInfo{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Nodes[mapkey] = mapvalue
			} else {
				var mapvalue *kythe_proto_common.NodeInfo
				m.Nodes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Anchor{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DefinitionLocations[mapkey] = mapvalue
			} else {
				var mapvalue *Anchor
				m.DefinitionLocations[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendsOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ExtendsOverrides == nil {
				m.ExtendsOverrides = make(map[string]*DecorationsReply_Overrides)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &DecorationsReply_Overrides{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ExtendsOverrides[mapkey] = mapvalue
			} else {
				var mapvalue *DecorationsReply_Overrides
				m.ExtendsOverrides[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetDefinition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Span == nil {
				m.Span = &kythe_proto_common.Span{}
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Override) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Override: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Override: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (DecorationsReply_Override_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &kythe_proto_common.MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetDefinition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Overrides) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Overrides: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Overrides: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Override = append(m.Override, &DecorationsReply_Override{})
			if err := m.Override[len(m.Override)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionKind", wireType)
			}
			m.DefinitionKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefinitionKind |= (CrossReferencesRequest_DefinitionKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceKind", wireType)
			}
			m.ReferenceKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceKind |= (CrossReferencesRequest_ReferenceKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AnchorText = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclarationKind", wireType)
			}
			m.DeclarationKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeclarationKind |= (CrossReferencesRequest_DeclarationKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDefinitions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeDefinitions = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerKind", wireType)
			}
			m.CallerKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallerKind |= (CrossReferencesRequest_CallerKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippets", wireType)
			}
			m.Snippets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snippets |= (SnippetsKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalSignatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExperimentalSignatures = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Anchor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Anchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Anchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snippet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Span == nil {
				m.Span = &kythe_proto_common.Span{}
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetSpan == nil {
				m.SnippetSpan = &kythe_proto_common.Span{}
			}
			if err := m.SnippetSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Printable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Printable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Printable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = append(m.Link, &kythe_proto_common.Link{})
			if err := m.Link[len(m.Link)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.CrossReferences == nil {
				m.CrossReferences = make(map[string]*CrossReferencesReply_CrossReferenceSet)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &CrossReferencesReply_CrossReferenceSet{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.CrossReferences[mapkey] = mapvalue
			} else {
				var mapvalue *CrossReferencesReply_CrossReferenceSet
				m.CrossReferences[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &kythe_proto_common.NodeInfo{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Nodes[mapkey] = mapvalue
			} else {
				var mapvalue *kythe_proto_common.NodeInfo
				m.Nodes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Anchor{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DefinitionLocations[mapkey] = mapvalue
			} else {
				var mapvalue *Anchor
				m.DefinitionLocations[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &CrossReferencesReply_Total{}
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_RelatedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_RelatedAnchor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedAnchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedAnchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &Anchor{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &Anchor{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &kythe_proto_common.MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_CrossReferenceSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferenceSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferenceSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Definition[len(m.Definition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Declaration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Declaration = append(m.Declaration, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Declaration[len(m.Declaration)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = append(m.Caller, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Caller[len(m.Caller)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &kythe_proto_common.MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedNode = append(m.RelatedNode, &CrossReferencesReply_RelatedNode{})
			if err := m.RelatedNode[len(m.RelatedNode)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_Total) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Total: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Total: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			m.Definitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Definitions |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Declarations", wireType)
			}
			m.Declarations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Declarations |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			m.References = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.References |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documentation", wireType)
			}
			m.Documentation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Documentation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callers", wireType)
			}
			m.Callers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Callers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNodesByRelation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.RelatedNodesByRelation == nil {
				m.RelatedNodesByRelation = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelatedNodesByRelation[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.RelatedNodesByRelation[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeChildren", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeChildren = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &DocumentationReply_Document{})
			if err := m.Document[len(m.Document)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &kythe_proto_common.NodeInfo{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Nodes[mapkey] = mapvalue
			} else {
				var mapvalue *kythe_proto_common.NodeInfo
				m.Nodes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowXref
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthXref
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Anchor{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DefinitionLocations[mapkey] = mapvalue
			} else {
				var mapvalue *Anchor
				m.DefinitionLocations[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply_Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &Printable{}
			}
			if err := m.Text.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Printable{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Printable{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializer == nil {
				m.Initializer = &Printable{}
			}
			if err := m.Initializer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinedBy == nil {
				m.DefinedBy = &Printable{}
			}
			if err := m.DefinedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &kythe_proto_common.MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &DocumentationReply_Document{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipXref(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowXref
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthXref
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowXref
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipXref(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthXref = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowXref   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kythe/proto/xref.proto", fileDescriptorXref) }

var fileDescriptorXref = []byte{
	// 2067 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x18, 0x4d, 0x73, 0xe3, 0x48,
	0x35, 0xb2, 0x65, 0x47, 0x7e, 0xb2, 0x63, 0xa5, 0x27, 0x9b, 0xd5, 0x7a, 0xd9, 0x24, 0xa3, 0x81,
	0x9d, 0xcc, 0xc7, 0x66, 0x6a, 0x1d, 0x16, 0xa6, 0x16, 0x76, 0x21, 0x89, 0x9d, 0xc5, 0x21, 0x6b,
	0x87, 0xb6, 0x67, 0x99, 0xaa, 0xa9, 0x42, 0x28, 0x52, 0x27, 0xa3, 0x8a, 0x22, 0x79, 0x25, 0x65,
	0x26, 0x9e, 0x03, 0x55, 0x54, 0x71, 0xe4, 0xc4, 0x89, 0x9f, 0xc0, 0x95, 0x2a, 0x7e, 0x01, 0x27,
	0x8a, 0x13, 0x3f, 0x81, 0x1a, 0xce, 0x1c, 0xa9, 0xe2, 0x02, 0x45, 0xa9, 0x5b, 0x92, 0x5b, 0xfe,
	0x4e, 0x8a, 0xcb, 0xde, 0xd4, 0xaf, 0xdf, 0x57, 0xbf, 0xef, 0x27, 0x58, 0xbf, 0x18, 0x84, 0x2f,
	0xc9, 0x93, 0xbe, 0xef, 0x85, 0xde, 0x93, 0x6b, 0x9f, 0x9c, 0xed, 0xd0, 0x4f, 0x24, 0x53, 0x38,
	0x3b, 0xd4, 0x54, 0x1e, 0xc9, 0xf4, 0x2e, 0x2f, 0x3d, 0x97, 0xdd, 0x68, 0x7f, 0x10, 0x40, 0x3a,
	0xf6, 0x4c, 0x23, 0xb4, 0x3d, 0x17, 0xad, 0x43, 0x31, 0xb4, 0xcd, 0x0b, 0x12, 0xaa, 0xc2, 0x96,
	0xb0, 0x5d, 0xc2, 0xf1, 0x09, 0xed, 0x80, 0x78, 0x61, 0xbb, 0x96, 0x9a, 0xdb, 0x12, 0xb6, 0x57,
	0xea, 0xb5, 0x1d, 0x8e, 0xf5, 0x4e, 0x42, 0xbc, 0xf3, 0x53, 0xdb, 0xb5, 0x30, 0xc5, 0x43, 0x8f,
	0x41, 0x0c, 0xfa, 0x86, 0xab, 0x16, 0xb6, 0x84, 0x6d, 0xb9, 0xae, 0x66, 0xf0, 0x63, 0xe9, 0xdd,
	0xbe, 0xe1, 0x62, 0x8a, 0xa5, 0xd5, 0x40, 0x8c, 0x68, 0x91, 0x04, 0xe2, 0x61, 0xeb, 0xb8, 0xa9,
	0x2c, 0x45, 0x5f, 0xdd, 0x93, 0xbd, 0xb6, 0x22, 0x1c, 0x89, 0x52, 0x5e, 0x11, 0x8f, 0x44, 0x49,
	0x54, 0x0a, 0xda, 0x3f, 0xf3, 0x80, 0x1a, 0xc4, 0xf4, 0x7c, 0x2a, 0x2f, 0xc0, 0xe4, 0xeb, 0x2b,
	0x12, 0x84, 0xe8, 0x63, 0x90, 0x9c, 0x58, 0x07, 0xaa, 0xb6, 0x5c, 0x7f, 0x67, 0xa2, 0x82, 0x38,
	0x45, 0x43, 0x77, 0xa1, 0x6c, 0xd9, 0x7e, 0x38, 0xd0, 0x4f, 0xaf, 0xce, 0xce, 0x88, 0x4f, 0xdf,
	0x55, 0xc6, 0x32, 0x85, 0xed, 0x53, 0x10, 0xda, 0x04, 0x39, 0xf0, 0xae, 0x7c, 0x93, 0xe8, 0x21,
	0xb9, 0x0e, 0xd5, 0xfc, 0x96, 0xb0, 0x2d, 0x61, 0x60, 0xa0, 0x1e, 0xb9, 0x0e, 0xd1, 0x06, 0x80,
	0x4f, 0xce, 0x88, 0x4f, 0x5c, 0x93, 0x04, 0xaa, 0xc8, 0xee, 0x87, 0x90, 0xc8, 0x96, 0x67, 0xb6,
	0x13, 0x12, 0x5f, 0x2d, 0x6c, 0xe5, 0x23, 0x5b, 0xb2, 0x13, 0xfa, 0x08, 0x50, 0x68, 0xf8, 0xe7,
	0x24, 0xd4, 0x2d, 0x72, 0x66, 0xbb, 0x36, 0x7d, 0x8b, 0x5a, 0xa4, 0xf4, 0xab, 0xec, 0xa6, 0x31,
	0xbc, 0x40, 0x8f, 0x60, 0x95, 0x5c, 0x87, 0xc4, 0xb5, 0x02, 0xdd, 0x7b, 0x45, 0x7c, 0xdf, 0xb6,
	0x48, 0xa0, 0x2e, 0x53, 0x6c, 0x25, 0xbe, 0xe8, 0x24, 0x70, 0xb4, 0x05, 0xb2, 0x65, 0x1b, 0xe7,
	0xae, 0x17, 0x84, 0xb6, 0x19, 0xa8, 0x12, 0x45, 0xe3, 0x41, 0xe8, 0x13, 0x90, 0x02, 0xd7, 0xee,
	0xf7, 0x49, 0x18, 0xa8, 0x25, 0xea, 0xcd, 0xf7, 0x32, 0xc6, 0xea, 0xc6, 0x97, 0xd4, 0x99, 0x29,
	0x2a, 0x6a, 0x42, 0x29, 0x72, 0x95, 0x4e, 0xa3, 0x00, 0x28, 0xdd, 0x76, 0x86, 0x6e, 0xdc, 0x2f,
	0xd4, 0xc3, 0x31, 0x9b, 0xf8, 0x4b, 0x7b, 0x0c, 0x52, 0x02, 0x45, 0x55, 0x90, 0x7f, 0xde, 0xea,
	0xfd, 0xa4, 0xd5, 0xd6, 0xa9, 0xab, 0x97, 0x22, 0xc0, 0x1e, 0xee, 0x3c, 0x6b, 0x37, 0x18, 0x40,
	0xd0, 0xfe, 0x0c, 0xa0, 0x64, 0xf8, 0xf6, 0x9d, 0xc1, 0x6d, 0xbc, 0x3d, 0xe2, 0x4a, 0xe6, 0x6c,
	0xde, 0x95, 0x35, 0x90, 0x88, 0x6b, 0x7a, 0x96, 0xed, 0x9e, 0x53, 0x47, 0x97, 0x70, 0x7a, 0x8e,
	0x5e, 0x9e, 0x3a, 0x55, 0x15, 0xb7, 0xf2, 0xdb, 0x72, 0xfd, 0xfe, 0xf4, 0x97, 0xf7, 0x9d, 0xc1,
	0x0e, 0x4e, 0xd0, 0xf1, 0x90, 0x12, 0x7d, 0x0e, 0x30, 0x74, 0x03, 0x8d, 0x08, 0xb9, 0xbe, 0x31,
	0x29, 0x2f, 0x1a, 0x29, 0x16, 0xe6, 0x28, 0xd0, 0xe7, 0x50, 0x70, 0xbd, 0xc8, 0xf5, 0x55, 0x4a,
	0xba, 0x3d, 0x5b, 0x85, 0x76, 0x84, 0xda, 0x74, 0x43, 0x7f, 0x80, 0x19, 0x19, 0xb2, 0x61, 0x6d,
	0x18, 0x6e, 0x7a, 0x62, 0x9a, 0x40, 0x55, 0x28, 0xbb, 0xef, 0xcd, 0x66, 0x37, 0x8c, 0xc7, 0xc4,
	0xba, 0x31, 0xf3, 0x3b, 0xd6, 0xf8, 0x0d, 0xfa, 0xe5, 0xa4, 0x88, 0x5d, 0xa5, 0x72, 0x76, 0x67,
	0xcb, 0x69, 0x8e, 0xc4, 0x33, 0x13, 0x32, 0x16, 0xe6, 0xb5, 0x3f, 0x0a, 0x50, 0x4a, 0xad, 0x8c,
	0xee, 0x41, 0x25, 0x4e, 0xa8, 0xb8, 0x76, 0xe5, 0xa8, 0x0b, 0xcb, 0x0c, 0xd8, 0x63, 0x15, 0x0c,
	0xc5, 0x15, 0x8c, 0xb9, 0x97, 0x55, 0xa9, 0x47, 0xb0, 0x3a, 0x96, 0x89, 0x34, 0x91, 0x4b, 0x58,
	0x19, 0x4d, 0xc4, 0x9b, 0x95, 0xb4, 0x23, 0x51, 0x12, 0x94, 0xdc, 0x91, 0x28, 0x81, 0x22, 0x1f,
	0x89, 0x92, 0xac, 0x94, 0x6b, 0xbf, 0xce, 0x81, 0x94, 0xbc, 0x80, 0xd6, 0x59, 0x2a, 0x20, 0xad,
	0xb3, 0xf4, 0x84, 0x7e, 0x94, 0xa9, 0xb3, 0x8f, 0x66, 0x5b, 0x2b, 0xe1, 0xc6, 0x17, 0xde, 0x26,
	0x54, 0x2e, 0x0d, 0xff, 0x82, 0x58, 0x3a, 0x0b, 0x6f, 0xfa, 0x1c, 0xb9, 0xbe, 0x35, 0x49, 0xdd,
	0x2f, 0x29, 0x62, 0x97, 0xe2, 0xe1, 0xf2, 0x25, 0x77, 0x9a, 0x6c, 0x99, 0xc2, 0x64, 0xcb, 0x68,
	0x5a, 0x5c, 0xbe, 0x2b, 0x50, 0xea, 0x7c, 0xd5, 0xc4, 0xb8, 0xd5, 0x68, 0x76, 0x95, 0x25, 0x24,
	0xc3, 0x72, 0xf3, 0x79, 0xaf, 0xd9, 0x6e, 0x74, 0x93, 0x32, 0x5e, 0xeb, 0x40, 0x69, 0x58, 0xab,
	0xf6, 0x41, 0x4a, 0xc2, 0x43, 0x15, 0x68, 0x74, 0x7c, 0xb8, 0xd8, 0x7b, 0x71, 0x4a, 0x57, 0xfb,
	0x0a, 0x60, 0x18, 0xea, 0x48, 0x81, 0xfc, 0x05, 0x19, 0xc4, 0x26, 0x8d, 0x3e, 0x51, 0x1d, 0x0a,
	0xaf, 0x0c, 0xe7, 0x8a, 0x50, 0x83, 0xca, 0xf5, 0x6f, 0x4d, 0x32, 0x43, 0xc4, 0xa0, 0xe5, 0x9e,
	0x79, 0x98, 0xa1, 0x7e, 0x9a, 0x7b, 0x2a, 0xd4, 0x5e, 0x80, 0x3a, 0x2d, 0xe6, 0x27, 0x48, 0x79,
	0x90, 0x95, 0x72, 0x27, 0x23, 0x65, 0xcf, 0x35, 0x5f, 0x7a, 0x3e, 0xcf, 0xdc, 0x81, 0x77, 0x26,
	0x06, 0xfa, 0x04, 0xce, 0x9f, 0x65, 0x39, 0xdf, 0x5f, 0xcc, 0x40, 0x01, 0x27, 0x4d, 0xfb, 0x8d,
	0x04, 0xeb, 0x07, 0xbe, 0x17, 0x04, 0x69, 0xc2, 0xa4, 0x8d, 0x93, 0xef, 0xf6, 0x79, 0xae, 0xdb,
	0xbf, 0x80, 0x2a, 0x57, 0x2b, 0xb8, 0x80, 0xac, 0x67, 0xe4, 0x4f, 0xe6, 0xca, 0x15, 0x0b, 0x1a,
	0x97, 0x2b, 0x56, 0xe6, 0x8c, 0x9e, 0xc3, 0x4a, 0x5a, 0x15, 0xf5, 0x34, 0x25, 0x57, 0xea, 0x1f,
	0x2f, 0xc2, 0x3b, 0x85, 0x50, 0xd6, 0x15, 0x9f, 0x3f, 0x4e, 0x6d, 0xb8, 0x9b, 0x20, 0x1b, 0xd4,
	0x09, 0xac, 0xfc, 0xb3, 0x4e, 0x0b, 0x0c, 0x44, 0xcb, 0xff, 0x2f, 0x40, 0xb1, 0x88, 0xe9, 0x18,
	0xcc, 0x98, 0x4c, 0xa9, 0x65, 0xaa, 0xd4, 0xee, 0x62, 0x0f, 0x4e, 0x69, 0xa9, 0x5a, 0x55, 0x2b,
	0x0b, 0x40, 0x0f, 0x40, 0x89, 0x8a, 0x70, 0xa6, 0xdf, 0xb3, 0xd6, 0x5c, 0x8d, 0xe0, 0x7c, 0xb7,
	0x7f, 0x1f, 0x4a, 0x7d, 0xe3, 0x9c, 0xe8, 0x81, 0xfd, 0x86, 0xd0, 0x3e, 0x5b, 0xc0, 0x52, 0x04,
	0xe8, 0xda, 0x6f, 0x08, 0xfa, 0x00, 0x80, 0x5e, 0x86, 0xde, 0x05, 0x71, 0x55, 0x99, 0x86, 0x09,
	0x45, 0xef, 0x45, 0x00, 0xd4, 0x01, 0xd9, 0x34, 0x1c, 0x87, 0xf8, 0xec, 0x05, 0x65, 0xfa, 0x82,
	0x9d, 0x45, 0x5e, 0x70, 0x40, 0xc9, 0xa8, 0xf2, 0x60, 0xa6, 0xdf, 0x99, 0x59, 0xa1, 0xb2, 0xf8,
	0xac, 0xf0, 0x7d, 0x78, 0x97, 0x5c, 0xf7, 0x89, 0x6f, 0x5f, 0x12, 0x37, 0x34, 0x1c, 0x3d, 0xb0,
	0xcf, 0x5d, 0x23, 0xbc, 0xf2, 0x49, 0xa0, 0x5a, 0xf4, 0xd5, 0xeb, 0xfc, 0x75, 0x37, 0xbd, 0xd5,
	0x5e, 0xc2, 0x4a, 0x36, 0x78, 0x10, 0x82, 0x95, 0x76, 0x47, 0x6f, 0x34, 0x0f, 0x5b, 0xed, 0x56,
	0xaf, 0xd5, 0x69, 0x47, 0x75, 0xe5, 0x0e, 0x54, 0xf7, 0x8e, 0x8f, 0x33, 0x40, 0x01, 0xad, 0x81,
	0x72, 0xf8, 0x6c, 0x04, 0x9a, 0x43, 0xef, 0xc2, 0x9d, 0xfd, 0x56, 0xbb, 0xd1, 0x6a, 0x7f, 0x91,
	0xb9, 0xc8, 0x6b, 0x3f, 0x84, 0xea, 0x88, 0xd7, 0x22, 0xb6, 0x54, 0xd4, 0xc1, 0xf1, 0x1e, 0xde,
	0x4b, 0x64, 0xad, 0x81, 0xc2, 0x64, 0x71, 0x50, 0x41, 0xb3, 0xa0, 0x92, 0x09, 0x44, 0xb4, 0x0a,
	0x95, 0x76, 0x47, 0xc7, 0xcd, 0xc3, 0x26, 0x6e, 0xb6, 0x0f, 0x9a, 0xb1, 0x96, 0x07, 0x11, 0x29,
	0x07, 0x14, 0x22, 0x7d, 0xda, 0x9d, 0xb6, 0x3e, 0x7a, 0x91, 0x8b, 0xde, 0x39, 0x02, 0xcb, 0x6b,
	0x87, 0x00, 0x43, 0xbf, 0xa0, 0x15, 0x80, 0x76, 0x87, 0x52, 0x36, 0x71, 0xc4, 0x1f, 0xc1, 0x4a,
	0xa3, 0x85, 0x9b, 0x07, 0xbd, 0x14, 0x46, 0x8d, 0x90, 0x14, 0xe0, 0x14, 0x9a, 0x8b, 0x67, 0xe7,
	0xff, 0x08, 0x50, 0x64, 0xa5, 0x68, 0xea, 0x90, 0x8f, 0xb8, 0xe6, 0x93, 0xb4, 0xc8, 0x75, 0x28,
	0xf6, 0x0d, 0x9f, 0xb8, 0x61, 0xdc, 0x38, 0xe3, 0x53, 0x84, 0x9b, 0x26, 0x53, 0x09, 0xd3, 0x6f,
	0xa4, 0xc2, 0x72, 0x1c, 0x03, 0x34, 0x7b, 0x4a, 0x38, 0x39, 0xa6, 0xbd, 0x13, 0x16, 0xe9, 0x9d,
	0xe8, 0x07, 0x50, 0x8e, 0x09, 0x75, 0x4a, 0x25, 0xcf, 0xa1, 0x92, 0x63, 0xec, 0x2e, 0x6b, 0xbc,
	0xa2, 0x52, 0x38, 0x12, 0xa5, 0x82, 0x52, 0x3c, 0x12, 0x25, 0x49, 0x29, 0x1d, 0x89, 0x52, 0x49,
	0x01, 0xad, 0x07, 0xa5, 0x13, 0xdf, 0x76, 0x43, 0xe3, 0xd4, 0x21, 0xe8, 0x3d, 0x90, 0x7c, 0xe3,
	0x35, 0x2b, 0x07, 0xcc, 0x06, 0xcb, 0xbe, 0xf1, 0x9a, 0xd6, 0x82, 0xc7, 0x20, 0x3a, 0xb6, 0x7b,
	0xa1, 0xe6, 0x68, 0x47, 0x9a, 0x28, 0xf4, 0xd8, 0x76, 0x2f, 0x30, 0xc5, 0xd2, 0xfe, 0xbb, 0x02,
	0x6b, 0x63, 0x39, 0x15, 0x4d, 0xa9, 0x06, 0x28, 0x66, 0x04, 0xd7, 0xb9, 0x15, 0x41, 0x98, 0x30,
	0x6a, 0x4d, 0x22, 0x1e, 0x05, 0xb2, 0x29, 0xa8, 0x6a, 0x66, 0xa1, 0x68, 0x3f, 0x99, 0x08, 0x99,
	0xaa, 0x8f, 0xe7, 0xf3, 0x1d, 0x9f, 0x0a, 0x2f, 0xa7, 0x4c, 0x85, 0x79, 0xca, 0xf2, 0xd3, 0xf9,
	0x2c, 0x6f, 0x36, 0x19, 0x7e, 0x06, 0x85, 0xd0, 0x0b, 0x0d, 0x27, 0x1e, 0xa2, 0xee, 0xcf, 0xe7,
	0xdf, 0x8b, 0xd0, 0x31, 0xa3, 0x42, 0x1f, 0x42, 0xd5, 0x25, 0xd7, 0xa1, 0xce, 0x15, 0x41, 0xa0,
	0xde, 0xab, 0x44, 0xe0, 0x93, 0xa4, 0x10, 0xd6, 0x2c, 0x90, 0x31, 0x71, 0x8c, 0x90, 0x58, 0xd1,
	0x8b, 0xa7, 0xc6, 0xfb, 0x3d, 0xa8, 0xf8, 0x11, 0x5a, 0xa6, 0xc9, 0x95, 0x70, 0x39, 0x01, 0xd2,
	0xbc, 0x53, 0x61, 0xd9, 0xf3, 0x2d, 0xdb, 0x35, 0x1c, 0x9a, 0x01, 0x05, 0x9c, 0x1c, 0x6b, 0x7f,
	0x15, 0xa2, 0x32, 0x40, 0xc5, 0xc4, 0x89, 0xf5, 0x08, 0x8a, 0xac, 0xab, 0xc4, 0x8b, 0xc9, 0xc4,
	0x41, 0x20, 0x46, 0x41, 0xf7, 0x41, 0x0c, 0xec, 0x90, 0xc4, 0xa6, 0x9e, 0x88, 0x4a, 0x11, 0x38,
	0xf5, 0xc5, 0x8c, 0xfa, 0x63, 0xa3, 0x5e, 0xe1, 0x36, 0xa3, 0xde, 0x91, 0x28, 0xe5, 0x94, 0x7c,
	0xed, 0xb7, 0x22, 0xac, 0x66, 0x1d, 0xd0, 0x25, 0xe1, 0x54, 0xcb, 0x75, 0x00, 0xb8, 0xb9, 0x90,
	0xc5, 0xdf, 0x93, 0xf9, 0xce, 0xcc, 0x58, 0x0b, 0x73, 0x2c, 0xd0, 0x97, 0xfc, 0x92, 0x95, 0xbf,
	0x1d, 0x3f, 0x6e, 0xd9, 0xfa, 0x19, 0xc8, 0x5c, 0x0f, 0x8e, 0xb7, 0xad, 0x1b, 0x33, 0xe4, 0x79,
	0xa0, 0x2f, 0xa0, 0xc8, 0x3a, 0xa3, 0x5a, 0xbc, 0x1d, 0xb7, 0x98, 0x7c, 0xdc, 0x6d, 0xd2, 0xad,
	0x26, 0xf4, 0x13, 0x60, 0x71, 0x4a, 0x2c, 0x3d, 0x4a, 0x65, 0x15, 0xa8, 0x56, 0x1f, 0x2d, 0xac,
	0x55, 0x94, 0x19, 0x58, 0xf6, 0x87, 0x87, 0xb4, 0x72, 0x2e, 0x2b, 0x52, 0xed, 0xdf, 0x39, 0x28,
	0xd0, 0xd4, 0xa3, 0x7f, 0x14, 0xb8, 0xb1, 0x25, 0x8a, 0x83, 0x3c, 0xe6, 0x41, 0x48, 0x83, 0x32,
	0x67, 0xa8, 0x80, 0x66, 0x51, 0x1e, 0x67, 0x60, 0x23, 0xff, 0x4a, 0xf2, 0x14, 0x83, 0xff, 0x57,
	0xf2, 0x6d, 0xa8, 0x58, 0x9e, 0x79, 0x45, 0x27, 0x82, 0x74, 0x0b, 0xcb, 0xe3, 0x2c, 0x30, 0xca,
	0x45, 0x66, 0xc4, 0x80, 0xc6, 0x7a, 0x1e, 0x27, 0x47, 0xf4, 0x2b, 0x78, 0x8f, 0xb7, 0x46, 0xa0,
	0x9f, 0x0e, 0xf4, 0x24, 0x8d, 0x63, 0x87, 0x1d, 0x2c, 0x58, 0x6c, 0x78, 0x03, 0x05, 0xfb, 0x03,
	0x1c, 0x73, 0x61, 0x55, 0x6d, 0xdd, 0x9f, 0x78, 0x59, 0x6b, 0xc1, 0xfb, 0x33, 0xc8, 0x26, 0x0c,
	0xf6, 0x6b, 0xfc, 0x60, 0x9f, 0xe7, 0xb7, 0x83, 0xd7, 0x63, 0x1d, 0x65, 0x1a, 0x8f, 0x56, 0x76,
	0x39, 0xd8, 0xbd, 0x69, 0x63, 0xe9, 0x92, 0x90, 0x17, 0xfc, 0x4d, 0xdc, 0xa5, 0xb4, 0xaf, 0x61,
	0xad, 0xc1, 0xc7, 0xc8, 0xbc, 0xd5, 0x66, 0xb8, 0x23, 0xe4, 0x32, 0x3b, 0xc2, 0x03, 0x50, 0x6c,
	0xd7, 0x74, 0xae, 0x2c, 0xa2, 0x9b, 0x2f, 0x6d, 0xc7, 0xf2, 0x89, 0x1b, 0xff, 0xf2, 0xab, 0xc6,
	0xf0, 0x83, 0x18, 0xac, 0xfd, 0xab, 0x08, 0x68, 0x44, 0x66, 0xd4, 0xf1, 0x1b, 0x20, 0x25, 0xd1,
	0x1a, 0x77, 0xfa, 0x91, 0x7f, 0x34, 0x63, 0x24, 0x29, 0x08, 0xa7, 0x94, 0xe8, 0xc7, 0xd9, 0xa6,
	0xfe, 0x70, 0x1e, 0x8b, 0xf1, 0x96, 0x7e, 0x31, 0xb3, 0xa5, 0x3f, 0x9d, 0xab, 0xd3, 0x4d, 0x1a,
	0x7a, 0xed, 0x4f, 0x79, 0x90, 0x12, 0x26, 0x53, 0xbb, 0xc5, 0xc3, 0x78, 0x56, 0x64, 0x1e, 0x5d,
	0xcf, 0x68, 0x90, 0xce, 0x64, 0xf1, 0x0c, 0xf9, 0x5d, 0x28, 0xa5, 0xeb, 0x02, 0x75, 0xc0, 0x74,
	0x82, 0x21, 0x22, 0x95, 0x30, 0xe8, 0x27, 0x3f, 0x3b, 0xa6, 0x4b, 0x18, 0xf4, 0x09, 0x7a, 0x0a,
	0x32, 0x7d, 0x86, 0xe1, 0xd8, 0x6f, 0xe8, 0xaa, 0x38, 0x8b, 0x84, 0x47, 0x45, 0x9f, 0xc4, 0x5d,
	0x8f, 0x58, 0xfa, 0xe9, 0x80, 0x4e, 0xbe, 0x33, 0x94, 0x8b, 0x31, 0xf7, 0x07, 0xff, 0xaf, 0x82,
	0xdf, 0x00, 0x29, 0x8d, 0xcc, 0xd2, 0x4d, 0xe3, 0x2b, 0xa1, 0x8c, 0xcb, 0xfb, 0x37, 0x31, 0xd5,
	0x1f, 0x7e, 0x07, 0xca, 0xfc, 0xc2, 0x89, 0x24, 0x10, 0xdb, 0x9d, 0x76, 0x93, 0xfd, 0x69, 0x6a,
	0x34, 0x0f, 0xf7, 0x9e, 0x1d, 0xf7, 0x14, 0xa1, 0xfe, 0xbb, 0x1c, 0xc8, 0xcf, 0x31, 0x39, 0xeb,
	0x12, 0xff, 0x95, 0x6d, 0x92, 0x68, 0x2b, 0xe6, 0x7e, 0x94, 0xa0, 0xcd, 0x39, 0x7f, 0xad, 0x6b,
	0x1f, 0xcc, 0xfc, 0xc7, 0xa2, 0x2d, 0xa1, 0x17, 0x50, 0x1d, 0x29, 0xae, 0xe8, 0xde, 0x02, 0x4b,
	0x76, 0xed, 0xee, 0xdc, 0xfa, 0xac, 0x2d, 0xa1, 0x67, 0x50, 0xc9, 0x38, 0x12, 0xdd, 0x9d, 0xe5,
	0x64, 0xc6, 0x78, 0x73, 0x4e, 0x1c, 0x68, 0x4b, 0xfb, 0xbb, 0x7f, 0x79, 0xbb, 0x21, 0xfc, 0xed,
	0xed, 0x86, 0xf0, 0xf7, 0xb7, 0x1b, 0xc2, 0xef, 0xff, 0xb1, 0xb1, 0x04, 0x9b, 0xa6, 0x77, 0xb9,
	0x73, 0xee, 0x79, 0xe7, 0x0e, 0xd9, 0xb1, 0xc8, 0xab, 0xd0, 0xf3, 0x9c, 0x80, 0xe7, 0x73, 0x22,
	0x9c, 0x16, 0xe9, 0xc7, 0xee, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xfb, 0x5c, 0x59, 0x61,
	0x1a, 0x00, 0x00,
}
