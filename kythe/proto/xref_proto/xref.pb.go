// Code generated by protoc-gen-go.
// source: kythe/proto/xref.proto
// DO NOT EDIT!

/*
Package xref_proto is a generated protocol buffer package.

It is generated from these files:
	kythe/proto/xref.proto

It has these top-level messages:
	NodesRequest
	NodeInfo
	NodesReply
	EdgesRequest
	EdgeSet
	EdgesReply
	Fact
	Location
	DecorationsRequest
	DecorationsReply
	CrossReferencesRequest
	Anchor
	CrossReferencesReply
*/
package xref_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Location_Kind int32

const (
	// The entire file; the start and end fields are ignored.
	Location_FILE Location_Kind = 0
	// The point or span of file subtended by start and end.
	Location_SPAN Location_Kind = 1
)

var Location_Kind_name = map[int32]string{
	0: "FILE",
	1: "SPAN",
}
var Location_Kind_value = map[string]int32{
	"FILE": 0,
	"SPAN": 1,
}

func (x Location_Kind) String() string {
	return proto.EnumName(Location_Kind_name, int32(x))
}

type CrossReferencesRequest_DefinitionKind int32

const (
	// No definitions will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DEFINITIONS CrossReferencesRequest_DefinitionKind = 0
	// All known definition anchors reached by the "/kythe/edge/defines" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 1
	// Only definition anchors reached by the "/kythe/edge/defines" edge kind
	// will be populated in the CrossReferencesReply.
	CrossReferencesRequest_FULL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 2
	// Only definition anchors reached by the "/kythe/edge/defines/binding" edge
	// kind will be populated in the CrossReferencesReply.
	CrossReferencesRequest_BINDING_DEFINITIONS CrossReferencesRequest_DefinitionKind = 3
)

var CrossReferencesRequest_DefinitionKind_name = map[int32]string{
	0: "NO_DEFINITIONS",
	1: "ALL_DEFINITIONS",
	2: "FULL_DEFINITIONS",
	3: "BINDING_DEFINITIONS",
}
var CrossReferencesRequest_DefinitionKind_value = map[string]int32{
	"NO_DEFINITIONS":      0,
	"ALL_DEFINITIONS":     1,
	"FULL_DEFINITIONS":    2,
	"BINDING_DEFINITIONS": 3,
}

func (x CrossReferencesRequest_DefinitionKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DefinitionKind_name, int32(x))
}

type CrossReferencesRequest_ReferenceKind int32

const (
	// No references will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_REFERENCES CrossReferencesRequest_ReferenceKind = 0
	// All known reference anchors reached by the "/kythe/edge/ref" edge kind
	// (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_REFERENCES CrossReferencesRequest_ReferenceKind = 1
)

var CrossReferencesRequest_ReferenceKind_name = map[int32]string{
	0: "NO_REFERENCES",
	1: "ALL_REFERENCES",
}
var CrossReferencesRequest_ReferenceKind_value = map[string]int32{
	"NO_REFERENCES":  0,
	"ALL_REFERENCES": 1,
}

func (x CrossReferencesRequest_ReferenceKind) String() string {
	return proto.EnumName(CrossReferencesRequest_ReferenceKind_name, int32(x))
}

type CrossReferencesRequest_DocumentationKind int32

const (
	// No documentation will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 0
	// All known documentation reached by the "/kythe/edge/documentation" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 1
)

var CrossReferencesRequest_DocumentationKind_name = map[int32]string{
	0: "NO_DOCUMENTATION",
	1: "ALL_DOCUMENTATION",
}
var CrossReferencesRequest_DocumentationKind_value = map[string]int32{
	"NO_DOCUMENTATION":  0,
	"ALL_DOCUMENTATION": 1,
}

func (x CrossReferencesRequest_DocumentationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DocumentationKind_name, int32(x))
}

type NodesRequest struct {
	// The tickets of the nodes to be looked up.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, all available facts
	// are returned for each matching node.  The filter applies to ALL requested
	// nodes.  For different filters per node, the client must issue separate
	// requests.  See EdgesRequest for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
}

func (m *NodesRequest) Reset()         { *m = NodesRequest{} }
func (m *NodesRequest) String() string { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()    {}

type NodeInfo struct {
	Ticket string  `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	Fact   []*Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}

func (m *NodeInfo) GetFact() []*Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

type NodesReply struct {
	// One NodeInfo is returned for each requested node that had a non-zero
	// number of matching facts.
	Node []*NodeInfo `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
}

func (m *NodesReply) Reset()         { *m = NodesReply{} }
func (m *NodesReply) String() string { return proto.CompactTextString(m) }
func (*NodesReply) ProtoMessage()    {}

func (m *NodesReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

type EdgesRequest struct {
	// The tickets of the source nodes for which edges are requested.
	// The service will return an error if no tickets are specified.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// The kinds of outbound edges that should be returned for each matching
	// source node.  If empty, all available edge kinds are returned.
	Kind []string `protobuf:"bytes,2,rep,name=kind" json:"kind,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for the target node of each matching edge.  If filter is empty,
	// no facts are returned.
	//
	// The supported glob operators are:
	//   *   zero or more non-slash characters ([^/]*)
	//   ?   any single non-slash character ([^/])
	//   **  zero or more of any character (.*)
	//
	// All other characters match literally, and the glob must consume the entire
	// name in order to match.  The facts returned are the union of those matched
	// by all the globs provided.
	Filter []string `protobuf:"bytes,3,rep,name=filter" json:"filter,omitempty"`
	// The edges matching a request are organized into logical pages.  The size
	// of each page is a number of distinct edges.  Notionally: All the matching
	// edges are ordered lexicographically by (start_ticket, kind, end_ticket);
	// the page_token determines where in the ordering to start, and page_size
	// determines how many edges should be returned.
	//
	// If page_token is empty, edges will be returned starting at the beginning
	// of the sequence; otherwise the starting point named by the page_token will
	// be used.  Legal values of page_token are returned by the server in the
	// next_page_token field of the EdgesReply.  A page token should be treated
	// as an opaque value by the client, and is valid only relative to a
	// particular set of tickets and kinds.  If an invalid page token is
	// requested, the server will return an error.
	//
	// If page_size > 0, at most that number of edges will be returned by the
	// service for this request (see EdgeSet and EdgesReply below).
	// If page_size = 0, the default, the server will assume a reasonable default
	// page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer edges than the requested page_size,
	// even if more are available, save that it must return at least 1 edge if
	// any are available at all.
	PageSize  int32  `protobuf:"varint,8,opt,name=page_size" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,9,opt,name=page_token" json:"page_token,omitempty"`
}

func (m *EdgesRequest) Reset()         { *m = EdgesRequest{} }
func (m *EdgesRequest) String() string { return proto.CompactTextString(m) }
func (*EdgesRequest) ProtoMessage()    {}

// An EdgeSet represents a collection of edges outbound from a single node.
// The edges are organized into groups, each sharing a common edge kind.
//
// The number of edges represented by an EdgeSet es, denoted len(es), is the
// sum of the lengths of the repeated target_ticket fields for all the groups
// in the EdgeSet.  This count is used to determine page size in a request.
//
// TODO(fromberger): Sort out what to do about the rare case of facts attached
// to edges.
type EdgeSet struct {
	// The ticket of the source node for all the edges in the edge set.
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket" json:"source_ticket,omitempty"`
	// Each group is a collection of outbound edges from source node sharing a
	// given kind.  In a given EdgeSet, the server will not send more than one
	// group with the same kind label.
	Group []*EdgeSet_Group `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
}

func (m *EdgeSet) Reset()         { *m = EdgeSet{} }
func (m *EdgeSet) String() string { return proto.CompactTextString(m) }
func (*EdgeSet) ProtoMessage()    {}

func (m *EdgeSet) GetGroup() []*EdgeSet_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type EdgeSet_Group struct {
	Kind         string   `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	TargetTicket []string `protobuf:"bytes,2,rep,name=target_ticket" json:"target_ticket,omitempty"`
}

func (m *EdgeSet_Group) Reset()         { *m = EdgeSet_Group{} }
func (m *EdgeSet_Group) String() string { return proto.CompactTextString(m) }
func (*EdgeSet_Group) ProtoMessage()    {}

type EdgesReply struct {
	// This field will contain one EdgeSet for each source node with one or more
	// matching outbound edges.  The number of edges represented by an EdgesReply
	// er, denoted len(er), is the sum of len(es) for each es in edgeset.  This
	// count is used to determine the page size.
	EdgeSet []*EdgeSet `protobuf:"bytes,1,rep,name=edge_set" json:"edge_set,omitempty"`
	// This field will contain one entry for each distinct node referenced by
	// some edge in edgesets, for which there is one or more matching facts.
	//
	// Rationale: This prevents us from having to copy the data to all the end
	// nodes, but allows the client to have that information without making
	// additional requests.
	Node []*NodeInfo `protobuf:"bytes,2,rep,name=node" json:"node,omitempty"`
	// If there are additional pages of edges after the ones returned in this
	// reply, next_page_token is the page token that may be passed to fetch the
	// next page in sequence after this one.  If there are no additional edges,
	// this field will be empty.
	NextPageToken string `protobuf:"bytes,9,opt,name=next_page_token" json:"next_page_token,omitempty"`
}

func (m *EdgesReply) Reset()         { *m = EdgesReply{} }
func (m *EdgesReply) String() string { return proto.CompactTextString(m) }
func (*EdgesReply) ProtoMessage()    {}

func (m *EdgesReply) GetEdgeSet() []*EdgeSet {
	if m != nil {
		return m.EdgeSet
	}
	return nil
}

func (m *EdgesReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

// Fact represents a single key/value fact from the graph.
type Fact struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Fact) Reset()         { *m = Fact{} }
func (m *Fact) String() string { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()    {}

// A Location represents a single span of zero or more contiguous bytes of a
// file or buffer.  An empty LOCATION denotes the entirety of the referenced
// file or buffer.
//
type Location struct {
	// The ticket of the file this location belongs to.  If the location
	// represents a memory buffer, the ticket should be omitted.
	Ticket string `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	// What kind of location this is.
	Kind Location_Kind `protobuf:"varint,2,opt,name=kind,enum=kythe.proto.Location_Kind" json:"kind,omitempty"`
	// The starting point of the location.
	Start *Location_Point `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	// The ending point of the location.
	End *Location_Point `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}

func (m *Location) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Location) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

// A Point represents a location within a file or buffer.
//
// If line_number ≤ 0, the line number and column offset are considered
// unknown and will be ignored.
//
// A point with line_number > 0 is said to be _normalized_ if it satisfies
// the constraint 0 ≤ column_offset ≤ bytelen(line_number); that is, if the
// column_offset is within the actual range of the corresponding line.  A
// point can be normalized by adjusting line_number and column_offset so that
// this constraint is satisfied.  This may be impossible if the column offset
// exceeds the bounds of the file.
type Location_Point struct {
	// The offset in bytes from the beginning of the file.
	// Requires 0 ≤ byte_offset ≤ len(file).
	ByteOffset int32 `protobuf:"varint,1,opt,name=byte_offset" json:"byte_offset,omitempty"`
	// The line number containing the point, 1-based.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number" json:"line_number,omitempty"`
	// The byte offset of the point within its line.
	ColumnOffset int32 `protobuf:"varint,3,opt,name=column_offset" json:"column_offset,omitempty"`
}

func (m *Location_Point) Reset()         { *m = Location_Point{} }
func (m *Location_Point) String() string { return proto.CompactTextString(m) }
func (*Location_Point) ProtoMessage()    {}

type DecorationsRequest struct {
	// The location of the file to fetch decorations for.  The ticket of location
	// must be non-empty.
	//
	// If the location is a SPAN, decorations are only returned for the specified
	// window of the file.  It is an error in any case if location is invalid.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// If dirty_buffer is non-empty, the results will be adjusted (patched) to
	// account for the regions of the specified file differing from the contents
	// of the dirty buffer.
	DirtyBuffer []byte `protobuf:"bytes,2,opt,name=dirty_buffer,proto3" json:"dirty_buffer,omitempty"`
	// If true, return the encoded source text for the selected window.  Source
	// text is not affected by patching.
	SourceText bool `protobuf:"varint,3,opt,name=source_text" json:"source_text,omitempty"`
	// If true, return reference edges whose source nodes are located in the
	// selected window.  References are affected by patching.
	References bool `protobuf:"varint,4,opt,name=references" json:"references,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
	// for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
}

func (m *DecorationsRequest) Reset()         { *m = DecorationsRequest{} }
func (m *DecorationsRequest) String() string { return proto.CompactTextString(m) }
func (*DecorationsRequest) ProtoMessage()    {}

func (m *DecorationsRequest) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

type DecorationsReply struct {
	// The normalized location for which decorations are returned.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The encoded source text for the selected window.
	SourceText []byte `protobuf:"bytes,2,opt,name=source_text,proto3" json:"source_text,omitempty"`
	Encoding   string `protobuf:"bytes,3,opt,name=encoding" json:"encoding,omitempty"`
	// The reference edges located in the specified window.
	Reference []*DecorationsReply_Reference `protobuf:"bytes,4,rep,name=reference" json:"reference,omitempty"`
	// This field will contain one entry for each distinct node referenced by a
	// reference edge that has at least 1 non-filtered fact.
	Node []*NodeInfo `protobuf:"bytes,15,rep,name=node" json:"node,omitempty"`
}

func (m *DecorationsReply) Reset()         { *m = DecorationsReply{} }
func (m *DecorationsReply) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply) ProtoMessage()    {}

func (m *DecorationsReply) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsReply) GetReference() []*DecorationsReply_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *DecorationsReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

// Represents a reference edge source ---KIND---> target.  Each source is an
// anchor within the requested source location.
type DecorationsReply_Reference struct {
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket" json:"source_ticket,omitempty"`
	TargetTicket string `protobuf:"bytes,2,opt,name=target_ticket" json:"target_ticket,omitempty"`
	Kind         string `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
	// Starting byte offset of this references's anchor (source_ticket) span.
	AnchorStart *Location_Point `protobuf:"bytes,10,opt,name=anchor_start" json:"anchor_start,omitempty"`
	// Ending byte offset of this references's anchor (source_ticket) span.
	AnchorEnd *Location_Point `protobuf:"bytes,11,opt,name=anchor_end" json:"anchor_end,omitempty"`
}

func (m *DecorationsReply_Reference) Reset()         { *m = DecorationsReply_Reference{} }
func (m *DecorationsReply_Reference) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Reference) ProtoMessage()    {}

func (m *DecorationsReply_Reference) GetAnchorStart() *Location_Point {
	if m != nil {
		return m.AnchorStart
	}
	return nil
}

func (m *DecorationsReply_Reference) GetAnchorEnd() *Location_Point {
	if m != nil {
		return m.AnchorEnd
	}
	return nil
}

type CrossReferencesRequest struct {
	// Set of nodes for which to return their cross-references.  Must be
	// non-empty.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// Determines what kind of definition anchors, if any, should be returned in
	// the response.  See the documentation for each DefinitionKind for more
	// information.
	DefinitionKind CrossReferencesRequest_DefinitionKind `protobuf:"varint,2,opt,name=definition_kind,enum=kythe.proto.CrossReferencesRequest_DefinitionKind" json:"definition_kind,omitempty"`
	// Determines what kind of reference anchors, if any, should be returned in
	// the response.  See the documentation for each ReferenceKind for more
	// information.
	ReferenceKind CrossReferencesRequest_ReferenceKind `protobuf:"varint,3,opt,name=reference_kind,enum=kythe.proto.CrossReferencesRequest_ReferenceKind" json:"reference_kind,omitempty"`
	// Determines what kind of documentation anchors, if any, should be returned
	// in the response.  See the documentation for each DocumentationKind for more
	// information.
	DocumentationKind CrossReferencesRequest_DocumentationKind `protobuf:"varint,4,opt,name=documentation_kind,enum=kythe.proto.CrossReferencesRequest_DocumentationKind" json:"documentation_kind,omitempty"`
	// Collection of filter globs that determines which facts will be returned for
	// the related nodes of each requested node.  If filter is empty or unset, no
	// node facts or related nodes are returned.  See EdgesRequest for the format
	// of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// Determines whether each Anchor in the response should have its text field
	// populated.
	AnchorText bool `protobuf:"varint,6,opt,name=anchor_text" json:"anchor_text,omitempty"`
	// The cross-references matching a request are organized into logical pages.
	// The size of each page is a number of distinct cross-references
	// (definitions, references, documentation, and related nodes).
	//
	// If page_token is empty, cross-references will be returned starting at the
	// beginning of the sequence; otherwise the starting point named by the
	// page_token will be used.  Legal values of page_token are returned by the
	// server in the next_page_token field of the CrossReferencesReply.  A page
	// token should be treated as an opaque value by the client, and is valid only
	// relative to a particular CrossReferencesRequest.  If an invalid page token
	// is requested, the server will return an error.
	//
	// If page_size > 0, at most that number of cross-references will be returned
	// by the service for this request (see ReferenceSet and CrossReferencesReply
	// below).  If page_size = 0, the default, the server will assume a reasonable
	// default page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer cross-references than the requested
	// page_size, even if more are available, save that it must return at least 1
	// edge if any are available at all.
	PageSize  int32  `protobuf:"varint,10,opt,name=page_size" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,11,opt,name=page_token" json:"page_token,omitempty"`
}

func (m *CrossReferencesRequest) Reset()         { *m = CrossReferencesRequest{} }
func (m *CrossReferencesRequest) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesRequest) ProtoMessage()    {}

type Anchor struct {
	// Ticket of the anchor node
	Ticket string `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	// Edge kind describing the anchor's relationship with its referenced node
	Kind string `protobuf:"bytes,2,opt,name=kind" json:"kind,omitempty"`
	// Parent ticket of the anchor; this is the file containing the anchor
	Parent string `protobuf:"bytes,3,opt,name=parent" json:"parent,omitempty"`
	// Starting location of the anchor within its parent's text
	Start *Location_Point `protobuf:"bytes,4,opt,name=start" json:"start,omitempty"`
	// Ending location of the anchor within its parent's text
	End *Location_Point `protobuf:"bytes,5,opt,name=end" json:"end,omitempty"`
	// The anchor's spanning text within the anchor parent's text
	Text string `protobuf:"bytes,6,opt,name=text" json:"text,omitempty"`
	// User-readable snippet of the anchor parent's text at the location of this
	// anchor
	Snippet string `protobuf:"bytes,7,opt,name=snippet" json:"snippet,omitempty"`
}

func (m *Anchor) Reset()         { *m = Anchor{} }
func (m *Anchor) String() string { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()    {}

func (m *Anchor) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Anchor) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

type CrossReferencesReply struct {
	// Sets of cross-references for each requested node
	CrossReferences map[string]*CrossReferencesReply_CrossReferenceSet `protobuf:"bytes,1,rep,name=cross_references" json:"cross_references,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The facts left from the requested filters of the related node facts
	Nodes map[string]*NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If there are additional pages of cross-references after the ones returned
	// in this reply, next_page_token is the page token that may be passed to
	// fetch the next page in sequence after this one.  If there are no additional
	// cross-references, this field will be empty.
	NextPageToken string `protobuf:"bytes,10,opt,name=next_page_token" json:"next_page_token,omitempty"`
}

func (m *CrossReferencesReply) Reset()         { *m = CrossReferencesReply{} }
func (m *CrossReferencesReply) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply) ProtoMessage()    {}

func (m *CrossReferencesReply) GetCrossReferences() map[string]*CrossReferencesReply_CrossReferenceSet {
	if m != nil {
		return m.CrossReferences
	}
	return nil
}

func (m *CrossReferencesReply) GetNodes() map[string]*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type CrossReferencesReply_RelatedNode struct {
	// Ticket of the node
	Ticket string `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	// Edge kind describing the node's relation
	RelationKind string `protobuf:"bytes,2,opt,name=relation_kind" json:"relation_kind,omitempty"`
}

func (m *CrossReferencesReply_RelatedNode) Reset()         { *m = CrossReferencesReply_RelatedNode{} }
func (m *CrossReferencesReply_RelatedNode) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedNode) ProtoMessage()    {}

type CrossReferencesReply_CrossReferenceSet struct {
	Ticket string `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	// The set of definitions for the given node.
	Definition []*Anchor `protobuf:"bytes,2,rep,name=definition" json:"definition,omitempty"`
	// The set of simple references for the given node.
	Reference []*Anchor `protobuf:"bytes,3,rep,name=reference" json:"reference,omitempty"`
	// The set of documentation for the given node.
	Documentation []*Anchor `protobuf:"bytes,4,rep,name=documentation" json:"documentation,omitempty"`
	// The set of related nodes to the given node.
	RelatedNode []*CrossReferencesReply_RelatedNode `protobuf:"bytes,10,rep,name=related_node" json:"related_node,omitempty"`
}

func (m *CrossReferencesReply_CrossReferenceSet) Reset() {
	*m = CrossReferencesReply_CrossReferenceSet{}
}
func (m *CrossReferencesReply_CrossReferenceSet) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_CrossReferenceSet) ProtoMessage()    {}

func (m *CrossReferencesReply_CrossReferenceSet) GetDefinition() []*Anchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetReference() []*Anchor {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDocumentation() []*Anchor {
	if m != nil {
		return m.Documentation
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetRelatedNode() []*CrossReferencesReply_RelatedNode {
	if m != nil {
		return m.RelatedNode
	}
	return nil
}

func init() {
	proto.RegisterEnum("kythe.proto.Location_Kind", Location_Kind_name, Location_Kind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DefinitionKind", CrossReferencesRequest_DefinitionKind_name, CrossReferencesRequest_DefinitionKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_ReferenceKind", CrossReferencesRequest_ReferenceKind_name, CrossReferencesRequest_ReferenceKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DocumentationKind", CrossReferencesRequest_DocumentationKind_name, CrossReferencesRequest_DocumentationKind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for XRefService service

type XRefServiceClient interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error)
}

type xRefServiceClient struct {
	cc *grpc.ClientConn
}

func NewXRefServiceClient(cc *grpc.ClientConn) XRefServiceClient {
	return &xRefServiceClient{cc}
}

func (c *xRefServiceClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Nodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error) {
	out := new(EdgesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Edges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error) {
	out := new(DecorationsReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Decorations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error) {
	out := new(CrossReferencesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/CrossReferences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XRefService service

type XRefServiceServer interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(context.Context, *NodesRequest) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(context.Context, *EdgesRequest) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(context.Context, *DecorationsRequest) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(context.Context, *CrossReferencesRequest) (*CrossReferencesReply, error)
}

func RegisterXRefServiceServer(s *grpc.Server, srv XRefServiceServer) {
	s.RegisterService(&_XRefService_serviceDesc, srv)
}

func _XRefService_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Nodes(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Edges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EdgesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Edges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Decorations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DecorationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Decorations(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_CrossReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CrossReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).CrossReferences(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _XRefService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.XRefService",
	HandlerType: (*XRefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Nodes",
			Handler:    _XRefService_Nodes_Handler,
		},
		{
			MethodName: "Edges",
			Handler:    _XRefService_Edges_Handler,
		},
		{
			MethodName: "Decorations",
			Handler:    _XRefService_Decorations_Handler,
		},
		{
			MethodName: "CrossReferences",
			Handler:    _XRefService_CrossReferences_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
