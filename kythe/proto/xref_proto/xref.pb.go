// Code generated by protoc-gen-gogo.
// source: kythe/proto/xref.proto
// DO NOT EDIT!

/*
	Package xref_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/xref.proto

	It has these top-level messages:
		NodesRequest
		NodeInfo
		NodesReply
		EdgesRequest
		EdgeSet
		EdgesReply
		Location
		DecorationsRequest
		DecorationsReply
		CrossReferencesRequest
		Anchor
		CrossReferencesReply
		CallersRequest
		CallersReply
*/
package xref_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_common "kythe.io/kythe/proto/common_proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Location_Kind int32

const (
	// The entire file; the start and end fields are ignored.
	Location_FILE Location_Kind = 0
	// The point or span of file subtended by start and end.
	Location_SPAN Location_Kind = 1
)

var Location_Kind_name = map[int32]string{
	0: "FILE",
	1: "SPAN",
}
var Location_Kind_value = map[string]int32{
	"FILE": 0,
	"SPAN": 1,
}

func (x Location_Kind) String() string {
	return proto.EnumName(Location_Kind_name, int32(x))
}

type CrossReferencesRequest_DefinitionKind int32

const (
	// No definitions will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DEFINITIONS CrossReferencesRequest_DefinitionKind = 0
	// All known definition anchors reached by the "/kythe/edge/defines" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 1
	// Only definition anchors reached by the "/kythe/edge/defines" edge kind
	// will be populated in the CrossReferencesReply.
	CrossReferencesRequest_FULL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 2
	// Only definition anchors reached by the "/kythe/edge/defines/binding" edge
	// kind will be populated in the CrossReferencesReply.
	CrossReferencesRequest_BINDING_DEFINITIONS CrossReferencesRequest_DefinitionKind = 3
)

var CrossReferencesRequest_DefinitionKind_name = map[int32]string{
	0: "NO_DEFINITIONS",
	1: "ALL_DEFINITIONS",
	2: "FULL_DEFINITIONS",
	3: "BINDING_DEFINITIONS",
}
var CrossReferencesRequest_DefinitionKind_value = map[string]int32{
	"NO_DEFINITIONS":      0,
	"ALL_DEFINITIONS":     1,
	"FULL_DEFINITIONS":    2,
	"BINDING_DEFINITIONS": 3,
}

func (x CrossReferencesRequest_DefinitionKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DefinitionKind_name, int32(x))
}

type CrossReferencesRequest_ReferenceKind int32

const (
	// No references will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_REFERENCES CrossReferencesRequest_ReferenceKind = 0
	// All known reference anchors reached by the "/kythe/edge/ref" edge kind
	// (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_REFERENCES CrossReferencesRequest_ReferenceKind = 1
)

var CrossReferencesRequest_ReferenceKind_name = map[int32]string{
	0: "NO_REFERENCES",
	1: "ALL_REFERENCES",
}
var CrossReferencesRequest_ReferenceKind_value = map[string]int32{
	"NO_REFERENCES":  0,
	"ALL_REFERENCES": 1,
}

func (x CrossReferencesRequest_ReferenceKind) String() string {
	return proto.EnumName(CrossReferencesRequest_ReferenceKind_name, int32(x))
}

type CrossReferencesRequest_DocumentationKind int32

const (
	// No documentation will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 0
	// All known documentation reached by the "/kythe/edge/documentation" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 1
)

var CrossReferencesRequest_DocumentationKind_name = map[int32]string{
	0: "NO_DOCUMENTATION",
	1: "ALL_DOCUMENTATION",
}
var CrossReferencesRequest_DocumentationKind_value = map[string]int32{
	"NO_DOCUMENTATION":  0,
	"ALL_DOCUMENTATION": 1,
}

func (x CrossReferencesRequest_DocumentationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DocumentationKind_name, int32(x))
}

type CallersReply_CallableDetail_Parameter_Kind int32

const (
	// A term-level binding (like the `x` in `void foo(int x)`).
	CallersReply_CallableDetail_Parameter_TERM CallersReply_CallableDetail_Parameter_Kind = 0
	// A type-level binding (like the `T` in
	// `template <typename T> void foo()`).
	CallersReply_CallableDetail_Parameter_TYPE CallersReply_CallableDetail_Parameter_Kind = 1
)

var CallersReply_CallableDetail_Parameter_Kind_name = map[int32]string{
	0: "TERM",
	1: "TYPE",
}
var CallersReply_CallableDetail_Parameter_Kind_value = map[string]int32{
	"TERM": 0,
	"TYPE": 1,
}

func (x CallersReply_CallableDetail_Parameter_Kind) String() string {
	return proto.EnumName(CallersReply_CallableDetail_Parameter_Kind_name, int32(x))
}

type NodesRequest struct {
	// The tickets of the nodes to be looked up.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, all available facts
	// are returned for each matching node.  The filter applies to ALL requested
	// nodes.  For different filters per node, the client must issue separate
	// requests.  See EdgesRequest for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
}

func (m *NodesRequest) Reset()         { *m = NodesRequest{} }
func (m *NodesRequest) String() string { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()    {}

type NodeInfo struct {
	// The ticket for a matching node.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// The matching facts known for that node.
	Fact []*kythe_proto_common.Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}

func (m *NodeInfo) GetFact() []*kythe_proto_common.Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

type NodesReply struct {
	// One NodeInfo is returned for each requested node that had a non-zero
	// number of matching facts.
	Node []*NodeInfo `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
}

func (m *NodesReply) Reset()         { *m = NodesReply{} }
func (m *NodesReply) String() string { return proto.CompactTextString(m) }
func (*NodesReply) ProtoMessage()    {}

func (m *NodesReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

type EdgesRequest struct {
	// The tickets of the source nodes for which edges are requested.
	// The service will return an error if no tickets are specified.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// The kinds of outbound edges that should be returned for each matching
	// source node.  If empty, all available edge kinds are returned.
	Kind []string `protobuf:"bytes,2,rep,name=kind" json:"kind,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for the target node of each matching edge.  If filter is empty,
	// no facts are returned.
	//
	// The supported glob operators are:
	//   *   zero or more non-slash characters ([^/]*)
	//   ?   any single non-slash character ([^/])
	//   **  zero or more of any character (.*)
	//
	// All other characters match literally, and the glob must consume the entire
	// name in order to match.  The facts returned are the union of those matched
	// by all the globs provided.
	Filter []string `protobuf:"bytes,3,rep,name=filter" json:"filter,omitempty"`
	// The edges matching a request are organized into logical pages.  The size
	// of each page is a number of distinct edges.  Notionally: All the matching
	// edges are ordered lexicographically by (start_ticket, kind, end_ticket);
	// the page_token determines where in the ordering to start, and page_size
	// determines how many edges should be returned.
	//
	// If page_token is empty, edges will be returned starting at the beginning
	// of the sequence; otherwise the starting point named by the page_token will
	// be used.  Legal values of page_token are returned by the server in the
	// next_page_token field of the EdgesReply.  A page token should be treated
	// as an opaque value by the client, and is valid only relative to a
	// particular set of tickets and kinds.  If an invalid page token is
	// requested, the server will return an error.
	//
	// If page_size > 0, at most that number of edges will be returned by the
	// service for this request (see EdgeSet and EdgesReply below).
	// If page_size = 0, the default, the server will assume a reasonable default
	// page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer edges than the requested page_size,
	// even if more are available, save that it must return at least 1 edge if
	// any are available at all.
	PageSize  int32  `protobuf:"varint,8,opt,name=page_size,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,9,opt,name=page_token,proto3" json:"page_token,omitempty"`
}

func (m *EdgesRequest) Reset()         { *m = EdgesRequest{} }
func (m *EdgesRequest) String() string { return proto.CompactTextString(m) }
func (*EdgesRequest) ProtoMessage()    {}

// An EdgeSet represents a collection of edges outbound from a single node.
// The edges are organized into groups, each sharing a common edge kind.
//
// The number of edges represented by an EdgeSet es, denoted len(es), is the
// sum of the lengths of the repeated target_ticket fields for all the groups
// in the EdgeSet.  This count is used to determine page size in a request.
//
// TODO(fromberger): Sort out what to do about the rare case of facts attached
// to edges.
type EdgeSet struct {
	// The ticket of the source node for all the edges in the edge set.
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket,proto3" json:"source_ticket,omitempty"`
	// Each group is a collection of outbound edges from source node sharing a
	// given kind.  In a given EdgeSet, the server will not send more than one
	// group with the same kind label.
	Group []*EdgeSet_Group `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
}

func (m *EdgeSet) Reset()         { *m = EdgeSet{} }
func (m *EdgeSet) String() string { return proto.CompactTextString(m) }
func (*EdgeSet) ProtoMessage()    {}

func (m *EdgeSet) GetGroup() []*EdgeSet_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type EdgeSet_Group struct {
	Kind         string   `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	TargetTicket []string `protobuf:"bytes,2,rep,name=target_ticket" json:"target_ticket,omitempty"`
}

func (m *EdgeSet_Group) Reset()         { *m = EdgeSet_Group{} }
func (m *EdgeSet_Group) String() string { return proto.CompactTextString(m) }
func (*EdgeSet_Group) ProtoMessage()    {}

type EdgesReply struct {
	// This field will contain one EdgeSet for each source node with one or more
	// matching outbound edges.  The number of edges represented by an EdgesReply
	// er, denoted len(er), is the sum of len(es) for each es in edgeset.  This
	// count is used to determine the page size.
	EdgeSet []*EdgeSet `protobuf:"bytes,1,rep,name=edge_set" json:"edge_set,omitempty"`
	// This field will contain one entry for each distinct node referenced by
	// some edge in edgesets, for which there is one or more matching facts.
	//
	// Rationale: This prevents us from having to copy the data to all the end
	// nodes, but allows the client to have that information without making
	// additional requests.
	Node []*NodeInfo `protobuf:"bytes,2,rep,name=node" json:"node,omitempty"`
	// If there are additional pages of edges after the ones returned in this
	// reply, next_page_token is the page token that may be passed to fetch the
	// next page in sequence after this one.  If there are no additional edges,
	// this field will be empty.
	NextPageToken string `protobuf:"bytes,9,opt,name=next_page_token,proto3" json:"next_page_token,omitempty"`
}

func (m *EdgesReply) Reset()         { *m = EdgesReply{} }
func (m *EdgesReply) String() string { return proto.CompactTextString(m) }
func (*EdgesReply) ProtoMessage()    {}

func (m *EdgesReply) GetEdgeSet() []*EdgeSet {
	if m != nil {
		return m.EdgeSet
	}
	return nil
}

func (m *EdgesReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

// A Location represents a single span of zero or more contiguous bytes of a
// file or buffer.  An empty LOCATION denotes the entirety of the referenced
// file or buffer.
//
type Location struct {
	// The ticket of the file this location belongs to.  If the location
	// represents a memory buffer, the ticket should be omitted.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// What kind of location this is.
	Kind Location_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.Location_Kind" json:"kind,omitempty"`
	// The starting point of the location.
	Start *Location_Point `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	// The ending point of the location.
	End *Location_Point `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}

func (m *Location) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Location) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

// A Point represents a location within a file or buffer.
//
// If line_number ≤ 0, the line number and column offset are considered
// unknown and will be ignored.
//
// A point with line_number > 0 is said to be _normalized_ if it satisfies
// the constraint 0 ≤ column_offset ≤ bytelen(line_number); that is, if the
// column_offset is within the actual range of the corresponding line.  A
// point can be normalized by adjusting line_number and column_offset so that
// this constraint is satisfied.  This may be impossible if the column offset
// exceeds the bounds of the file.
type Location_Point struct {
	// The offset in bytes from the beginning of the file.
	// Requires 0 ≤ byte_offset ≤ len(file).
	ByteOffset int32 `protobuf:"varint,1,opt,name=byte_offset,proto3" json:"byte_offset,omitempty"`
	// The line number containing the point, 1-based.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number,proto3" json:"line_number,omitempty"`
	// The byte offset of the point within its line.
	ColumnOffset int32 `protobuf:"varint,3,opt,name=column_offset,proto3" json:"column_offset,omitempty"`
}

func (m *Location_Point) Reset()         { *m = Location_Point{} }
func (m *Location_Point) String() string { return proto.CompactTextString(m) }
func (*Location_Point) ProtoMessage()    {}

type DecorationsRequest struct {
	// The location of the file to fetch decorations for.  The ticket of location
	// must be non-empty.
	//
	// If the location is a SPAN, decorations are only returned for the specified
	// window of the file.  It is an error in any case if location is invalid.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// If dirty_buffer is non-empty, the results will be adjusted (patched) to
	// account for the regions of the specified file differing from the contents
	// of the dirty buffer.
	DirtyBuffer []byte `protobuf:"bytes,2,opt,name=dirty_buffer,proto3" json:"dirty_buffer,omitempty"`
	// If true, return the encoded source text for the selected window.  Source
	// text is not affected by patching.
	SourceText bool `protobuf:"varint,3,opt,name=source_text,proto3" json:"source_text,omitempty"`
	// If true, return reference edges whose source nodes are located in the
	// selected window.  References are affected by patching.
	References bool `protobuf:"varint,4,opt,name=references,proto3" json:"references,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
	// for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
}

func (m *DecorationsRequest) Reset()         { *m = DecorationsRequest{} }
func (m *DecorationsRequest) String() string { return proto.CompactTextString(m) }
func (*DecorationsRequest) ProtoMessage()    {}

func (m *DecorationsRequest) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

type DecorationsReply struct {
	// The normalized location for which decorations are returned.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The encoded source text for the selected window.
	SourceText []byte `protobuf:"bytes,2,opt,name=source_text,proto3" json:"source_text,omitempty"`
	Encoding   string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// The reference edges located in the specified window.
	Reference []*DecorationsReply_Reference `protobuf:"bytes,4,rep,name=reference" json:"reference,omitempty"`
	// This field will contain one entry for each distinct node referenced by a
	// reference edge that has at least 1 non-filtered fact.
	Node []*NodeInfo `protobuf:"bytes,15,rep,name=node" json:"node,omitempty"`
}

func (m *DecorationsReply) Reset()         { *m = DecorationsReply{} }
func (m *DecorationsReply) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply) ProtoMessage()    {}

func (m *DecorationsReply) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsReply) GetReference() []*DecorationsReply_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *DecorationsReply) GetNode() []*NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

// Represents a reference edge source ---KIND---> target.  Each source is an
// anchor within the requested source location.
type DecorationsReply_Reference struct {
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket,proto3" json:"source_ticket,omitempty"`
	TargetTicket string `protobuf:"bytes,2,opt,name=target_ticket,proto3" json:"target_ticket,omitempty"`
	Kind         string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Starting byte offset of this references's anchor (source_ticket) span.
	AnchorStart *Location_Point `protobuf:"bytes,10,opt,name=anchor_start" json:"anchor_start,omitempty"`
	// Ending byte offset of this references's anchor (source_ticket) span.
	AnchorEnd *Location_Point `protobuf:"bytes,11,opt,name=anchor_end" json:"anchor_end,omitempty"`
}

func (m *DecorationsReply_Reference) Reset()         { *m = DecorationsReply_Reference{} }
func (m *DecorationsReply_Reference) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Reference) ProtoMessage()    {}

func (m *DecorationsReply_Reference) GetAnchorStart() *Location_Point {
	if m != nil {
		return m.AnchorStart
	}
	return nil
}

func (m *DecorationsReply_Reference) GetAnchorEnd() *Location_Point {
	if m != nil {
		return m.AnchorEnd
	}
	return nil
}

type CrossReferencesRequest struct {
	// Set of nodes for which to return their cross-references.  Must be
	// non-empty.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// Determines what kind of definition anchors, if any, should be returned in
	// the response.  See the documentation for each DefinitionKind for more
	// information.
	DefinitionKind CrossReferencesRequest_DefinitionKind `protobuf:"varint,2,opt,name=definition_kind,proto3,enum=kythe.proto.CrossReferencesRequest_DefinitionKind" json:"definition_kind,omitempty"`
	// Determines what kind of reference anchors, if any, should be returned in
	// the response.  See the documentation for each ReferenceKind for more
	// information.
	ReferenceKind CrossReferencesRequest_ReferenceKind `protobuf:"varint,3,opt,name=reference_kind,proto3,enum=kythe.proto.CrossReferencesRequest_ReferenceKind" json:"reference_kind,omitempty"`
	// Determines what kind of documentation anchors, if any, should be returned
	// in the response.  See the documentation for each DocumentationKind for more
	// information.
	DocumentationKind CrossReferencesRequest_DocumentationKind `protobuf:"varint,4,opt,name=documentation_kind,proto3,enum=kythe.proto.CrossReferencesRequest_DocumentationKind" json:"documentation_kind,omitempty"`
	// Collection of filter globs that determines which facts will be returned for
	// the related nodes of each requested node.  If filter is empty or unset, no
	// node facts or related nodes are returned.  See EdgesRequest for the format
	// of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// Determines whether each Anchor in the response should have its text field
	// populated.
	AnchorText bool `protobuf:"varint,6,opt,name=anchor_text,proto3" json:"anchor_text,omitempty"`
	// The cross-references matching a request are organized into logical pages.
	// The size of each page is a number of distinct cross-references
	// (definitions, references, documentation, and related nodes).
	//
	// If page_token is empty, cross-references will be returned starting at the
	// beginning of the sequence; otherwise the starting point named by the
	// page_token will be used.  Legal values of page_token are returned by the
	// server in the next_page_token field of the CrossReferencesReply.  A page
	// token should be treated as an opaque value by the client, and is valid only
	// relative to a particular CrossReferencesRequest.  If an invalid page token
	// is requested, the server will return an error.
	//
	// If page_size > 0, at most that number of cross-references will be returned
	// by the service for this request (see ReferenceSet and CrossReferencesReply
	// below).  If page_size = 0, the default, the server will assume a reasonable
	// default page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer cross-references than the requested
	// page_size, even if more are available, save that it must return at least 1
	// edge if any are available at all.
	PageSize  int32  `protobuf:"varint,10,opt,name=page_size,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,11,opt,name=page_token,proto3" json:"page_token,omitempty"`
}

func (m *CrossReferencesRequest) Reset()         { *m = CrossReferencesRequest{} }
func (m *CrossReferencesRequest) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesRequest) ProtoMessage()    {}

type Anchor struct {
	// Ticket of the anchor node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the anchor's relationship with its referenced node
	Kind string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	// Parent ticket of the anchor; this is the file containing the anchor
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// Starting location of the anchor within its parent's text
	Start *Location_Point `protobuf:"bytes,4,opt,name=start" json:"start,omitempty"`
	// Ending location of the anchor within its parent's text
	End *Location_Point `protobuf:"bytes,5,opt,name=end" json:"end,omitempty"`
	// The anchor's spanning text within the anchor parent's text
	Text string `protobuf:"bytes,6,opt,name=text,proto3" json:"text,omitempty"`
	// User-readable snippet of the anchor parent's text at the location of this
	// anchor
	Snippet string `protobuf:"bytes,7,opt,name=snippet,proto3" json:"snippet,omitempty"`
	// Starting location of the anchor's snippet within its parent's text
	SnippetStart *Location_Point `protobuf:"bytes,8,opt,name=snippet_start" json:"snippet_start,omitempty"`
	// Ending location of the anchor's snippet within its parent's text
	SnippetEnd *Location_Point `protobuf:"bytes,9,opt,name=snippet_end" json:"snippet_end,omitempty"`
}

func (m *Anchor) Reset()         { *m = Anchor{} }
func (m *Anchor) String() string { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()    {}

func (m *Anchor) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Anchor) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Anchor) GetSnippetStart() *Location_Point {
	if m != nil {
		return m.SnippetStart
	}
	return nil
}

func (m *Anchor) GetSnippetEnd() *Location_Point {
	if m != nil {
		return m.SnippetEnd
	}
	return nil
}

type CrossReferencesReply struct {
	// Sets of cross-references for each requested node
	CrossReferences map[string]*CrossReferencesReply_CrossReferenceSet `protobuf:"bytes,1,rep,name=cross_references" json:"cross_references,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// The facts left from the requested filters of the related node facts
	Nodes map[string]*NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// If there are additional pages of cross-references after the ones returned
	// in this reply, next_page_token is the page token that may be passed to
	// fetch the next page in sequence after this one.  If there are no additional
	// cross-references, this field will be empty.
	NextPageToken string `protobuf:"bytes,10,opt,name=next_page_token,proto3" json:"next_page_token,omitempty"`
}

func (m *CrossReferencesReply) Reset()         { *m = CrossReferencesReply{} }
func (m *CrossReferencesReply) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply) ProtoMessage()    {}

func (m *CrossReferencesReply) GetCrossReferences() map[string]*CrossReferencesReply_CrossReferenceSet {
	if m != nil {
		return m.CrossReferences
	}
	return nil
}

func (m *CrossReferencesReply) GetNodes() map[string]*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type CrossReferencesReply_RelatedNode struct {
	// Ticket of the node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the node's relation
	RelationKind string `protobuf:"bytes,2,opt,name=relation_kind,proto3" json:"relation_kind,omitempty"`
}

func (m *CrossReferencesReply_RelatedNode) Reset()         { *m = CrossReferencesReply_RelatedNode{} }
func (m *CrossReferencesReply_RelatedNode) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedNode) ProtoMessage()    {}

type CrossReferencesReply_CrossReferenceSet struct {
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// The set of definitions for the given node.
	Definition []*Anchor `protobuf:"bytes,2,rep,name=definition" json:"definition,omitempty"`
	// The set of simple references for the given node.
	Reference []*Anchor `protobuf:"bytes,3,rep,name=reference" json:"reference,omitempty"`
	// The set of documentation for the given node.
	Documentation []*Anchor `protobuf:"bytes,4,rep,name=documentation" json:"documentation,omitempty"`
	// The set of related nodes to the given node.
	RelatedNode []*CrossReferencesReply_RelatedNode `protobuf:"bytes,10,rep,name=related_node" json:"related_node,omitempty"`
}

func (m *CrossReferencesReply_CrossReferenceSet) Reset() {
	*m = CrossReferencesReply_CrossReferenceSet{}
}
func (m *CrossReferencesReply_CrossReferenceSet) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_CrossReferenceSet) ProtoMessage()    {}

func (m *CrossReferencesReply_CrossReferenceSet) GetDefinition() []*Anchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetReference() []*Anchor {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDocumentation() []*Anchor {
	if m != nil {
		return m.Documentation
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetRelatedNode() []*CrossReferencesReply_RelatedNode {
	if m != nil {
		return m.RelatedNode
	}
	return nil
}

type CallersRequest struct {
	// A set of semantic tickets. These may refer to nodes that are `callableas`
	// other nodes or they may refer to those specific `callable` nodes. This
	// means that you can use both the target nodes of `ref/call` edges and
	// more common reference or definition edges (like `ref` or
	// `defines/binding`).
	//
	// The Kythe data model defines a `callable` as something that can be the
	// target of a `ref/call` edge. A `callable` has its own identity in the
	// graph and is connected to the nodes it can be called through by a
	// `callableas` edge. A `function` is the most typical node kind that
	// participates in this `callableas` relationship. Other language-level
	// objects that may be sources of `callableas` edges include C++
	// struct/class types that define an operator(), Python classes that
	// define __call__, and so forth.
	//
	// A given node may be `callableas` several different `callable` nodes.
	// For example, if a struct S defines multiple overrides for
	// operator(), it will be `callableas` multiple nodes C0...CN. These
	// nodes will be distinguished by their type signatures. It's better to
	// use `callable` nodes in this set because they make the query more
	// specific.
	SemanticObject []string `protobuf:"bytes,1,rep,name=semantic_object" json:"semantic_object,omitempty"`
	// Expand the semantic_object set by including nodes that participate in
	// an `overrides` relationship (in either direction) with nodes in the set.
	//
	// In the program:
	//   struct A { virtual void f(); };
	//   struct B : public A { void f() override; };
	//   struct C : public B { void f() override; };
	//   void g(B* b) { b->f(); }
	//
	// we would return the following results (for queries on the singleton
	// semantic_object set containing A::f, B::f, or C::f):
	//
	// include_overrides  A::f  B::f  C::f
	//             false    {}   {g}    {}
	//              true   {g}   {g}   {g}
	IncludeOverrides bool `protobuf:"varint,2,opt,name=include_overrides,proto3" json:"include_overrides,omitempty"`
}

func (m *CallersRequest) Reset()         { *m = CallersRequest{} }
func (m *CallersRequest) String() string { return proto.CompactTextString(m) }
func (*CallersRequest) ProtoMessage()    {}

type CallersReply struct {
	// All objects that were blamed for making calls.
	Caller []*CallersReply_Caller `protobuf:"bytes,1,rep,name=caller" json:"caller,omitempty"`
	// Details for the semantic objects that were passed via a CallersRequest.
	Callee []*CallersReply_CallableDetail `protobuf:"bytes,2,rep,name=callee" json:"callee,omitempty"`
}

func (m *CallersReply) Reset()         { *m = CallersReply{} }
func (m *CallersReply) String() string { return proto.CompactTextString(m) }
func (*CallersReply) ProtoMessage()    {}

func (m *CallersReply) GetCaller() []*CallersReply_Caller {
	if m != nil {
		return m.Caller
	}
	return nil
}

func (m *CallersReply) GetCallee() []*CallersReply_CallableDetail {
	if m != nil {
		return m.Callee
	}
	return nil
}

// Details common to all objects that participate in the call graph.
type CallersReply_CallableDetail struct {
	// The definition site of the object called or being blamed for a call.
	// This would be the "bar" in "void bar()" for calls blamed on bar above
	// and the "foo" in "void foo()" if it refers to foo as a callee.
	Definition *Anchor `protobuf:"bytes,1,opt,name=definition" json:"definition,omitempty"`
	// The ticket of the object that is `callableas` some C. This would refer
	// to the function node for "bar" or "foo". This object may be the target
	// of a `completes` edge (e.g., if the call was made to a definition
	// rather than a declaration).
	SemanticObject string `protobuf:"bytes,2,opt,name=semantic_object,proto3" json:"semantic_object,omitempty"`
	// The ticket of the callable C for semantic_object that was used to service
	// the query.
	SemanticObjectCallable string `protobuf:"bytes,3,opt,name=semantic_object_callable,proto3" json:"semantic_object_callable,omitempty"`
	// The unqualified identifier for this object ("bar" or "foo" above,
	// even if they were defined in some namespace or record). This field
	// should be human-readable and can be displayed in a UI.
	Identifier string `protobuf:"bytes,4,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// An unambiguous (as possible) identifier for this object ("bar()" or
	// "foo()" above; if it was defined in a namespace, "ns::bar()";
	// if it took arguments, "ns::bar(int *, void *)"). This field should
	// be human-readable and can be displayed in a UI.
	DisplayName string `protobuf:"bytes,5,opt,name=display_name,proto3" json:"display_name,omitempty"`
	// The parameters bound by the object referred to by `definition` above.
	// There is no semantic meaning to the order of this array, but it should
	// be reasonable to surface the ordering in a UI (for example, term-level
	// parameters will not be capriciously reordered).
	Parameter []*CallersReply_CallableDetail_Parameter `protobuf:"bytes,6,rep,name=parameter" json:"parameter,omitempty"`
}

func (m *CallersReply_CallableDetail) Reset()         { *m = CallersReply_CallableDetail{} }
func (m *CallersReply_CallableDetail) String() string { return proto.CompactTextString(m) }
func (*CallersReply_CallableDetail) ProtoMessage()    {}

func (m *CallersReply_CallableDetail) GetDefinition() *Anchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CallersReply_CallableDetail) GetParameter() []*CallersReply_CallableDetail_Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// A parameter bound by the object referred to by `definition` above.
type CallersReply_CallableDetail_Parameter struct {
	// The parameter's kind.
	Kind CallersReply_CallableDetail_Parameter_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=kythe.proto.CallersReply_CallableDetail_Parameter_Kind" json:"kind,omitempty"`
	// The parameter's (unqualified) human-readable and displayable name.
	// May be empty. May also be non-unique; for example, the identifiers for
	// the (unnamed in the source language) parameters for the function
	// `void ignore_pair(int, int)` may be "int" and "int".
	Identifier string `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// The ticket that refers to the parameter.
	Ticket string `protobuf:"bytes,3,opt,name=ticket,proto3" json:"ticket,omitempty"`
}

func (m *CallersReply_CallableDetail_Parameter) Reset()         { *m = CallersReply_CallableDetail_Parameter{} }
func (m *CallersReply_CallableDetail_Parameter) String() string { return proto.CompactTextString(m) }
func (*CallersReply_CallableDetail_Parameter) ProtoMessage()    {}

// An object that was blamed for making a call to an object in the set passed
// to Callers, along with the syntactic locations that caused that blame to
// be cast.
type CallersReply_Caller struct {
	// The object (e.g., a function) responsible for making a call.
	Detail   *CallersReply_CallableDetail    `protobuf:"bytes,1,opt,name=detail" json:"detail,omitempty"`
	CallSite []*CallersReply_Caller_CallSite `protobuf:"bytes,2,rep,name=call_site" json:"call_site,omitempty"`
}

func (m *CallersReply_Caller) Reset()         { *m = CallersReply_Caller{} }
func (m *CallersReply_Caller) String() string { return proto.CompactTextString(m) }
func (*CallersReply_Caller) ProtoMessage()    {}

func (m *CallersReply_Caller) GetDetail() *CallersReply_CallableDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *CallersReply_Caller) GetCallSite() []*CallersReply_Caller_CallSite {
	if m != nil {
		return m.CallSite
	}
	return nil
}

type CallersReply_Caller_CallSite struct {
	// The location where a call was found inside the blamed object.
	Anchor *Anchor `protobuf:"bytes,1,opt,name=anchor" json:"anchor,omitempty"`
	// This field will be set to true iff this call site was included in the
	// results because include_overrides was true in CallersRequest.
	CallToOverride bool `protobuf:"varint,2,opt,name=call_to_override,proto3" json:"call_to_override,omitempty"`
}

func (m *CallersReply_Caller_CallSite) Reset()         { *m = CallersReply_Caller_CallSite{} }
func (m *CallersReply_Caller_CallSite) String() string { return proto.CompactTextString(m) }
func (*CallersReply_Caller_CallSite) ProtoMessage()    {}

func (m *CallersReply_Caller_CallSite) GetAnchor() *Anchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func init() {
	proto.RegisterType((*NodesRequest)(nil), "kythe.proto.NodesRequest")
	proto.RegisterType((*NodeInfo)(nil), "kythe.proto.NodeInfo")
	proto.RegisterType((*NodesReply)(nil), "kythe.proto.NodesReply")
	proto.RegisterType((*EdgesRequest)(nil), "kythe.proto.EdgesRequest")
	proto.RegisterType((*EdgeSet)(nil), "kythe.proto.EdgeSet")
	proto.RegisterType((*EdgeSet_Group)(nil), "kythe.proto.EdgeSet.Group")
	proto.RegisterType((*EdgesReply)(nil), "kythe.proto.EdgesReply")
	proto.RegisterType((*Location)(nil), "kythe.proto.Location")
	proto.RegisterType((*Location_Point)(nil), "kythe.proto.Location.Point")
	proto.RegisterType((*DecorationsRequest)(nil), "kythe.proto.DecorationsRequest")
	proto.RegisterType((*DecorationsReply)(nil), "kythe.proto.DecorationsReply")
	proto.RegisterType((*DecorationsReply_Reference)(nil), "kythe.proto.DecorationsReply.Reference")
	proto.RegisterType((*CrossReferencesRequest)(nil), "kythe.proto.CrossReferencesRequest")
	proto.RegisterType((*Anchor)(nil), "kythe.proto.Anchor")
	proto.RegisterType((*CrossReferencesReply)(nil), "kythe.proto.CrossReferencesReply")
	proto.RegisterType((*CrossReferencesReply_RelatedNode)(nil), "kythe.proto.CrossReferencesReply.RelatedNode")
	proto.RegisterType((*CrossReferencesReply_CrossReferenceSet)(nil), "kythe.proto.CrossReferencesReply.CrossReferenceSet")
	proto.RegisterType((*CallersRequest)(nil), "kythe.proto.CallersRequest")
	proto.RegisterType((*CallersReply)(nil), "kythe.proto.CallersReply")
	proto.RegisterType((*CallersReply_CallableDetail)(nil), "kythe.proto.CallersReply.CallableDetail")
	proto.RegisterType((*CallersReply_CallableDetail_Parameter)(nil), "kythe.proto.CallersReply.CallableDetail.Parameter")
	proto.RegisterType((*CallersReply_Caller)(nil), "kythe.proto.CallersReply.Caller")
	proto.RegisterType((*CallersReply_Caller_CallSite)(nil), "kythe.proto.CallersReply.Caller.CallSite")
	proto.RegisterEnum("kythe.proto.Location_Kind", Location_Kind_name, Location_Kind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DefinitionKind", CrossReferencesRequest_DefinitionKind_name, CrossReferencesRequest_DefinitionKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_ReferenceKind", CrossReferencesRequest_ReferenceKind_name, CrossReferencesRequest_ReferenceKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DocumentationKind", CrossReferencesRequest_DocumentationKind_name, CrossReferencesRequest_DocumentationKind_value)
	proto.RegisterEnum("kythe.proto.CallersReply_CallableDetail_Parameter_Kind", CallersReply_CallableDetail_Parameter_Kind_name, CallersReply_CallableDetail_Parameter_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for XRefService service

type XRefServiceClient interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error)
	// Callers takes a set of tickets for semantic objects and returns the set
	// of places where those objects were called. For example, in the program
	//   void bar() { foo(); foo(); } void baz() { foo(); } void foo() { }
	// `Callers({foo})` would return:
	//   {(bar, {first-call-anchor, second-call-anchor}),
	//    (baz, {first-call-anchor})}
	// To walk further up the call graph, you can project the first field of
	// each tuple in the result set ({bar, baz}) and feed that set back in
	// to a new Callers request.
	//
	// The core of this query is specified in terms of graph operations in the
	// Kythe repository at //kythe/docs/schema/callgraph.txt.
	Callers(ctx context.Context, in *CallersRequest, opts ...grpc.CallOption) (*CallersReply, error)
}

type xRefServiceClient struct {
	cc *grpc.ClientConn
}

func NewXRefServiceClient(cc *grpc.ClientConn) XRefServiceClient {
	return &xRefServiceClient{cc}
}

func (c *xRefServiceClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Nodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error) {
	out := new(EdgesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Edges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error) {
	out := new(DecorationsReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Decorations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error) {
	out := new(CrossReferencesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/CrossReferences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Callers(ctx context.Context, in *CallersRequest, opts ...grpc.CallOption) (*CallersReply, error) {
	out := new(CallersReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Callers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XRefService service

type XRefServiceServer interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(context.Context, *NodesRequest) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(context.Context, *EdgesRequest) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(context.Context, *DecorationsRequest) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(context.Context, *CrossReferencesRequest) (*CrossReferencesReply, error)
	// Callers takes a set of tickets for semantic objects and returns the set
	// of places where those objects were called. For example, in the program
	//   void bar() { foo(); foo(); } void baz() { foo(); } void foo() { }
	// `Callers({foo})` would return:
	//   {(bar, {first-call-anchor, second-call-anchor}),
	//    (baz, {first-call-anchor})}
	// To walk further up the call graph, you can project the first field of
	// each tuple in the result set ({bar, baz}) and feed that set back in
	// to a new Callers request.
	//
	// The core of this query is specified in terms of graph operations in the
	// Kythe repository at //kythe/docs/schema/callgraph.txt.
	Callers(context.Context, *CallersRequest) (*CallersReply, error)
}

func RegisterXRefServiceServer(s *grpc.Server, srv XRefServiceServer) {
	s.RegisterService(&_XRefService_serviceDesc, srv)
}

func _XRefService_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Nodes(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Edges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EdgesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Edges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Decorations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DecorationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Decorations(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_CrossReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CrossReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).CrossReferences(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _XRefService_Callers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CallersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(XRefServiceServer).Callers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _XRefService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.XRefService",
	HandlerType: (*XRefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Nodes",
			Handler:    _XRefService_Nodes_Handler,
		},
		{
			MethodName: "Edges",
			Handler:    _XRefService_Edges_Handler,
		},
		{
			MethodName: "Decorations",
			Handler:    _XRefService_Decorations_Handler,
		},
		{
			MethodName: "CrossReferences",
			Handler:    _XRefService_CrossReferences_Handler,
		},
		{
			MethodName: "Callers",
			Handler:    _XRefService_Callers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *NodesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *NodeInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Fact) > 0 {
		for _, msg := range m.Fact {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, msg := range m.Node {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EdgesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Kind) > 0 {
		for _, s := range m.Kind {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.PageSize != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintXref(data, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.PageToken)))
		i += copy(data[i:], m.PageToken)
	}
	return i, nil
}

func (m *EdgeSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTicket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if len(m.Group) > 0 {
		for _, msg := range m.Group {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EdgeSet_Group) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeSet_Group) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.TargetTicket) > 0 {
		for _, s := range m.TargetTicket {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *EdgesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeSet) > 0 {
		for _, msg := range m.EdgeSet {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Node) > 0 {
		for _, msg := range m.Node {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.NextPageToken)))
		i += copy(data[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *Location) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Location) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Kind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if m.Start != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(m.Start.Size()))
		n1, err := m.Start.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.End != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.End.Size()))
		n2, err := m.End.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Location_Point) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Location_Point) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ByteOffset != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintXref(data, i, uint64(m.ByteOffset))
	}
	if m.LineNumber != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.ColumnOffset))
	}
	return i, nil
}

func (m *DecorationsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Location.Size()))
		n3, err := m.Location.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DirtyBuffer != nil {
		if len(m.DirtyBuffer) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(len(m.DirtyBuffer)))
			i += copy(data[i:], m.DirtyBuffer)
		}
	}
	if m.SourceText {
		data[i] = 0x18
		i++
		if m.SourceText {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.References {
		data[i] = 0x20
		i++
		if m.References {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DecorationsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Location.Size()))
		n4, err := m.Location.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SourceText != nil {
		if len(m.SourceText) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(len(m.SourceText)))
			i += copy(data[i:], m.SourceText)
		}
	}
	if len(m.Encoding) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Encoding)))
		i += copy(data[i:], m.Encoding)
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			data[i] = 0x22
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Node) > 0 {
		for _, msg := range m.Node {
			data[i] = 0x7a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DecorationsReply_Reference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply_Reference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTicket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if len(m.TargetTicket) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.TargetTicket)))
		i += copy(data[i:], m.TargetTicket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if m.AnchorStart != nil {
		data[i] = 0x52
		i++
		i = encodeVarintXref(data, i, uint64(m.AnchorStart.Size()))
		n5, err := m.AnchorStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AnchorEnd != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintXref(data, i, uint64(m.AnchorEnd.Size()))
		n6, err := m.AnchorEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CrossReferencesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.DefinitionKind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.ReferenceKind))
	}
	if m.DocumentationKind != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintXref(data, i, uint64(m.DocumentationKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.AnchorText {
		data[i] = 0x30
		i++
		if m.AnchorText {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.PageSize != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintXref(data, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.PageToken)))
		i += copy(data[i:], m.PageToken)
	}
	return i, nil
}

func (m *Anchor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Anchor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Parent) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Parent)))
		i += copy(data[i:], m.Parent)
	}
	if m.Start != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.Start.Size()))
		n7, err := m.Start.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.End != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(m.End.Size()))
		n8, err := m.End.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Text) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Text)))
		i += copy(data[i:], m.Text)
	}
	if len(m.Snippet) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Snippet)))
		i += copy(data[i:], m.Snippet)
	}
	if m.SnippetStart != nil {
		data[i] = 0x42
		i++
		i = encodeVarintXref(data, i, uint64(m.SnippetStart.Size()))
		n9, err := m.SnippetStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SnippetEnd != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(m.SnippetEnd.Size()))
		n10, err := m.SnippetEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CrossReferencesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, _ := range m.CrossReferences {
			data[i] = 0xa
			i++
			v := m.CrossReferences[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n11, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n11
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x12
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n12, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n12
		}
	}
	if len(m.NextPageToken) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintXref(data, i, uint64(len(m.NextPageToken)))
		i += copy(data[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CrossReferencesReply_RelatedNode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_RelatedNode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.RelationKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.RelationKind)))
		i += copy(data[i:], m.RelationKind)
	}
	return i, nil
}

func (m *CrossReferencesReply_CrossReferenceSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_CrossReferenceSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Definition) > 0 {
		for _, msg := range m.Definition {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			data[i] = 0x1a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Documentation) > 0 {
		for _, msg := range m.Documentation {
			data[i] = 0x22
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RelatedNode) > 0 {
		for _, msg := range m.RelatedNode {
			data[i] = 0x52
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SemanticObject) > 0 {
		for _, s := range m.SemanticObject {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.IncludeOverrides {
		data[i] = 0x10
		i++
		if m.IncludeOverrides {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CallersReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Caller) > 0 {
		for _, msg := range m.Caller {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Callee) > 0 {
		for _, msg := range m.Callee {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersReply_CallableDetail) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_CallableDetail) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Definition != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Definition.Size()))
		n13, err := m.Definition.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.SemanticObject) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SemanticObject)))
		i += copy(data[i:], m.SemanticObject)
	}
	if len(m.SemanticObjectCallable) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SemanticObjectCallable)))
		i += copy(data[i:], m.SemanticObjectCallable)
	}
	if len(m.Identifier) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Identifier)))
		i += copy(data[i:], m.Identifier)
	}
	if len(m.DisplayName) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.DisplayName)))
		i += copy(data[i:], m.DisplayName)
	}
	if len(m.Parameter) > 0 {
		for _, msg := range m.Parameter {
			data[i] = 0x32
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersReply_CallableDetail_Parameter) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_CallableDetail_Parameter) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if len(m.Identifier) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Identifier)))
		i += copy(data[i:], m.Identifier)
	}
	if len(m.Ticket) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	return i, nil
}

func (m *CallersReply_Caller) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_Caller) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Detail.Size()))
		n14, err := m.Detail.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.CallSite) > 0 {
		for _, msg := range m.CallSite {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersReply_Caller_CallSite) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_Caller_CallSite) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Anchor.Size()))
		n15, err := m.Anchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.CallToOverride {
		data[i] = 0x10
		i++
		if m.CallToOverride {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Xref(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Xref(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintXref(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *NodesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Fact) > 0 {
		for _, e := range m.Fact {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *NodesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, e := range m.Node {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *EdgesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Kind) > 0 {
		for _, s := range m.Kind {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.PageSize != 0 {
		n += 1 + sovXref(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *EdgeSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *EdgeSet_Group) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.TargetTicket) > 0 {
		for _, s := range m.TargetTicket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *EdgesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.EdgeSet) > 0 {
		for _, e := range m.EdgeSet {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Node) > 0 {
		for _, e := range m.Node {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Location_Point) Size() (n int) {
	var l int
	_ = l
	if m.ByteOffset != 0 {
		n += 1 + sovXref(uint64(m.ByteOffset))
	}
	if m.LineNumber != 0 {
		n += 1 + sovXref(uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		n += 1 + sovXref(uint64(m.ColumnOffset))
	}
	return n
}

func (m *DecorationsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.DirtyBuffer != nil {
		l = len(m.DirtyBuffer)
		if l > 0 {
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.SourceText {
		n += 2
	}
	if m.References {
		n += 2
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DecorationsReply) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SourceText != nil {
		l = len(m.SourceText)
		if l > 0 {
			n += 1 + l + sovXref(uint64(l))
		}
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Node) > 0 {
		for _, e := range m.Node {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DecorationsReply_Reference) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.AnchorStart != nil {
		l = m.AnchorStart.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.AnchorEnd != nil {
		l = m.AnchorEnd.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.DefinitionKind != 0 {
		n += 1 + sovXref(uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		n += 1 + sovXref(uint64(m.ReferenceKind))
	}
	if m.DocumentationKind != 0 {
		n += 1 + sovXref(uint64(m.DocumentationKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.AnchorText {
		n += 2
	}
	if m.PageSize != 0 {
		n += 1 + sovXref(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Anchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Snippet)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetStart != nil {
		l = m.SnippetStart.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetEnd != nil {
		l = m.SnippetEnd.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, v := range m.CrossReferences {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_RelatedNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.RelationKind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_CrossReferenceSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Definition) > 0 {
		for _, e := range m.Definition {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Documentation) > 0 {
		for _, e := range m.Documentation {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.RelatedNode) > 0 {
		for _, e := range m.RelatedNode {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.SemanticObject) > 0 {
		for _, s := range m.SemanticObject {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.IncludeOverrides {
		n += 2
	}
	return n
}

func (m *CallersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Caller) > 0 {
		for _, e := range m.Caller {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Callee) > 0 {
		for _, e := range m.Callee {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersReply_CallableDetail) Size() (n int) {
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SemanticObject)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SemanticObjectCallable)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Parameter) > 0 {
		for _, e := range m.Parameter {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersReply_CallableDetail_Parameter) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CallersReply_Caller) Size() (n int) {
	var l int
	_ = l
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.CallSite) > 0 {
		for _, e := range m.CallSite {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersReply_Caller_CallSite) Size() (n int) {
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.CallToOverride {
		n += 2
	}
	return n
}

func sovXref(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozXref(x uint64) (n int) {
	return sovXref(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fact = append(m.Fact, &kythe_proto_common.Fact{})
			if err := m.Fact[len(m.Fact)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node, &NodeInfo{})
			if err := m.Node[len(m.Node)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = append(m.Kind, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &EdgeSet_Group{})
			if err := m.Group[len(m.Group)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet_Group) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = append(m.TargetTicket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeSet = append(m.EdgeSet, &EdgeSet{})
			if err := m.EdgeSet[len(m.EdgeSet)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node, &NodeInfo{})
			if err := m.Node[len(m.Node)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (Location_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Location_Point{}
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Location_Point{}
			}
			if err := m.End.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location_Point) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOffset", wireType)
			}
			m.ByteOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineNumber", wireType)
			}
			m.LineNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LineNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOffset", wireType)
			}
			m.ColumnOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ColumnOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyBuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirtyBuffer = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceText = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.References = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceText = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &DecorationsReply_Reference{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node, &NodeInfo{})
			if err := m.Node[len(m.Node)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Reference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorStart == nil {
				m.AnchorStart = &Location_Point{}
			}
			if err := m.AnchorStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorEnd == nil {
				m.AnchorEnd = &Location_Point{}
			}
			if err := m.AnchorEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionKind", wireType)
			}
			m.DefinitionKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DefinitionKind |= (CrossReferencesRequest_DefinitionKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceKind", wireType)
			}
			m.ReferenceKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReferenceKind |= (CrossReferencesRequest_ReferenceKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationKind", wireType)
			}
			m.DocumentationKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DocumentationKind |= (CrossReferencesRequest_DocumentationKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AnchorText = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Anchor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Anchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Anchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Location_Point{}
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Location_Point{}
			}
			if err := m.End.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snippet = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetStart == nil {
				m.SnippetStart = &Location_Point{}
			}
			if err := m.SnippetStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetEnd == nil {
				m.SnippetEnd = &Location_Point{}
			}
			if err := m.SnippetEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &CrossReferencesReply_CrossReferenceSet{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.CrossReferences == nil {
				m.CrossReferences = make(map[string]*CrossReferencesReply_CrossReferenceSet)
			}
			m.CrossReferences[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_RelatedNode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_CrossReferenceSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferenceSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferenceSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, &Anchor{})
			if err := m.Definition[len(m.Definition)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &Anchor{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documentation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Documentation = append(m.Documentation, &Anchor{})
			if err := m.Documentation[len(m.Documentation)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedNode = append(m.RelatedNode, &CrossReferencesReply_RelatedNode{})
			if err := m.RelatedNode[len(m.RelatedNode)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticObject = append(m.SemanticObject, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeOverrides", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeOverrides = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = append(m.Caller, &CallersReply_Caller{})
			if err := m.Caller[len(m.Caller)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callee = append(m.Callee, &CallersReply_CallableDetail{})
			if err := m.Callee[len(m.Callee)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_CallableDetail) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallableDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallableDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &Anchor{}
			}
			if err := m.Definition.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticObject = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticObjectCallable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticObjectCallable = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameter = append(m.Parameter, &CallersReply_CallableDetail_Parameter{})
			if err := m.Parameter[len(m.Parameter)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_CallableDetail_Parameter) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (CallersReply_CallableDetail_Parameter_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_Caller) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Caller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Caller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &CallersReply_CallableDetail{}
			}
			if err := m.Detail.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSite = append(m.CallSite, &CallersReply_Caller_CallSite{})
			if err := m.CallSite[len(m.CallSite)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_Caller_CallSite) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallSite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallSite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &Anchor{}
			}
			if err := m.Anchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CallToOverride = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipXref(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowXref
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthXref
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowXref
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipXref(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthXref = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowXref   = fmt.Errorf("proto: integer overflow")
)
