// Code generated by protoc-gen-gogo.
// source: kythe/proto/xref.proto
// DO NOT EDIT!

/*
	Package xref_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/xref.proto

	It has these top-level messages:
		Location
		DecorationsRequest
		DecorationsReply
		CrossReferencesRequest
		Anchor
		Link
		Printable
		CrossReferencesReply
		DocumentationRequest
		DocumentationReply
*/
package xref_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_common "kythe.io/kythe/proto/common_proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Location_Kind int32

const (
	// The entire file; the start and end fields are ignored.
	Location_FILE Location_Kind = 0
	// The point or span of file subtended by start and end.
	Location_SPAN Location_Kind = 1
)

var Location_Kind_name = map[int32]string{
	0: "FILE",
	1: "SPAN",
}
var Location_Kind_value = map[string]int32{
	"FILE": 0,
	"SPAN": 1,
}

func (x Location_Kind) String() string {
	return proto.EnumName(Location_Kind_name, int32(x))
}
func (Location_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorXref, []int{0, 0} }

type DecorationsRequest_SpanKind int32

const (
	// If the location is a SPAN, only decorations contained within the
	// specified window of the file are returned.  This is the default behavior.
	DecorationsRequest_WITHIN_SPAN DecorationsRequest_SpanKind = 0
	// If the location is a SPAN, any decorations that surround it are returned.
	DecorationsRequest_AROUND_SPAN DecorationsRequest_SpanKind = 1
)

var DecorationsRequest_SpanKind_name = map[int32]string{
	0: "WITHIN_SPAN",
	1: "AROUND_SPAN",
}
var DecorationsRequest_SpanKind_value = map[string]int32{
	"WITHIN_SPAN": 0,
	"AROUND_SPAN": 1,
}

func (x DecorationsRequest_SpanKind) String() string {
	return proto.EnumName(DecorationsRequest_SpanKind_name, int32(x))
}
func (DecorationsRequest_SpanKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{1, 0}
}

// What kind of override this is.
type DecorationsReply_Override_Kind int32

const (
	DecorationsReply_Override_OVERRIDES DecorationsReply_Override_Kind = 0
	DecorationsReply_Override_EXTENDS   DecorationsReply_Override_Kind = 1
)

var DecorationsReply_Override_Kind_name = map[int32]string{
	0: "OVERRIDES",
	1: "EXTENDS",
}
var DecorationsReply_Override_Kind_value = map[string]int32{
	"OVERRIDES": 0,
	"EXTENDS":   1,
}

func (x DecorationsReply_Override_Kind) String() string {
	return proto.EnumName(DecorationsReply_Override_Kind_name, int32(x))
}
func (DecorationsReply_Override_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{2, 1, 0}
}

type CrossReferencesRequest_DefinitionKind int32

const (
	// No definitions will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DEFINITIONS CrossReferencesRequest_DefinitionKind = 0
	// All known definition anchors reached by the "/kythe/edge/defines" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 1
	// Only definition anchors reached by the "/kythe/edge/defines" edge kind
	// will be populated in the CrossReferencesReply.
	CrossReferencesRequest_FULL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 2
	// Only definition anchors reached by the "/kythe/edge/defines/binding" edge
	// kind will be populated in the CrossReferencesReply.
	CrossReferencesRequest_BINDING_DEFINITIONS CrossReferencesRequest_DefinitionKind = 3
)

var CrossReferencesRequest_DefinitionKind_name = map[int32]string{
	0: "NO_DEFINITIONS",
	1: "ALL_DEFINITIONS",
	2: "FULL_DEFINITIONS",
	3: "BINDING_DEFINITIONS",
}
var CrossReferencesRequest_DefinitionKind_value = map[string]int32{
	"NO_DEFINITIONS":      0,
	"ALL_DEFINITIONS":     1,
	"FULL_DEFINITIONS":    2,
	"BINDING_DEFINITIONS": 3,
}

func (x CrossReferencesRequest_DefinitionKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DefinitionKind_name, int32(x))
}
func (CrossReferencesRequest_DefinitionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 0}
}

type CrossReferencesRequest_DeclarationKind int32

const (
	// No declarations will be populated in the CrossDeclarationsReply.
	CrossReferencesRequest_NO_DECLARATIONS CrossReferencesRequest_DeclarationKind = 0
	// When the source node is incomplete, all known declaration anchors reached
	// by the "/kythe/edge/defines" edge kind (or its variants) will be
	// populated in the CrossDeclarationsReply.
	CrossReferencesRequest_ALL_DECLARATIONS CrossReferencesRequest_DeclarationKind = 1
)

var CrossReferencesRequest_DeclarationKind_name = map[int32]string{
	0: "NO_DECLARATIONS",
	1: "ALL_DECLARATIONS",
}
var CrossReferencesRequest_DeclarationKind_value = map[string]int32{
	"NO_DECLARATIONS":  0,
	"ALL_DECLARATIONS": 1,
}

func (x CrossReferencesRequest_DeclarationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DeclarationKind_name, int32(x))
}
func (CrossReferencesRequest_DeclarationKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 1}
}

type CrossReferencesRequest_ReferenceKind int32

const (
	// No references will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_REFERENCES CrossReferencesRequest_ReferenceKind = 0
	// Only callgraph-related references as described in
	// http://www.kythe.io/docs/schema/callgraph.html
	CrossReferencesRequest_CALL_REFERENCES CrossReferencesRequest_ReferenceKind = 1
	// All references except those that are related to the callgraph.
	CrossReferencesRequest_NON_CALL_REFERENCES CrossReferencesRequest_ReferenceKind = 2
	// All known reference anchors reached by the "/kythe/edge/ref" edge kind
	// (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_REFERENCES CrossReferencesRequest_ReferenceKind = 3
)

var CrossReferencesRequest_ReferenceKind_name = map[int32]string{
	0: "NO_REFERENCES",
	1: "CALL_REFERENCES",
	2: "NON_CALL_REFERENCES",
	3: "ALL_REFERENCES",
}
var CrossReferencesRequest_ReferenceKind_value = map[string]int32{
	"NO_REFERENCES":       0,
	"CALL_REFERENCES":     1,
	"NON_CALL_REFERENCES": 2,
	"ALL_REFERENCES":      3,
}

func (x CrossReferencesRequest_ReferenceKind) String() string {
	return proto.EnumName(CrossReferencesRequest_ReferenceKind_name, int32(x))
}
func (CrossReferencesRequest_ReferenceKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 2}
}

type CrossReferencesRequest_DocumentationKind int32

const (
	// No documentation will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 0
	// All known documentation reached by the "/kythe/edge/documentation" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 1
)

var CrossReferencesRequest_DocumentationKind_name = map[int32]string{
	0: "NO_DOCUMENTATION",
	1: "ALL_DOCUMENTATION",
}
var CrossReferencesRequest_DocumentationKind_value = map[string]int32{
	"NO_DOCUMENTATION":  0,
	"ALL_DOCUMENTATION": 1,
}

func (x CrossReferencesRequest_DocumentationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DocumentationKind_name, int32(x))
}
func (CrossReferencesRequest_DocumentationKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 3}
}

type CrossReferencesRequest_CallerKind int32

const (
	// No callgraph information will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_CALLERS CrossReferencesRequest_CallerKind = 0
	// Callgraph information will be populated in the CrossReferencesReply.
	CrossReferencesRequest_DIRECT_CALLERS CrossReferencesRequest_CallerKind = 1
	// Callgraph information will be populated in the CrossReferencesReply.
	// Calls to override-related functions will also be considered.
	CrossReferencesRequest_OVERRIDE_CALLERS CrossReferencesRequest_CallerKind = 2
)

var CrossReferencesRequest_CallerKind_name = map[int32]string{
	0: "NO_CALLERS",
	1: "DIRECT_CALLERS",
	2: "OVERRIDE_CALLERS",
}
var CrossReferencesRequest_CallerKind_value = map[string]int32{
	"NO_CALLERS":       0,
	"DIRECT_CALLERS":   1,
	"OVERRIDE_CALLERS": 2,
}

func (x CrossReferencesRequest_CallerKind) String() string {
	return proto.EnumName(CrossReferencesRequest_CallerKind_name, int32(x))
}
func (CrossReferencesRequest_CallerKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{3, 4}
}

type Link_Kind int32

const (
	// This annotates a link to a ticket.
	Link_DEFINITION Link_Kind = 0
	// This span of text contains a list of items.
	Link_LIST Link_Kind = 1
	// This span of text is an item in a list.
	Link_LIST_ITEM Link_Kind = 2
	// This span of text is important.
	Link_IMPORTANT Link_Kind = 999
)

var Link_Kind_name = map[int32]string{
	0:   "DEFINITION",
	1:   "LIST",
	2:   "LIST_ITEM",
	999: "IMPORTANT",
}
var Link_Kind_value = map[string]int32{
	"DEFINITION": 0,
	"LIST":       1,
	"LIST_ITEM":  2,
	"IMPORTANT":  999,
}

func (x Link_Kind) String() string {
	return proto.EnumName(Link_Kind_name, int32(x))
}
func (Link_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorXref, []int{5, 0} }

// A Location represents a single span of zero or more contiguous bytes of a
// file or buffer.  An empty LOCATION denotes the entirety of the referenced
// file or buffer.
//
type Location struct {
	// The ticket of the file this location belongs to.  If the location
	// represents a memory buffer, the ticket should be omitted.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// What kind of location this is.
	Kind Location_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.Location_Kind" json:"kind,omitempty"`
	// The starting point of the location.
	Start *Location_Point `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	// The ending point of the location.
	End *Location_Point `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{0} }

func (m *Location) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Location) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

// A Point represents a location within a file or buffer.
//
// If line_number ≤ 0, the line number and column offset are considered
// unknown and will be ignored.
//
// A point with line_number > 0 is said to be _normalized_ if it satisfies
// the constraint 0 ≤ column_offset ≤ bytelen(line_number); that is, if the
// column_offset is within the actual range of the corresponding line.  A
// point can be normalized by adjusting line_number and column_offset so that
// this constraint is satisfied.  This may be impossible if the column offset
// exceeds the bounds of the file.
type Location_Point struct {
	// The offset in bytes from the beginning of the file.
	// Requires 0 ≤ byte_offset ≤ len(file).
	ByteOffset int32 `protobuf:"varint,1,opt,name=byte_offset,json=byteOffset,proto3" json:"byte_offset,omitempty"`
	// The line number containing the point, 1-based.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number,json=lineNumber,proto3" json:"line_number,omitempty"`
	// The byte offset of the point within its line.
	ColumnOffset int32 `protobuf:"varint,3,opt,name=column_offset,json=columnOffset,proto3" json:"column_offset,omitempty"`
}

func (m *Location_Point) Reset()                    { *m = Location_Point{} }
func (m *Location_Point) String() string            { return proto.CompactTextString(m) }
func (*Location_Point) ProtoMessage()               {}
func (*Location_Point) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{0, 0} }

type DecorationsRequest struct {
	// The location of the file to fetch decorations for.  The ticket of location
	// must be non-empty.  It is an error in any case if location is invalid.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// How to treat SPAN locations.
	SpanKind DecorationsRequest_SpanKind `protobuf:"varint,10,opt,name=span_kind,json=spanKind,proto3,enum=kythe.proto.DecorationsRequest_SpanKind" json:"span_kind,omitempty"`
	// If dirty_buffer is non-empty, the results will be adjusted (patched) to
	// account for the regions of the specified file differing from the contents
	// of the dirty buffer.
	DirtyBuffer []byte `protobuf:"bytes,2,opt,name=dirty_buffer,json=dirtyBuffer,proto3" json:"dirty_buffer,omitempty"`
	// If true, return the encoded source text for the selected window.  Source
	// text is not affected by patching.
	SourceText bool `protobuf:"varint,3,opt,name=source_text,json=sourceText,proto3" json:"source_text,omitempty"`
	// If true, return reference edges whose source nodes are located in the
	// selected window.  References are affected by patching.
	References bool `protobuf:"varint,4,opt,name=references,proto3" json:"references,omitempty"`
	// If true, return definition locations, if possible, for each returned
	// reference target in the DecorationsReply.
	TargetDefinitions bool `protobuf:"varint,6,opt,name=target_definitions,json=targetDefinitions,proto3" json:"target_definitions,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
	// (graph.proto) for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// If true, for every defines/binding Reference in the reply, a NodeInfo
	// will be provided for each node that Reference extends or overrides.
	// Furthermore, if definition_locations is true, the response's
	// definition_locations field will include (where possible) the locations of
	// the definitions of the nodes that are extended or overridden.
	ExtendsOverrides bool `protobuf:"varint,7,opt,name=extends_overrides,json=extendsOverrides,proto3" json:"extends_overrides,omitempty"`
}

func (m *DecorationsRequest) Reset()                    { *m = DecorationsRequest{} }
func (m *DecorationsRequest) String() string            { return proto.CompactTextString(m) }
func (*DecorationsRequest) ProtoMessage()               {}
func (*DecorationsRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{1} }

func (m *DecorationsRequest) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

type DecorationsReply struct {
	// The normalized location for which decorations are returned.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The encoded source text for the selected window.
	SourceText []byte `protobuf:"bytes,2,opt,name=source_text,json=sourceText,proto3" json:"source_text,omitempty"`
	Encoding   string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// The reference edges located in the specified window.
	Reference []*DecorationsReply_Reference `protobuf:"bytes,4,rep,name=reference" json:"reference,omitempty"`
	// This field will contain one entry, keyed by ticket, for each distinct node
	// referenced by a reference edge that has at least 1 non-filtered fact.
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,15,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Each anchor cited as a target definition in the references.  The map is
	// keyed by each anchor's ticket.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,16,rep,name=definition_locations,json=definitionLocations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Maps from semantic nodes on the right-hand side of defines/binding
	// references to the list of their overrides.
	ExtendsOverrides map[string]*DecorationsReply_Overrides `protobuf:"bytes,17,rep,name=extends_overrides,json=extendsOverrides" json:"extends_overrides,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DecorationsReply) Reset()                    { *m = DecorationsReply{} }
func (m *DecorationsReply) String() string            { return proto.CompactTextString(m) }
func (*DecorationsReply) ProtoMessage()               {}
func (*DecorationsReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{2} }

func (m *DecorationsReply) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsReply) GetReference() []*DecorationsReply_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *DecorationsReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DecorationsReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

func (m *DecorationsReply) GetExtendsOverrides() map[string]*DecorationsReply_Overrides {
	if m != nil {
		return m.ExtendsOverrides
	}
	return nil
}

// Represents a reference edge source ---KIND---> target.  Each source is an
// anchor within the requested source location.
type DecorationsReply_Reference struct {
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket,json=sourceTicket,proto3" json:"source_ticket,omitempty"`
	TargetTicket string `protobuf:"bytes,2,opt,name=target_ticket,json=targetTicket,proto3" json:"target_ticket,omitempty"`
	Kind         string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Starting byte offset of this references's anchor (source_ticket) span.
	AnchorStart *Location_Point `protobuf:"bytes,10,opt,name=anchor_start,json=anchorStart" json:"anchor_start,omitempty"`
	// Ending byte offset of this references's anchor (source_ticket) span.
	AnchorEnd *Location_Point `protobuf:"bytes,11,opt,name=anchor_end,json=anchorEnd" json:"anchor_end,omitempty"`
	// Anchor ticket of the target's definition.  Populated only if
	// target_definitions is true in the DecorationsRequest and the target has
	// a single unambiguous definition.  For each ticket, an Anchor will be
	// populated in the top-level definition_locations map.
	TargetDefinition string `protobuf:"bytes,4,opt,name=target_definition,json=targetDefinition,proto3" json:"target_definition,omitempty"`
}

func (m *DecorationsReply_Reference) Reset()         { *m = DecorationsReply_Reference{} }
func (m *DecorationsReply_Reference) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Reference) ProtoMessage()    {}
func (*DecorationsReply_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{2, 0}
}

func (m *DecorationsReply_Reference) GetAnchorStart() *Location_Point {
	if m != nil {
		return m.AnchorStart
	}
	return nil
}

func (m *DecorationsReply_Reference) GetAnchorEnd() *Location_Point {
	if m != nil {
		return m.AnchorEnd
	}
	return nil
}

type DecorationsReply_Override struct {
	// The target object.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// The kind of override.
	Kind DecorationsReply_Override_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.DecorationsReply_Override_Kind" json:"kind,omitempty"`
	// A display name for the object at ticket.
	DisplayName *Printable `protobuf:"bytes,3,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
}

func (m *DecorationsReply_Override) Reset()                    { *m = DecorationsReply_Override{} }
func (m *DecorationsReply_Override) String() string            { return proto.CompactTextString(m) }
func (*DecorationsReply_Override) ProtoMessage()               {}
func (*DecorationsReply_Override) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{2, 1} }

func (m *DecorationsReply_Override) GetDisplayName() *Printable {
	if m != nil {
		return m.DisplayName
	}
	return nil
}

type DecorationsReply_Overrides struct {
	Override []*DecorationsReply_Override `protobuf:"bytes,1,rep,name=override" json:"override,omitempty"`
}

func (m *DecorationsReply_Overrides) Reset()         { *m = DecorationsReply_Overrides{} }
func (m *DecorationsReply_Overrides) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Overrides) ProtoMessage()    {}
func (*DecorationsReply_Overrides) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{2, 2}
}

func (m *DecorationsReply_Overrides) GetOverride() []*DecorationsReply_Override {
	if m != nil {
		return m.Override
	}
	return nil
}

type CrossReferencesRequest struct {
	// Set of nodes for which to return their cross-references.  Must be
	// non-empty.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// Determines what kind of definition anchors, if any, should be returned in
	// the response.  See the documentation for each DefinitionKind for more
	// information.
	DefinitionKind CrossReferencesRequest_DefinitionKind `protobuf:"varint,2,opt,name=definition_kind,json=definitionKind,proto3,enum=kythe.proto.CrossReferencesRequest_DefinitionKind" json:"definition_kind,omitempty"`
	// Determines what kind of declaration anchors, if any, should be returned in
	// the response.  See the documentation for each DeclarationKind for more
	// information.
	DeclarationKind CrossReferencesRequest_DeclarationKind `protobuf:"varint,7,opt,name=declaration_kind,json=declarationKind,proto3,enum=kythe.proto.CrossReferencesRequest_DeclarationKind" json:"declaration_kind,omitempty"`
	// Determines what kind of reference anchors, if any, should be returned in
	// the response.  See the documentation for each ReferenceKind for more
	// information.
	ReferenceKind CrossReferencesRequest_ReferenceKind `protobuf:"varint,3,opt,name=reference_kind,json=referenceKind,proto3,enum=kythe.proto.CrossReferencesRequest_ReferenceKind" json:"reference_kind,omitempty"`
	// Determines what kind of documentation anchors, if any, should be returned
	// in the response.  See the documentation for each DocumentationKind for more
	// information.
	// NOTE: this field is deprecated and will be treated as NO_DOCUMENTATION
	// in the future.
	DocumentationKind CrossReferencesRequest_DocumentationKind `protobuf:"varint,4,opt,name=documentation_kind,json=documentationKind,proto3,enum=kythe.proto.CrossReferencesRequest_DocumentationKind" json:"documentation_kind,omitempty"`
	// Determines what kind of callgraph information, if any, should be returned
	// in the response.  See the documentation for each CallerKind for more
	// information.
	CallerKind CrossReferencesRequest_CallerKind `protobuf:"varint,12,opt,name=caller_kind,json=callerKind,proto3,enum=kythe.proto.CrossReferencesRequest_CallerKind" json:"caller_kind,omitempty"`
	// Collection of filter globs that determines which facts will be returned for
	// the related nodes of each requested node.  If filter is empty or unset, no
	// node facts or related nodes are returned.  See EdgesRequest (graph.proto)
	// for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// Determines whether each Anchor in the response should have its text field
	// populated.
	AnchorText bool `protobuf:"varint,6,opt,name=anchor_text,json=anchorText,proto3" json:"anchor_text,omitempty"`
	// Determines whether each NodeInfo matching the above filters will have its
	// definition location populated, if known.
	NodeDefinitions bool `protobuf:"varint,8,opt,name=node_definitions,json=nodeDefinitions,proto3" json:"node_definitions,omitempty"`
	// Enable the experimental generation of signatures in the
	// CrossReferencesReply.  Enabling this currently causes multiple lookups and
	// can significantly impact latency.  Once latency concerns have been
	// addressed, this field will be removed and signatures will be returned by
	// default.
	// TODO(T156): remove this flag; always enable feature
	ExperimentalSignatures bool `protobuf:"varint,100,opt,name=experimental_signatures,json=experimentalSignatures,proto3" json:"experimental_signatures,omitempty"`
	// The cross-references matching a request are organized into logical pages.
	// The size of each page is a number of distinct cross-references
	// (definitions, references, documentation, and related nodes).
	//
	// If page_token is empty, cross-references will be returned starting at the
	// beginning of the sequence; otherwise the starting point named by the
	// page_token will be used.  Legal values of page_token are returned by the
	// server in the next_page_token field of the CrossReferencesReply.  A page
	// token should be treated as an opaque value by the client, and is valid only
	// relative to a particular CrossReferencesRequest.  If an invalid page token
	// is requested, the server will return an error.
	//
	// If page_size > 0, at most that number of cross-references will be returned
	// by the service for this request (see ReferenceSet and CrossReferencesReply
	// below).  If page_size = 0, the default, the server will assume a reasonable
	// default page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer cross-references than the requested
	// page_size, even if more are available, save that it must return at least 1
	// edge if any are available at all.
	PageSize  int32  `protobuf:"varint,10,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,11,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *CrossReferencesRequest) Reset()                    { *m = CrossReferencesRequest{} }
func (m *CrossReferencesRequest) String() string            { return proto.CompactTextString(m) }
func (*CrossReferencesRequest) ProtoMessage()               {}
func (*CrossReferencesRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{3} }

type Anchor struct {
	// Ticket of the anchor node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the anchor's relationship with its referenced node
	Kind string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	// Parent ticket of the anchor; this is the file containing the anchor
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// Starting location of the anchor within its parent's text
	Start *Location_Point `protobuf:"bytes,4,opt,name=start" json:"start,omitempty"`
	// Ending location of the anchor within its parent's text
	End *Location_Point `protobuf:"bytes,5,opt,name=end" json:"end,omitempty"`
	// The anchor's spanning text within the anchor parent's text
	Text string `protobuf:"bytes,6,opt,name=text,proto3" json:"text,omitempty"`
	// User-readable snippet of the anchor parent's text at the location of this
	// anchor
	Snippet string `protobuf:"bytes,7,opt,name=snippet,proto3" json:"snippet,omitempty"`
	// Starting location of the anchor's snippet within its parent's text
	SnippetStart *Location_Point `protobuf:"bytes,8,opt,name=snippet_start,json=snippetStart" json:"snippet_start,omitempty"`
	// Ending location of the anchor's snippet within its parent's text
	SnippetEnd *Location_Point `protobuf:"bytes,9,opt,name=snippet_end,json=snippetEnd" json:"snippet_end,omitempty"`
}

func (m *Anchor) Reset()                    { *m = Anchor{} }
func (m *Anchor) String() string            { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()               {}
func (*Anchor) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{4} }

func (m *Anchor) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Anchor) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Anchor) GetSnippetStart() *Location_Point {
	if m != nil {
		return m.SnippetStart
	}
	return nil
}

func (m *Anchor) GetSnippetEnd() *Location_Point {
	if m != nil {
		return m.SnippetEnd
	}
	return nil
}

// TODO(zarko): Rename to something more appropriate.
type Link struct {
	// The kind of this span.
	Kind Link_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.Link_Kind" json:"kind,omitempty"`
	// Semantic tickets for DEFINITION links.
	Definition []string `protobuf:"bytes,3,rep,name=definition" json:"definition,omitempty"`
}

func (m *Link) Reset()                    { *m = Link{} }
func (m *Link) String() string            { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()               {}
func (*Link) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{5} }

type Printable struct {
	// Raw text that can be displayed to the user (but may also contain
	// markup that can be interpreted, like Doxygen comments). Links are
	// marked using []. \ is an escape character (where possible escape
	// sequences are \[, \], and \\).
	RawText string `protobuf:"bytes,1,opt,name=raw_text,json=rawText,proto3" json:"raw_text,omitempty"`
	// Annotations for spans in raw_text. The ith Link corresponds to the span
	// starting at the ith [. Spans may link to definitions; they may also
	// describe properties of the text (e.g., that parts should not be dropped
	// when summarizing).
	Link []*Link `protobuf:"bytes,2,rep,name=link" json:"link,omitempty"`
}

func (m *Printable) Reset()                    { *m = Printable{} }
func (m *Printable) String() string            { return proto.CompactTextString(m) }
func (*Printable) ProtoMessage()               {}
func (*Printable) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{6} }

func (m *Printable) GetLink() []*Link {
	if m != nil {
		return m.Link
	}
	return nil
}

type CrossReferencesReply struct {
	// Total number of cross-references on all pages matching requested filters.
	Total *CrossReferencesReply_Total `protobuf:"bytes,5,opt,name=total" json:"total,omitempty"`
	// Sets of cross-references for each requested node
	CrossReferences map[string]*CrossReferencesReply_CrossReferenceSet `protobuf:"bytes,1,rep,name=cross_references,json=crossReferences" json:"cross_references,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// The facts left from the requested filters of the related node facts
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Map from the definition tickets referred to in each NodeInfo to their
	// Anchor.  This map will only be returned if the
	// CrossReferencesRequest.node_definitions switch is true.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,3,rep,name=definition_locations,json=definitionLocations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// If there are additional pages of cross-references after the ones returned
	// in this reply, next_page_token is the page token that may be passed to
	// fetch the next page in sequence after this one.  If there are no additional
	// cross-references, this field will be empty.
	NextPageToken string `protobuf:"bytes,10,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *CrossReferencesReply) Reset()                    { *m = CrossReferencesReply{} }
func (m *CrossReferencesReply) String() string            { return proto.CompactTextString(m) }
func (*CrossReferencesReply) ProtoMessage()               {}
func (*CrossReferencesReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{7} }

func (m *CrossReferencesReply) GetTotal() *CrossReferencesReply_Total {
	if m != nil {
		return m.Total
	}
	return nil
}

func (m *CrossReferencesReply) GetCrossReferences() map[string]*CrossReferencesReply_CrossReferenceSet {
	if m != nil {
		return m.CrossReferences
	}
	return nil
}

func (m *CrossReferencesReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CrossReferencesReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

type CrossReferencesReply_RelatedNode struct {
	// Ticket of the node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the node's relation
	RelationKind string `protobuf:"bytes,2,opt,name=relation_kind,json=relationKind,proto3" json:"relation_kind,omitempty"`
	// Optional ordinal for edges of the same relation_kind.
	Ordinal int32 `protobuf:"varint,3,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *CrossReferencesReply_RelatedNode) Reset()         { *m = CrossReferencesReply_RelatedNode{} }
func (m *CrossReferencesReply_RelatedNode) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedNode) ProtoMessage()    {}
func (*CrossReferencesReply_RelatedNode) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{7, 0}
}

type CrossReferencesReply_RelatedAnchor struct {
	// The anchor covering the related object.
	Anchor *Anchor `protobuf:"bytes,1,opt,name=anchor" json:"anchor,omitempty"`
	// A name for the related object.
	DisplayName *Printable `protobuf:"bytes,2,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Specific locations, usually within the related object, that caused
	// the relationship to exist. This field is relevant to caller sets.
	Site []*Anchor `protobuf:"bytes,3,rep,name=site" json:"site,omitempty"`
	// The relevant semantic object. Populated for callers.
	Ticket string `protobuf:"bytes,4,opt,name=ticket,proto3" json:"ticket,omitempty"`
}

func (m *CrossReferencesReply_RelatedAnchor) Reset()         { *m = CrossReferencesReply_RelatedAnchor{} }
func (m *CrossReferencesReply_RelatedAnchor) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedAnchor) ProtoMessage()    {}
func (*CrossReferencesReply_RelatedAnchor) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{7, 1}
}

func (m *CrossReferencesReply_RelatedAnchor) GetAnchor() *Anchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *CrossReferencesReply_RelatedAnchor) GetDisplayName() *Printable {
	if m != nil {
		return m.DisplayName
	}
	return nil
}

func (m *CrossReferencesReply_RelatedAnchor) GetSite() []*Anchor {
	if m != nil {
		return m.Site
	}
	return nil
}

type CrossReferencesReply_CrossReferenceSet struct {
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// A name for the given node.
	DisplayName *Printable `protobuf:"bytes,7,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// The set of definitions for the given node.
	Definition []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,2,rep,name=definition" json:"definition,omitempty"`
	// The set of declarations for the given node.
	Declaration []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,5,rep,name=declaration" json:"declaration,omitempty"`
	// The set of simple references for the given node.
	Reference []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,3,rep,name=reference" json:"reference,omitempty"`
	// The set of documentation for the given node.
	Documentation []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,4,rep,name=documentation" json:"documentation,omitempty"`
	// The set of callers for the given node.
	Caller []*CrossReferencesReply_RelatedAnchor `protobuf:"bytes,6,rep,name=caller" json:"caller,omitempty"`
	// The set of related nodes to the given node.
	RelatedNode []*CrossReferencesReply_RelatedNode `protobuf:"bytes,10,rep,name=related_node,json=relatedNode" json:"related_node,omitempty"`
}

func (m *CrossReferencesReply_CrossReferenceSet) Reset() {
	*m = CrossReferencesReply_CrossReferenceSet{}
}
func (m *CrossReferencesReply_CrossReferenceSet) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_CrossReferenceSet) ProtoMessage()    {}
func (*CrossReferencesReply_CrossReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{7, 2}
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDisplayName() *Printable {
	if m != nil {
		return m.DisplayName
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDefinition() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDeclaration() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Declaration
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetReference() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDocumentation() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Documentation
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetCaller() []*CrossReferencesReply_RelatedAnchor {
	if m != nil {
		return m.Caller
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetRelatedNode() []*CrossReferencesReply_RelatedNode {
	if m != nil {
		return m.RelatedNode
	}
	return nil
}

type CrossReferencesReply_Total struct {
	Definitions            int64            `protobuf:"varint,1,opt,name=definitions,proto3" json:"definitions,omitempty"`
	Declarations           int64            `protobuf:"varint,2,opt,name=declarations,proto3" json:"declarations,omitempty"`
	References             int64            `protobuf:"varint,3,opt,name=references,proto3" json:"references,omitempty"`
	Documentation          int64            `protobuf:"varint,4,opt,name=documentation,proto3" json:"documentation,omitempty"`
	Callers                int64            `protobuf:"varint,5,opt,name=callers,proto3" json:"callers,omitempty"`
	RelatedNodesByRelation map[string]int64 `protobuf:"bytes,6,rep,name=related_nodes_by_relation,json=relatedNodesByRelation" json:"related_nodes_by_relation,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *CrossReferencesReply_Total) Reset()         { *m = CrossReferencesReply_Total{} }
func (m *CrossReferencesReply_Total) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_Total) ProtoMessage()    {}
func (*CrossReferencesReply_Total) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{7, 3}
}

func (m *CrossReferencesReply_Total) GetRelatedNodesByRelation() map[string]int64 {
	if m != nil {
		return m.RelatedNodesByRelation
	}
	return nil
}

type DocumentationRequest struct {
	// Semantic tickets about which documentation is sought.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned. The filter applies to ALL documented and linked nodes.
	// See EdgesRequest (graph.proto) for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
}

func (m *DocumentationRequest) Reset()                    { *m = DocumentationRequest{} }
func (m *DocumentationRequest) String() string            { return proto.CompactTextString(m) }
func (*DocumentationRequest) ProtoMessage()               {}
func (*DocumentationRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{8} }

type DocumentationReply struct {
	Document []*DocumentationReply_Document `protobuf:"bytes,1,rep,name=document" json:"document,omitempty"`
	// The facts left from the requested filters of the documented node facts.
	Nodes map[string]*kythe_proto_common.NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Map from the definition tickets referred to in each NodeInfo to their
	// Anchor.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,3,rep,name=definition_locations,json=definitionLocations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DocumentationReply) Reset()                    { *m = DocumentationReply{} }
func (m *DocumentationReply) String() string            { return proto.CompactTextString(m) }
func (*DocumentationReply) ProtoMessage()               {}
func (*DocumentationReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{9} }

func (m *DocumentationReply) GetDocument() []*DocumentationReply_Document {
	if m != nil {
		return m.Document
	}
	return nil
}

func (m *DocumentationReply) GetNodes() map[string]*kythe_proto_common.NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DocumentationReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

type DocumentationReply_Document struct {
	// The ticket to which this Document refers.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Documentation that can be displayed to the user.
	Text *Printable `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// A signature that can be displayed to the user. For variables, this
	// may just be the variable name; for functions, this may be some version
	// of the function prototype.
	Signature *Printable `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	// The type as a signature that can be displayed to the user.
	Type *Printable `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// The initialization value, if any.
	Initializer *Printable `protobuf:"bytes,5,opt,name=initializer" json:"initializer,omitempty"`
	// The semantic parent of this value.
	DefinedBy *Printable `protobuf:"bytes,6,opt,name=defined_by,json=definedBy" json:"defined_by,omitempty"`
}

func (m *DocumentationReply_Document) Reset()         { *m = DocumentationReply_Document{} }
func (m *DocumentationReply_Document) String() string { return proto.CompactTextString(m) }
func (*DocumentationReply_Document) ProtoMessage()    {}
func (*DocumentationReply_Document) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{9, 0}
}

func (m *DocumentationReply_Document) GetText() *Printable {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *DocumentationReply_Document) GetSignature() *Printable {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DocumentationReply_Document) GetType() *Printable {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DocumentationReply_Document) GetInitializer() *Printable {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *DocumentationReply_Document) GetDefinedBy() *Printable {
	if m != nil {
		return m.DefinedBy
	}
	return nil
}

func init() {
	proto.RegisterType((*Location)(nil), "kythe.proto.Location")
	proto.RegisterType((*Location_Point)(nil), "kythe.proto.Location.Point")
	proto.RegisterType((*DecorationsRequest)(nil), "kythe.proto.DecorationsRequest")
	proto.RegisterType((*DecorationsReply)(nil), "kythe.proto.DecorationsReply")
	proto.RegisterType((*DecorationsReply_Reference)(nil), "kythe.proto.DecorationsReply.Reference")
	proto.RegisterType((*DecorationsReply_Override)(nil), "kythe.proto.DecorationsReply.Override")
	proto.RegisterType((*DecorationsReply_Overrides)(nil), "kythe.proto.DecorationsReply.Overrides")
	proto.RegisterType((*CrossReferencesRequest)(nil), "kythe.proto.CrossReferencesRequest")
	proto.RegisterType((*Anchor)(nil), "kythe.proto.Anchor")
	proto.RegisterType((*Link)(nil), "kythe.proto.Link")
	proto.RegisterType((*Printable)(nil), "kythe.proto.Printable")
	proto.RegisterType((*CrossReferencesReply)(nil), "kythe.proto.CrossReferencesReply")
	proto.RegisterType((*CrossReferencesReply_RelatedNode)(nil), "kythe.proto.CrossReferencesReply.RelatedNode")
	proto.RegisterType((*CrossReferencesReply_RelatedAnchor)(nil), "kythe.proto.CrossReferencesReply.RelatedAnchor")
	proto.RegisterType((*CrossReferencesReply_CrossReferenceSet)(nil), "kythe.proto.CrossReferencesReply.CrossReferenceSet")
	proto.RegisterType((*CrossReferencesReply_Total)(nil), "kythe.proto.CrossReferencesReply.Total")
	proto.RegisterType((*DocumentationRequest)(nil), "kythe.proto.DocumentationRequest")
	proto.RegisterType((*DocumentationReply)(nil), "kythe.proto.DocumentationReply")
	proto.RegisterType((*DocumentationReply_Document)(nil), "kythe.proto.DocumentationReply.Document")
	proto.RegisterEnum("kythe.proto.Location_Kind", Location_Kind_name, Location_Kind_value)
	proto.RegisterEnum("kythe.proto.DecorationsRequest_SpanKind", DecorationsRequest_SpanKind_name, DecorationsRequest_SpanKind_value)
	proto.RegisterEnum("kythe.proto.DecorationsReply_Override_Kind", DecorationsReply_Override_Kind_name, DecorationsReply_Override_Kind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DefinitionKind", CrossReferencesRequest_DefinitionKind_name, CrossReferencesRequest_DefinitionKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DeclarationKind", CrossReferencesRequest_DeclarationKind_name, CrossReferencesRequest_DeclarationKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_ReferenceKind", CrossReferencesRequest_ReferenceKind_name, CrossReferencesRequest_ReferenceKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DocumentationKind", CrossReferencesRequest_DocumentationKind_name, CrossReferencesRequest_DocumentationKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_CallerKind", CrossReferencesRequest_CallerKind_name, CrossReferencesRequest_CallerKind_value)
	proto.RegisterEnum("kythe.proto.Link_Kind", Link_Kind_name, Link_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for XRefService service

type XRefServiceClient interface {
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error)
	// Documentation takes a set of tickets for semantic objects and returns
	// documentation about them, including generated signatures and
	// user-provided text. The documentation may refer to tickets for other
	// nodes in the graph.
	Documentation(ctx context.Context, in *DocumentationRequest, opts ...grpc.CallOption) (*DocumentationReply, error)
}

type xRefServiceClient struct {
	cc *grpc.ClientConn
}

func NewXRefServiceClient(cc *grpc.ClientConn) XRefServiceClient {
	return &xRefServiceClient{cc}
}

func (c *xRefServiceClient) Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error) {
	out := new(DecorationsReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Decorations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error) {
	out := new(CrossReferencesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/CrossReferences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Documentation(ctx context.Context, in *DocumentationRequest, opts ...grpc.CallOption) (*DocumentationReply, error) {
	out := new(DocumentationReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Documentation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XRefService service

type XRefServiceServer interface {
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(context.Context, *DecorationsRequest) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(context.Context, *CrossReferencesRequest) (*CrossReferencesReply, error)
	// Documentation takes a set of tickets for semantic objects and returns
	// documentation about them, including generated signatures and
	// user-provided text. The documentation may refer to tickets for other
	// nodes in the graph.
	Documentation(context.Context, *DocumentationRequest) (*DocumentationReply, error)
}

func RegisterXRefServiceServer(s *grpc.Server, srv XRefServiceServer) {
	s.RegisterService(&_XRefService_serviceDesc, srv)
}

func _XRefService_Decorations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecorationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Decorations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Decorations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Decorations(ctx, req.(*DecorationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_CrossReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CrossReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).CrossReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/CrossReferences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).CrossReferences(ctx, req.(*CrossReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Documentation(ctx, req.(*DocumentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _XRefService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.XRefService",
	HandlerType: (*XRefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Decorations",
			Handler:    _XRefService_Decorations_Handler,
		},
		{
			MethodName: "CrossReferences",
			Handler:    _XRefService_CrossReferences_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _XRefService_Documentation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *Location) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Location) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Kind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if m.Start != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(m.Start.Size()))
		n1, err := m.Start.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.End != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.End.Size()))
		n2, err := m.End.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Location_Point) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Location_Point) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ByteOffset != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintXref(data, i, uint64(m.ByteOffset))
	}
	if m.LineNumber != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.ColumnOffset))
	}
	return i, nil
}

func (m *DecorationsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Location.Size()))
		n3, err := m.Location.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.DirtyBuffer) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.DirtyBuffer)))
		i += copy(data[i:], m.DirtyBuffer)
	}
	if m.SourceText {
		data[i] = 0x18
		i++
		if m.SourceText {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.References {
		data[i] = 0x20
		i++
		if m.References {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.TargetDefinitions {
		data[i] = 0x30
		i++
		if m.TargetDefinitions {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ExtendsOverrides {
		data[i] = 0x38
		i++
		if m.ExtendsOverrides {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SpanKind != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintXref(data, i, uint64(m.SpanKind))
	}
	return i, nil
}

func (m *DecorationsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Location.Size()))
		n4, err := m.Location.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.SourceText) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SourceText)))
		i += copy(data[i:], m.SourceText)
	}
	if len(m.Encoding) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Encoding)))
		i += copy(data[i:], m.Encoding)
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			data[i] = 0x22
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x7a
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n5, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n5
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			data[i] = 0x82
			i++
			data[i] = 0x1
			i++
			v := m.DefinitionLocations[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n6, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n6
		}
	}
	if len(m.ExtendsOverrides) > 0 {
		for k, _ := range m.ExtendsOverrides {
			data[i] = 0x8a
			i++
			data[i] = 0x1
			i++
			v := m.ExtendsOverrides[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n7, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n7
		}
	}
	return i, nil
}

func (m *DecorationsReply_Reference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply_Reference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTicket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if len(m.TargetTicket) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.TargetTicket)))
		i += copy(data[i:], m.TargetTicket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.TargetDefinition) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(len(m.TargetDefinition)))
		i += copy(data[i:], m.TargetDefinition)
	}
	if m.AnchorStart != nil {
		data[i] = 0x52
		i++
		i = encodeVarintXref(data, i, uint64(m.AnchorStart.Size()))
		n8, err := m.AnchorStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.AnchorEnd != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintXref(data, i, uint64(m.AnchorEnd.Size()))
		n9, err := m.AnchorEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DecorationsReply_Override) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply_Override) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Kind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if m.DisplayName != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(m.DisplayName.Size()))
		n10, err := m.DisplayName.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *DecorationsReply_Overrides) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply_Overrides) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Override) > 0 {
		for _, msg := range m.Override {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CrossReferencesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.DefinitionKind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.ReferenceKind))
	}
	if m.DocumentationKind != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintXref(data, i, uint64(m.DocumentationKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.AnchorText {
		data[i] = 0x30
		i++
		if m.AnchorText {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.DeclarationKind != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintXref(data, i, uint64(m.DeclarationKind))
	}
	if m.NodeDefinitions {
		data[i] = 0x40
		i++
		if m.NodeDefinitions {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.PageSize != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintXref(data, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.PageToken)))
		i += copy(data[i:], m.PageToken)
	}
	if m.CallerKind != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintXref(data, i, uint64(m.CallerKind))
	}
	if m.ExperimentalSignatures {
		data[i] = 0xa0
		i++
		data[i] = 0x6
		i++
		if m.ExperimentalSignatures {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Anchor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Anchor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Parent) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Parent)))
		i += copy(data[i:], m.Parent)
	}
	if m.Start != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.Start.Size()))
		n11, err := m.Start.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.End != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(m.End.Size()))
		n12, err := m.End.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Text) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Text)))
		i += copy(data[i:], m.Text)
	}
	if len(m.Snippet) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Snippet)))
		i += copy(data[i:], m.Snippet)
	}
	if m.SnippetStart != nil {
		data[i] = 0x42
		i++
		i = encodeVarintXref(data, i, uint64(m.SnippetStart.Size()))
		n13, err := m.SnippetStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.SnippetEnd != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(m.SnippetEnd.Size()))
		n14, err := m.SnippetEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *Link) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Link) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if len(m.Definition) > 0 {
		for _, s := range m.Definition {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Printable) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Printable) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RawText) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.RawText)))
		i += copy(data[i:], m.RawText)
	}
	if len(m.Link) > 0 {
		for _, msg := range m.Link {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CrossReferencesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, _ := range m.CrossReferences {
			data[i] = 0xa
			i++
			v := m.CrossReferences[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n15, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n15
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x12
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n16, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n16
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			data[i] = 0x1a
			i++
			v := m.DefinitionLocations[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n17, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n17
		}
	}
	if m.Total != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(m.Total.Size()))
		n18, err := m.Total.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.NextPageToken) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintXref(data, i, uint64(len(m.NextPageToken)))
		i += copy(data[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CrossReferencesReply_RelatedNode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_RelatedNode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.RelationKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.RelationKind)))
		i += copy(data[i:], m.RelationKind)
	}
	if m.Ordinal != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *CrossReferencesReply_RelatedAnchor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_RelatedAnchor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Anchor.Size()))
		n19, err := m.Anchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.DisplayName != nil {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(m.DisplayName.Size()))
		n20, err := m.DisplayName.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Site) > 0 {
		for _, msg := range m.Site {
			data[i] = 0x1a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ticket) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	return i, nil
}

func (m *CrossReferencesReply_CrossReferenceSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_CrossReferenceSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Definition) > 0 {
		for _, msg := range m.Definition {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			data[i] = 0x1a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Documentation) > 0 {
		for _, msg := range m.Documentation {
			data[i] = 0x22
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Declaration) > 0 {
		for _, msg := range m.Declaration {
			data[i] = 0x2a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Caller) > 0 {
		for _, msg := range m.Caller {
			data[i] = 0x32
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DisplayName != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintXref(data, i, uint64(m.DisplayName.Size()))
		n21, err := m.DisplayName.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.RelatedNode) > 0 {
		for _, msg := range m.RelatedNode {
			data[i] = 0x52
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CrossReferencesReply_Total) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_Total) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Definitions != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintXref(data, i, uint64(m.Definitions))
	}
	if m.Declarations != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Declarations))
	}
	if m.References != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.References))
	}
	if m.Documentation != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintXref(data, i, uint64(m.Documentation))
	}
	if m.Callers != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintXref(data, i, uint64(m.Callers))
	}
	if len(m.RelatedNodesByRelation) > 0 {
		for k, _ := range m.RelatedNodesByRelation {
			data[i] = 0x32
			i++
			v := m.RelatedNodesByRelation[k]
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + sovXref(uint64(v))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintXref(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DocumentationRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DocumentationReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, msg := range m.Document {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x12
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n22, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n22
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			data[i] = 0x1a
			i++
			v := m.DefinitionLocations[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n23, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n23
		}
	}
	return i, nil
}

func (m *DocumentationReply_Document) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationReply_Document) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Text != nil {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(m.Text.Size()))
		n24, err := m.Text.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Signature != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(m.Signature.Size()))
		n25, err := m.Signature.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Type != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.Type.Size()))
		n26, err := m.Type.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Initializer != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(m.Initializer.Size()))
		n27, err := m.Initializer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.DefinedBy != nil {
		data[i] = 0x32
		i++
		i = encodeVarintXref(data, i, uint64(m.DefinedBy.Size()))
		n28, err := m.DefinedBy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func encodeFixed64Xref(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Xref(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintXref(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Location_Point) Size() (n int) {
	var l int
	_ = l
	if m.ByteOffset != 0 {
		n += 1 + sovXref(uint64(m.ByteOffset))
	}
	if m.LineNumber != 0 {
		n += 1 + sovXref(uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		n += 1 + sovXref(uint64(m.ColumnOffset))
	}
	return n
}

func (m *DecorationsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.DirtyBuffer)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SourceText {
		n += 2
	}
	if m.References {
		n += 2
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.TargetDefinitions {
		n += 2
	}
	if m.ExtendsOverrides {
		n += 2
	}
	if m.SpanKind != 0 {
		n += 1 + sovXref(uint64(m.SpanKind))
	}
	return n
}

func (m *DecorationsReply) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SourceText)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 2 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.ExtendsOverrides) > 0 {
		for k, v := range m.ExtendsOverrides {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 2 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DecorationsReply_Reference) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetDefinition)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.AnchorStart != nil {
		l = m.AnchorStart.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.AnchorEnd != nil {
		l = m.AnchorEnd.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *DecorationsReply_Override) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if m.DisplayName != nil {
		l = m.DisplayName.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *DecorationsReply_Overrides) Size() (n int) {
	var l int
	_ = l
	if len(m.Override) > 0 {
		for _, e := range m.Override {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CrossReferencesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.DefinitionKind != 0 {
		n += 1 + sovXref(uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		n += 1 + sovXref(uint64(m.ReferenceKind))
	}
	if m.DocumentationKind != 0 {
		n += 1 + sovXref(uint64(m.DocumentationKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.AnchorText {
		n += 2
	}
	if m.DeclarationKind != 0 {
		n += 1 + sovXref(uint64(m.DeclarationKind))
	}
	if m.NodeDefinitions {
		n += 2
	}
	if m.PageSize != 0 {
		n += 1 + sovXref(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.CallerKind != 0 {
		n += 1 + sovXref(uint64(m.CallerKind))
	}
	if m.ExperimentalSignatures {
		n += 3
	}
	return n
}

func (m *Anchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Snippet)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetStart != nil {
		l = m.SnippetStart.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetEnd != nil {
		l = m.SnippetEnd.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Link) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if len(m.Definition) > 0 {
		for _, s := range m.Definition {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *Printable) Size() (n int) {
	var l int
	_ = l
	l = len(m.RawText)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Link) > 0 {
		for _, e := range m.Link {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CrossReferencesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, v := range m.CrossReferences {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_RelatedNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.RelationKind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovXref(uint64(m.Ordinal))
	}
	return n
}

func (m *CrossReferencesReply_RelatedAnchor) Size() (n int) {
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.DisplayName != nil {
		l = m.DisplayName.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_CrossReferenceSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Definition) > 0 {
		for _, e := range m.Definition {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Documentation) > 0 {
		for _, e := range m.Documentation {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Declaration) > 0 {
		for _, e := range m.Declaration {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Caller) > 0 {
		for _, e := range m.Caller {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.DisplayName != nil {
		l = m.DisplayName.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.RelatedNode) > 0 {
		for _, e := range m.RelatedNode {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CrossReferencesReply_Total) Size() (n int) {
	var l int
	_ = l
	if m.Definitions != 0 {
		n += 1 + sovXref(uint64(m.Definitions))
	}
	if m.Declarations != 0 {
		n += 1 + sovXref(uint64(m.Declarations))
	}
	if m.References != 0 {
		n += 1 + sovXref(uint64(m.References))
	}
	if m.Documentation != 0 {
		n += 1 + sovXref(uint64(m.Documentation))
	}
	if m.Callers != 0 {
		n += 1 + sovXref(uint64(m.Callers))
	}
	if len(m.RelatedNodesByRelation) > 0 {
		for k, v := range m.RelatedNodesByRelation {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + sovXref(uint64(v))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DocumentationRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DocumentationReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DocumentationReply_Document) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Initializer != nil {
		l = m.Initializer.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.DefinedBy != nil {
		l = m.DefinedBy.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func sovXref(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozXref(x uint64) (n int) {
	return sovXref(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Location) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (Location_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Location_Point{}
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Location_Point{}
			}
			if err := m.End.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location_Point) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOffset", wireType)
			}
			m.ByteOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineNumber", wireType)
			}
			m.LineNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LineNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOffset", wireType)
			}
			m.ColumnOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ColumnOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyBuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirtyBuffer = append(m.DirtyBuffer[:0], data[iNdEx:postIndex]...)
			if m.DirtyBuffer == nil {
				m.DirtyBuffer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceText = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.References = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinitions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetDefinitions = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendsOverrides", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtendsOverrides = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanKind", wireType)
			}
			m.SpanKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SpanKind |= (DecorationsRequest_SpanKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceText = append(m.SourceText[:0], data[iNdEx:postIndex]...)
			if m.SourceText == nil {
				m.SourceText = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &DecorationsReply_Reference{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &kythe_proto_common.NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Anchor{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			m.DefinitionLocations[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendsOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &DecorationsReply_Overrides{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.ExtendsOverrides == nil {
				m.ExtendsOverrides = make(map[string]*DecorationsReply_Overrides)
			}
			m.ExtendsOverrides[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Reference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetDefinition = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorStart == nil {
				m.AnchorStart = &Location_Point{}
			}
			if err := m.AnchorStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorEnd == nil {
				m.AnchorEnd = &Location_Point{}
			}
			if err := m.AnchorEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Override) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Override: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Override: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (DecorationsReply_Override_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisplayName == nil {
				m.DisplayName = &Printable{}
			}
			if err := m.DisplayName.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Overrides) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Overrides: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Overrides: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Override = append(m.Override, &DecorationsReply_Override{})
			if err := m.Override[len(m.Override)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionKind", wireType)
			}
			m.DefinitionKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DefinitionKind |= (CrossReferencesRequest_DefinitionKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceKind", wireType)
			}
			m.ReferenceKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReferenceKind |= (CrossReferencesRequest_ReferenceKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationKind", wireType)
			}
			m.DocumentationKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DocumentationKind |= (CrossReferencesRequest_DocumentationKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AnchorText = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclarationKind", wireType)
			}
			m.DeclarationKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DeclarationKind |= (CrossReferencesRequest_DeclarationKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDefinitions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeDefinitions = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerKind", wireType)
			}
			m.CallerKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CallerKind |= (CrossReferencesRequest_CallerKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalSignatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExperimentalSignatures = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Anchor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Anchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Anchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Location_Point{}
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Location_Point{}
			}
			if err := m.End.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snippet = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetStart == nil {
				m.SnippetStart = &Location_Point{}
			}
			if err := m.SnippetStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetEnd == nil {
				m.SnippetEnd = &Location_Point{}
			}
			if err := m.SnippetEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (Link_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Printable) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Printable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Printable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawText = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = append(m.Link, &Link{})
			if err := m.Link[len(m.Link)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &CrossReferencesReply_CrossReferenceSet{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.CrossReferences == nil {
				m.CrossReferences = make(map[string]*CrossReferencesReply_CrossReferenceSet)
			}
			m.CrossReferences[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &kythe_proto_common.NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Anchor{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			m.DefinitionLocations[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &CrossReferencesReply_Total{}
			}
			if err := m.Total.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_RelatedNode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_RelatedAnchor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedAnchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedAnchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &Anchor{}
			}
			if err := m.Anchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisplayName == nil {
				m.DisplayName = &Printable{}
			}
			if err := m.DisplayName.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &Anchor{})
			if err := m.Site[len(m.Site)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_CrossReferenceSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferenceSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferenceSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Definition[len(m.Definition)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documentation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Documentation = append(m.Documentation, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Documentation[len(m.Documentation)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Declaration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Declaration = append(m.Declaration, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Declaration[len(m.Declaration)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = append(m.Caller, &CrossReferencesReply_RelatedAnchor{})
			if err := m.Caller[len(m.Caller)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisplayName == nil {
				m.DisplayName = &Printable{}
			}
			if err := m.DisplayName.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedNode = append(m.RelatedNode, &CrossReferencesReply_RelatedNode{})
			if err := m.RelatedNode[len(m.RelatedNode)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_Total) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Total: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Total: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			m.Definitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Definitions |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Declarations", wireType)
			}
			m.Declarations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Declarations |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			m.References = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.References |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documentation", wireType)
			}
			m.Documentation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Documentation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callers", wireType)
			}
			m.Callers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Callers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNodesByRelation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.RelatedNodesByRelation == nil {
				m.RelatedNodesByRelation = make(map[string]int64)
			}
			m.RelatedNodesByRelation[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &DocumentationReply_Document{})
			if err := m.Document[len(m.Document)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &kythe_proto_common.NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*kythe_proto_common.NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Anchor{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			m.DefinitionLocations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply_Document) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &Printable{}
			}
			if err := m.Text.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &Printable{}
			}
			if err := m.Signature.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Printable{}
			}
			if err := m.Type.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializer == nil {
				m.Initializer = &Printable{}
			}
			if err := m.Initializer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinedBy == nil {
				m.DefinedBy = &Printable{}
			}
			if err := m.DefinedBy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipXref(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowXref
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthXref
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowXref
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipXref(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthXref = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowXref   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorXref = []byte{
	// 2107 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x18, 0x4b, 0x6f, 0xdb, 0xc8,
	0xd9, 0xd4, 0xc3, 0xa6, 0x3e, 0x59, 0x12, 0x35, 0x71, 0xbc, 0x5a, 0xa5, 0xeb, 0x38, 0x4c, 0xbb,
	0xf1, 0x26, 0x1b, 0x07, 0x71, 0xba, 0x6d, 0x1a, 0xec, 0x23, 0x7e, 0xc8, 0x5b, 0x6d, 0x1d, 0xca,
	0x1d, 0x29, 0xdb, 0x00, 0x01, 0xca, 0xd2, 0xe2, 0x28, 0x21, 0x4c, 0x93, 0x2a, 0x49, 0x27, 0x56,
	0x0e, 0xfd, 0x11, 0x8b, 0x1e, 0xda, 0x7b, 0x81, 0x1e, 0xfa, 0x07, 0x7a, 0x2c, 0x7a, 0x2a, 0xd0,
	0x4b, 0x7f, 0x40, 0x0f, 0x45, 0x7a, 0x68, 0x6f, 0xbd, 0xf6, 0xb8, 0x98, 0x07, 0xa9, 0xa1, 0xde,
	0xce, 0x6d, 0x6f, 0x9c, 0x6f, 0xbe, 0xd7, 0x7c, 0xef, 0x8f, 0xb0, 0x7e, 0x3a, 0x88, 0x5e, 0x92,
	0x7b, 0xfd, 0xc0, 0x8f, 0xfc, 0x7b, 0x17, 0x01, 0xe9, 0x6d, 0xb3, 0x4f, 0x54, 0x64, 0x70, 0x7e,
	0xa8, 0xd7, 0x64, 0xa4, 0xae, 0x7f, 0x76, 0xe6, 0x7b, 0xfc, 0x46, 0xff, 0x4b, 0x06, 0xd4, 0x23,
	0xbf, 0x6b, 0x45, 0x8e, 0xef, 0xa1, 0x75, 0x58, 0x8e, 0x9c, 0xee, 0x29, 0x89, 0x6a, 0xca, 0xa6,
	0xb2, 0x55, 0xc0, 0xe2, 0x84, 0xb6, 0x21, 0x77, 0xea, 0x78, 0x76, 0x2d, 0xb3, 0xa9, 0x6c, 0x95,
	0x77, 0xea, 0xdb, 0x12, 0xeb, 0xed, 0x98, 0x78, 0xfb, 0x67, 0x8e, 0x67, 0x63, 0x86, 0x87, 0xee,
	0x43, 0x3e, 0x8c, 0xac, 0x20, 0xaa, 0x65, 0x37, 0x95, 0xad, 0xe2, 0xce, 0xb5, 0xc9, 0x04, 0xc7,
	0xbe, 0xe3, 0x45, 0x98, 0x63, 0xa2, 0xbb, 0x90, 0x25, 0x9e, 0x5d, 0xcb, 0xcd, 0x27, 0xa0, 0x78,
	0x75, 0x0f, 0xf2, 0xec, 0x84, 0xae, 0x43, 0xf1, 0x64, 0x10, 0x11, 0xd3, 0xef, 0xf5, 0x42, 0xa1,
	0x77, 0x1e, 0x03, 0x05, 0xb5, 0x18, 0x84, 0x22, 0xb8, 0x8e, 0x47, 0x4c, 0xef, 0xfc, 0xec, 0x84,
	0x04, 0xec, 0x09, 0x79, 0x0c, 0x14, 0x64, 0x30, 0x08, 0xba, 0x09, 0xa5, 0xae, 0xef, 0x9e, 0x9f,
	0x79, 0x31, 0x8f, 0x2c, 0x43, 0x59, 0xe5, 0x40, 0xce, 0x45, 0xaf, 0x43, 0x8e, 0xbe, 0x0f, 0xa9,
	0x90, 0x3b, 0x6c, 0x1e, 0x35, 0xb4, 0x25, 0xfa, 0xd5, 0x3e, 0xde, 0x35, 0x34, 0x45, 0xff, 0x6d,
	0x16, 0xd0, 0x01, 0xe9, 0xfa, 0x01, 0xd3, 0x32, 0xc4, 0xe4, 0xd7, 0xe7, 0x24, 0x8c, 0xd0, 0x7d,
	0x50, 0x5d, 0xa1, 0x39, 0x53, 0xab, 0xb8, 0x73, 0x75, 0xe2, 0xb3, 0x70, 0x82, 0x86, 0x6e, 0xc0,
	0xaa, 0xed, 0x04, 0xd1, 0xc0, 0x3c, 0x39, 0xef, 0xf5, 0x84, 0xb2, 0xab, 0xb8, 0xc8, 0x60, 0x7b,
	0x0c, 0x44, 0x9f, 0x13, 0xfa, 0xe7, 0x41, 0x97, 0x98, 0x11, 0xb9, 0xe0, 0xba, 0xaa, 0x18, 0x38,
	0xa8, 0x43, 0x2e, 0x22, 0xb4, 0x01, 0x10, 0x90, 0x1e, 0x09, 0x88, 0xd7, 0x25, 0x21, 0xb3, 0xa7,
	0x8a, 0x25, 0x08, 0xf5, 0x71, 0xcf, 0x71, 0x23, 0x12, 0xd4, 0xf2, 0x9b, 0x59, 0xea, 0x63, 0x7e,
	0x42, 0x77, 0x01, 0x45, 0x56, 0xf0, 0x82, 0x44, 0xa6, 0x4d, 0x7a, 0x8e, 0xe7, 0xb0, 0xb7, 0xd4,
	0x96, 0x19, 0x7d, 0x95, 0xdf, 0x1c, 0x0c, 0x2f, 0xd0, 0x1d, 0xa8, 0x92, 0x8b, 0x88, 0x78, 0x76,
	0x68, 0xfa, 0xaf, 0x48, 0x10, 0x38, 0x36, 0x09, 0x6b, 0x2b, 0x0c, 0x5b, 0x13, 0x17, 0xad, 0x18,
	0x8e, 0x1a, 0x50, 0x08, 0xfb, 0x96, 0x67, 0xb2, 0x20, 0x02, 0x16, 0x44, 0x5b, 0x29, 0x5b, 0x8c,
	0x9b, 0x6f, 0xbb, 0xdd, 0xb7, 0x3c, 0x16, 0x52, 0x6a, 0x28, 0xbe, 0xf4, 0x8f, 0x41, 0x8d, 0xa1,
	0xa8, 0x02, 0xc5, 0x5f, 0x34, 0x3b, 0x3f, 0x6d, 0x1a, 0x26, 0xf3, 0xc2, 0x12, 0x05, 0xec, 0xe2,
	0xd6, 0x53, 0xe3, 0xc0, 0x14, 0x6e, 0xf9, 0x03, 0x80, 0x96, 0xe2, 0xdb, 0x77, 0x07, 0xef, 0xe2,
	0x94, 0x11, 0x8b, 0x73, 0x9f, 0xc8, 0x16, 0xaf, 0x83, 0x4a, 0xbc, 0xae, 0x6f, 0x3b, 0xde, 0x0b,
	0xe6, 0x8f, 0x02, 0x4e, 0xce, 0xf4, 0xe5, 0x89, 0xed, 0x6b, 0xb9, 0xcd, 0xec, 0x56, 0x71, 0xe7,
	0xd6, 0xf4, 0x97, 0xf7, 0xdd, 0xc1, 0x36, 0x8e, 0xd1, 0xf1, 0x90, 0x12, 0x7d, 0x0e, 0x79, 0xcf,
	0xa7, 0x16, 0xae, 0x30, 0x16, 0x5b, 0xb3, 0x59, 0x18, 0x14, 0xb5, 0xe1, 0x45, 0xc1, 0x00, 0x73,
	0x32, 0xe4, 0xc0, 0xda, 0xd0, 0xab, 0x66, 0xfc, 0xb4, 0xb0, 0xa6, 0x31, 0x76, 0x3f, 0x9a, 0xcd,
	0x6e, 0xe8, 0xf6, 0xd8, 0x3a, 0x82, 0xf9, 0x15, 0x7b, 0xfc, 0x06, 0xfd, 0x6a, 0x52, 0x60, 0x54,
	0x99, 0x9c, 0x07, 0xb3, 0xe5, 0x34, 0x46, 0xc2, 0x86, 0x0b, 0x19, 0x8b, 0xa6, 0xfa, 0x37, 0x19,
	0x28, 0x24, 0x56, 0xa2, 0xe9, 0x1b, 0xbb, 0x47, 0x2e, 0x5d, 0xab, 0xc2, 0x41, 0xbc, 0x80, 0xdd,
	0x84, 0x92, 0x08, 0x6e, 0x81, 0x94, 0xe1, 0x48, 0x1c, 0x28, 0x90, 0x90, 0xa8, 0x72, 0xdc, 0x87,
	0xbc, 0x92, 0xdd, 0x81, 0xea, 0x58, 0x56, 0xb0, 0xa4, 0x2a, 0x60, 0x6d, 0x34, 0x29, 0xd0, 0xe7,
	0xb0, 0x6a, 0x79, 0xdd, 0x97, 0x7e, 0x60, 0xf2, 0xea, 0x07, 0xf3, 0x8b, 0x59, 0x91, 0x13, 0xb4,
	0x59, 0x0d, 0x7c, 0x04, 0x20, 0xe8, 0x69, 0x29, 0x2c, 0xce, 0xa7, 0x2e, 0x70, 0xf4, 0x86, 0x67,
	0xd7, 0xff, 0xaa, 0x80, 0x1a, 0x9b, 0x68, 0x6a, 0x1d, 0xff, 0x22, 0x55, 0xc7, 0xef, 0xcc, 0x76,
	0x47, 0xcc, 0x4d, 0x2e, 0xec, 0x3f, 0xa1, 0x05, 0x2a, 0xec, 0xbb, 0xd6, 0xc0, 0xf4, 0xac, 0x33,
	0x22, 0xea, 0xfb, 0x7a, 0x8a, 0xd1, 0x71, 0xe0, 0x78, 0x91, 0x75, 0xe2, 0x12, 0x5a, 0xb8, 0x18,
	0xae, 0x61, 0x9d, 0x11, 0x5d, 0x17, 0x15, 0xb4, 0x04, 0x85, 0xd6, 0xd7, 0x0d, 0x8c, 0x9b, 0x07,
	0x8d, 0xb6, 0xb6, 0x84, 0x8a, 0xb0, 0xd2, 0x78, 0xd6, 0x69, 0x18, 0x07, 0x6d, 0x4d, 0xa9, 0xb7,
	0xa0, 0x30, 0x2c, 0x1a, 0x7b, 0xa0, 0xc6, 0x01, 0x54, 0x53, 0x58, 0xfc, 0x7c, 0xb8, 0x98, 0xc2,
	0x38, 0xa1, 0xab, 0x7f, 0x0d, 0x30, 0x4c, 0x06, 0xa4, 0x41, 0xf6, 0x94, 0x0c, 0x84, 0x4d, 0xe8,
	0x27, 0xda, 0x81, 0xfc, 0x2b, 0xcb, 0x3d, 0x27, 0xcc, 0x22, 0xc5, 0x9d, 0xef, 0xa5, 0x04, 0x88,
	0x3e, 0x49, 0x19, 0x34, 0xbd, 0x9e, 0x8f, 0x39, 0xea, 0xa3, 0xcc, 0x43, 0xa5, 0xfe, 0x1c, 0x6a,
	0xd3, 0xb2, 0x62, 0x82, 0x94, 0x8f, 0xd2, 0x52, 0xae, 0xa4, 0xa4, 0xec, 0x32, 0x17, 0xca, 0xcc,
	0x5d, 0xb8, 0x3a, 0x31, 0x15, 0x26, 0x70, 0xfe, 0x2c, 0xcd, 0xf9, 0xd6, 0x62, 0x06, 0x0a, 0x25,
	0x69, 0xfa, 0xff, 0x54, 0x58, 0xdf, 0x0f, 0xfc, 0x30, 0x4c, 0x52, 0x2a, 0xe9, 0x60, 0x72, 0x18,
	0x65, 0xa5, 0x30, 0x7a, 0x0e, 0x15, 0xa9, 0x9a, 0x48, 0x11, 0xb5, 0x93, 0x92, 0x3f, 0x99, 0xab,
	0x54, 0x4e, 0x58, 0x60, 0x95, 0xed, 0xd4, 0x19, 0x3d, 0x83, 0x72, 0x52, 0xf7, 0xcc, 0x24, 0x1f,
	0xcb, 0x3b, 0xf7, 0x17, 0xe1, 0x9d, 0x40, 0x18, 0xeb, 0x52, 0x20, 0x1f, 0x91, 0x0d, 0xc8, 0xf6,
	0xbb, 0xe7, 0x67, 0xc4, 0x8b, 0xac, 0xa1, 0xe6, 0x39, 0xc6, 0xfd, 0x93, 0x85, 0x34, 0x97, 0xa9,
	0x99, 0x84, 0xaa, 0x3d, 0x0a, 0x9a, 0xda, 0x5f, 0xaf, 0x83, 0xc8, 0x75, 0xde, 0x46, 0x78, 0x63,
	0x15, 0xf9, 0xce, 0xda, 0xc8, 0x2f, 0x41, 0xb3, 0x49, 0xd7, 0xb5, 0x02, 0x49, 0xb9, 0x15, 0xa6,
	0xdc, 0x83, 0xc5, 0xcc, 0x9a, 0xd0, 0x32, 0xd5, 0x2a, 0x76, 0x1a, 0x80, 0x3e, 0x02, 0x8d, 0x36,
	0x83, 0x54, 0x7b, 0x57, 0x99, 0x16, 0x15, 0x0a, 0x97, 0x9b, 0xfb, 0x35, 0x28, 0xf4, 0xad, 0x17,
	0xc4, 0x0c, 0x9d, 0x37, 0x84, 0x55, 0xb1, 0x3c, 0x56, 0x29, 0xa0, 0xed, 0xbc, 0x21, 0xe8, 0x03,
	0x00, 0x76, 0x19, 0xf9, 0xa7, 0xc4, 0x63, 0x55, 0xaa, 0x80, 0x19, 0x7a, 0x87, 0x02, 0x50, 0x0b,
	0x8a, 0x5d, 0xcb, 0x75, 0x49, 0xc0, 0x5f, 0xb0, 0xca, 0x5e, 0xb0, 0xbd, 0xc8, 0x0b, 0xf6, 0x19,
	0x19, 0x53, 0x1e, 0xba, 0xc9, 0x37, 0xfa, 0x31, 0xbc, 0x47, 0x2e, 0xfa, 0x24, 0x70, 0x98, 0x9d,
	0x5d, 0x33, 0x74, 0x5e, 0x78, 0x56, 0x74, 0x1e, 0x90, 0xb0, 0x66, 0x33, 0xf5, 0xd7, 0xe5, 0xeb,
	0x76, 0x72, 0xab, 0xbf, 0x84, 0x72, 0x3a, 0xd6, 0x10, 0x82, 0xb2, 0xd1, 0x32, 0x0f, 0x1a, 0x87,
	0x4d, 0xa3, 0xd9, 0x69, 0xb6, 0x0c, 0x5a, 0x80, 0xae, 0x40, 0x65, 0xf7, 0xe8, 0x28, 0x05, 0x54,
	0xd0, 0x1a, 0x68, 0x87, 0x4f, 0x47, 0xa0, 0x19, 0xf4, 0x1e, 0x5c, 0xd9, 0x6b, 0x1a, 0x07, 0x4d,
	0xe3, 0xcb, 0xd4, 0x45, 0x56, 0xff, 0x14, 0x2a, 0x23, 0xe6, 0xa7, 0x6c, 0x99, 0xa8, 0xfd, 0xa3,
	0x5d, 0xbc, 0x1b, 0xcb, 0x5a, 0x03, 0x8d, 0xcb, 0x92, 0xa0, 0x8a, 0x6e, 0x43, 0x29, 0x15, 0xb7,
	0xa8, 0x0a, 0x25, 0xa3, 0x65, 0xe2, 0xc6, 0x61, 0x03, 0x37, 0x8c, 0xfd, 0x86, 0xd0, 0x72, 0x9f,
	0x92, 0x4a, 0x40, 0x85, 0xea, 0x63, 0xb4, 0x0c, 0x73, 0xf4, 0x22, 0x43, 0xdf, 0x39, 0x02, 0xcb,
	0xea, 0x8f, 0xa1, 0x3a, 0x16, 0xbf, 0x54, 0x21, 0xaa, 0x65, 0x6b, 0xff, 0xe9, 0x93, 0x86, 0xd1,
	0x61, 0x1a, 0x69, 0x4b, 0xe8, 0x2a, 0x54, 0x99, 0x9a, 0x29, 0xb0, 0xa2, 0x1f, 0x02, 0x0c, 0x5d,
	0x84, 0xca, 0x00, 0x46, 0x8b, 0xc9, 0x6e, 0x60, 0xaa, 0x21, 0x82, 0xf2, 0x41, 0x13, 0x37, 0xf6,
	0x3b, 0x09, 0x8c, 0x99, 0x31, 0xae, 0xf5, 0x09, 0x34, 0xa3, 0xff, 0x33, 0x03, 0xcb, 0xbc, 0xea,
	0x4d, 0x6d, 0x54, 0x48, 0x6a, 0x54, 0x71, 0x2b, 0x5e, 0x87, 0xe5, 0xbe, 0x15, 0x10, 0x2f, 0x12,
	0x0d, 0x5a, 0x9c, 0x86, 0xcb, 0x46, 0xee, 0xb2, 0xcb, 0x46, 0x7e, 0xb1, 0x65, 0x83, 0x6a, 0x93,
	0xe4, 0x6c, 0x01, 0xb3, 0x6f, 0x54, 0x83, 0x95, 0xd0, 0x73, 0xfa, 0x7d, 0x12, 0xb1, 0x24, 0x2d,
	0xe0, 0xf8, 0x88, 0x1e, 0x43, 0x49, 0x7c, 0x8a, 0x31, 0x40, 0x9d, 0x2f, 0x66, 0x55, 0x50, 0xf0,
	0x39, 0xe0, 0x53, 0x28, 0xc6, 0x1c, 0xa8, 0x9a, 0x85, 0xf9, 0xf4, 0x20, 0xf0, 0x1b, 0x9e, 0xad,
	0xff, 0x5e, 0x81, 0xdc, 0x91, 0xe3, 0x9d, 0xa2, 0xdb, 0xa9, 0x6e, 0x9f, 0x6e, 0xd2, 0x14, 0x41,
	0x6e, 0xec, 0x1b, 0x00, 0xd2, 0x80, 0x93, 0x65, 0x95, 0x4b, 0x82, 0xe8, 0x5f, 0x88, 0xee, 0x5d,
	0x06, 0x18, 0x86, 0x3e, 0xdf, 0x82, 0x8e, 0x9a, 0xed, 0x8e, 0xa6, 0xd0, 0xbe, 0x4e, 0xbf, 0xcc,
	0x66, 0xa7, 0xf1, 0x44, 0xcb, 0xa0, 0x32, 0x14, 0x9a, 0x4f, 0x8e, 0x5b, 0xb8, 0xb3, 0x6b, 0x74,
	0xb4, 0xff, 0xac, 0x7c, 0x95, 0x53, 0x15, 0x2d, 0xa3, 0x3f, 0x81, 0x42, 0x32, 0x1e, 0xa0, 0xf7,
	0x41, 0x0d, 0xac, 0xd7, 0xbc, 0x1c, 0x72, 0xf7, 0xaf, 0x04, 0xd6, 0x6b, 0x56, 0x0b, 0x7f, 0x00,
	0x39, 0xd7, 0xf1, 0x4e, 0x6b, 0x19, 0xd6, 0xf7, 0xab, 0x63, 0xaa, 0x63, 0x76, 0xad, 0xff, 0xa9,
	0x02, 0x6b, 0x63, 0xc5, 0x84, 0x8e, 0xf9, 0x16, 0x68, 0x5d, 0x0a, 0x37, 0xa5, 0x55, 0x48, 0x99,
	0x30, 0xeb, 0x4e, 0x22, 0x1e, 0x05, 0xf2, 0x31, 0xb4, 0xd2, 0x4d, 0x43, 0xd1, 0x5e, 0x3c, 0x92,
	0x73, 0x1d, 0x3f, 0x9e, 0xcf, 0x77, 0x7c, 0x2c, 0x3f, 0x9b, 0x32, 0x96, 0x67, 0x19, 0xcb, 0x47,
	0xf3, 0x59, 0x5e, 0x6e, 0x34, 0xff, 0x0c, 0xf2, 0x91, 0x1f, 0x59, 0xae, 0x08, 0xfc, 0x5b, 0xf3,
	0xf9, 0x77, 0x28, 0x3a, 0xe6, 0x54, 0xe8, 0x43, 0xa8, 0x78, 0xe4, 0x22, 0x32, 0xa5, 0xea, 0x0f,
	0xcc, 0x6d, 0x25, 0x0a, 0x3e, 0x8e, 0x3b, 0x40, 0xdd, 0x86, 0x22, 0x26, 0xae, 0x15, 0x11, 0x9b,
	0xbe, 0x78, 0x6a, 0x8e, 0xdf, 0x84, 0x52, 0x40, 0xd1, 0x52, 0x33, 0x44, 0x01, 0xaf, 0xc6, 0x40,
	0x16, 0x6f, 0x35, 0x58, 0xf1, 0x03, 0xdb, 0xf1, 0x2c, 0x57, 0xac, 0xe5, 0xf1, 0xb1, 0xfe, 0x67,
	0x85, 0x96, 0x4d, 0x26, 0x46, 0x14, 0x93, 0x3b, 0xb0, 0xcc, 0xdb, 0xa9, 0xd8, 0xec, 0x26, 0xce,
	0x59, 0x02, 0x65, 0x6c, 0x92, 0xcd, 0x2c, 0x3c, 0xc9, 0xa2, 0x5b, 0x90, 0x0b, 0x9d, 0x88, 0x08,
	0x2f, 0x4d, 0x94, 0xc2, 0x10, 0xa4, 0x97, 0xe7, 0xe4, 0x97, 0xd7, 0xff, 0x9e, 0x83, 0x6a, 0xda,
	0xdc, 0x6d, 0x12, 0x4d, 0xb5, 0x53, 0x2b, 0x95, 0x9a, 0x3c, 0xda, 0xee, 0xcd, 0x77, 0x5d, 0xca,
	0x36, 0x72, 0x2e, 0xa3, 0x27, 0xf2, 0x4e, 0x9a, 0x7d, 0x37, 0x7e, 0xd2, 0x6e, 0xfa, 0x14, 0x4a,
	0xa9, 0x29, 0x48, 0xac, 0xb9, 0x97, 0x66, 0x99, 0xe6, 0x82, 0x7e, 0x0e, 0x45, 0x69, 0x82, 0x61,
	0xc3, 0xd4, 0x3b, 0x30, 0x95, 0x79, 0xa0, 0x2f, 0x61, 0x99, 0xcf, 0x15, 0xb5, 0xe5, 0x77, 0xe3,
	0x26, 0xc8, 0xc7, 0x82, 0x67, 0x65, 0xf1, 0xe0, 0x39, 0x06, 0x1e, 0xe0, 0xc4, 0x36, 0x69, 0x0d,
	0xa8, 0x01, 0xd3, 0xe4, 0xee, 0xc2, 0x9a, 0xd0, 0x94, 0xc2, 0xc5, 0x60, 0x78, 0xa8, 0xff, 0x3f,
	0x03, 0x79, 0x96, 0xa7, 0x68, 0x93, 0x9a, 0x6c, 0x38, 0xdc, 0xd1, 0x30, 0xca, 0x62, 0x19, 0x84,
	0x74, 0x58, 0x95, 0x0c, 0x12, 0xb2, 0xa8, 0xcf, 0xe2, 0x14, 0x6c, 0xe4, 0x07, 0x52, 0x96, 0x61,
	0xc8, 0x3f, 0x90, 0xbe, 0x3f, 0xee, 0x6f, 0x8a, 0x32, 0xe2, 0xbe, 0x1a, 0xac, 0x70, 0x63, 0x85,
	0xac, 0xda, 0x64, 0x71, 0x7c, 0x44, 0xbf, 0x81, 0xf7, 0x65, 0x0b, 0x84, 0xe6, 0xc9, 0xc0, 0x8c,
	0x73, 0x5e, 0x38, 0x66, 0x7f, 0xc1, 0xca, 0x24, 0x1b, 0x25, 0xdc, 0x1b, 0x60, 0xc1, 0x85, 0x97,
	0xc0, 0xf5, 0x60, 0xe2, 0x65, 0xbd, 0x09, 0xd7, 0x66, 0x90, 0x4d, 0x58, 0xb2, 0xd6, 0xe4, 0x25,
	0x2b, 0x2b, 0x6f, 0x6a, 0xaf, 0xc7, 0xda, 0xcf, 0x34, 0x1e, 0xcd, 0xf4, 0xa2, 0xf6, 0xe0, 0xb2,
	0x5d, 0xa8, 0x4d, 0x22, 0x59, 0xf0, 0x77, 0x71, 0xaf, 0xd5, 0x0f, 0x61, 0x2d, 0x35, 0x81, 0xce,
	0x5b, 0x33, 0x87, 0x9b, 0x54, 0x46, 0xde, 0xa4, 0xf4, 0xff, 0xe6, 0x01, 0x8d, 0x30, 0xa2, 0x3d,
	0xff, 0x00, 0xd4, 0x38, 0x04, 0x45, 0xaf, 0x1f, 0xf9, 0x4d, 0x36, 0x46, 0x92, 0x80, 0x70, 0x42,
	0x89, 0x1e, 0xa7, 0xdb, 0xfa, 0xed, 0x79, 0x2c, 0xc6, 0x9b, 0xfa, 0xe9, 0xcc, 0xa6, 0xfe, 0x70,
	0xae, 0x4e, 0x97, 0x69, 0xe9, 0xf5, 0x3f, 0x66, 0x40, 0x8d, 0x99, 0x4c, 0xed, 0x20, 0xb7, 0xc5,
	0xfc, 0x3a, 0xbb, 0xc7, 0xf1, 0xb9, 0xf6, 0x87, 0x50, 0x48, 0x16, 0xac, 0x39, 0xbf, 0x77, 0x86,
	0x88, 0x4c, 0xc2, 0xa0, 0x4f, 0xc4, 0x08, 0x3e, 0x5d, 0xc2, 0xa0, 0x4f, 0xd0, 0x43, 0x28, 0xb2,
	0x67, 0x58, 0xae, 0xf3, 0x86, 0x6d, 0xc9, 0x33, 0x6b, 0xa7, 0x84, 0x8a, 0x3e, 0x11, 0x9d, 0x90,
	0xd8, 0xe6, 0xc9, 0x80, 0x4d, 0xe3, 0x33, 0x94, 0x13, 0x98, 0x7b, 0x83, 0xaf, 0x72, 0xea, 0x8a,
	0xa6, 0x7e, 0x27, 0x53, 0x66, 0xe7, 0x9b, 0x0c, 0x14, 0x9f, 0x61, 0xd2, 0x6b, 0x93, 0xe0, 0x95,
	0xd3, 0x25, 0x74, 0xb9, 0x96, 0xfe, 0xea, 0xa0, 0xeb, 0x73, 0x7e, 0xa2, 0xd7, 0x3f, 0x98, 0xf9,
	0x43, 0x48, 0x5f, 0x42, 0xcf, 0xa1, 0x32, 0x52, 0x7d, 0xd0, 0xcd, 0x05, 0x76, 0xf5, 0xfa, 0x8d,
	0xb9, 0x05, 0x4c, 0x5f, 0xa2, 0x93, 0x41, 0x2a, 0xc0, 0xd1, 0x8d, 0x59, 0xc1, 0xcf, 0x19, 0x5f,
	0x9f, 0x93, 0x1f, 0xfa, 0xd2, 0x9e, 0xf6, 0xb7, 0xb7, 0x1b, 0xca, 0x3f, 0xde, 0x6e, 0x28, 0xff,
	0x7a, 0xbb, 0xa1, 0xfc, 0xee, 0xdf, 0x1b, 0x4b, 0x27, 0xcb, 0x0c, 0xfb, 0xc1, 0xb7, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x57, 0x37, 0xe9, 0xd3, 0x0c, 0x1b, 0x00, 0x00,
}
