// Code generated by protoc-gen-gogo.
// source: kythe/proto/serving.proto
// DO NOT EDIT!

/*
	Package serving_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/serving.proto

	It has these top-level messages:
		Node
		Edge
		EdgeGroup
		PagedEdgeSet
		PageIndex
		EdgePage
		FileDirectory
		CorpusRoots
		File
		RawAnchor
		ExpandedAnchor
		Link
		MarkedSource
		FileDecorations
		PagedCrossReferences
*/
package serving_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_common "kythe.io/kythe/proto/common_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MarkedSource_Kind int32

const (
	// This node only contains other nodes and has no special semantics.
	MarkedSource_BOX MarkedSource_Kind = 0
	// This node dominates nodes that should be classified as types.
	MarkedSource_TYPE MarkedSource_Kind = 1
	// This node dominates nodes that should be classified as parameters.
	MarkedSource_PARAMETER MarkedSource_Kind = 2
	// This node dominates nodes that should be classified as identifiers.
	MarkedSource_IDENTIFIER MarkedSource_Kind = 3
	// This node dominates nodes that should be classified as context.
	MarkedSource_CONTEXT MarkedSource_Kind = 4
	// This node dominates nodes that should be classified as initializers.
	MarkedSource_INITIALIZER MarkedSource_Kind = 5
	// Substitute this node with a PARAMETER formed from the param edges from
	// the context node starting with `lookup_index`.
	MarkedSource_PARAMETER_LOOKUP_BY_PARAM MarkedSource_Kind = 6
	// Substitute this node with the marked source derived from the
	// `lookup_index`th param edge of the context node.
	MarkedSource_LOOKUP_BY_PARAM MarkedSource_Kind = 7
	// Substitute this node with a PARAMETER formed from the param edges from
	// the context node starting with `lookup_index`. Checks the context
	// node for a `param/default` fact and uses that to set the
	// first_default_child field.
	MarkedSource_PARAMETER_LOOKUP_BY_PARAM_WITH_DEFAULTS MarkedSource_Kind = 8
)

var MarkedSource_Kind_name = map[int32]string{
	0: "BOX",
	1: "TYPE",
	2: "PARAMETER",
	3: "IDENTIFIER",
	4: "CONTEXT",
	5: "INITIALIZER",
	6: "PARAMETER_LOOKUP_BY_PARAM",
	7: "LOOKUP_BY_PARAM",
	8: "PARAMETER_LOOKUP_BY_PARAM_WITH_DEFAULTS",
}
var MarkedSource_Kind_value = map[string]int32{
	"BOX":                                     0,
	"TYPE":                                    1,
	"PARAMETER":                               2,
	"IDENTIFIER":                              3,
	"CONTEXT":                                 4,
	"INITIALIZER":                             5,
	"PARAMETER_LOOKUP_BY_PARAM":               6,
	"LOOKUP_BY_PARAM":                         7,
	"PARAMETER_LOOKUP_BY_PARAM_WITH_DEFAULTS": 8,
}

func (x MarkedSource_Kind) String() string {
	return proto.EnumName(MarkedSource_Kind_name, int32(x))
}
func (MarkedSource_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorServing, []int{12, 0} }

// What kind of override this is.
type FileDecorations_Override_Kind int32

const (
	FileDecorations_Override_OVERRIDES FileDecorations_Override_Kind = 0
	FileDecorations_Override_EXTENDS   FileDecorations_Override_Kind = 1
)

var FileDecorations_Override_Kind_name = map[int32]string{
	0: "OVERRIDES",
	1: "EXTENDS",
}
var FileDecorations_Override_Kind_value = map[string]int32{
	"OVERRIDES": 0,
	"EXTENDS":   1,
}

func (x FileDecorations_Override_Kind) String() string {
	return proto.EnumName(FileDecorations_Override_Kind_name, int32(x))
}
func (FileDecorations_Override_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{13, 1, 0}
}

type PagedCrossReferences_Feature int32

const (
	// Related nodes are mixed with related anchors.
	PagedCrossReferences_RELATED_NODES PagedCrossReferences_Feature = 0
	// The marked_source field is populated.
	PagedCrossReferences_MARKED_SOURCE PagedCrossReferences_Feature = 1
	// Callers are mixed with related anchors.
	PagedCrossReferences_CALLERS PagedCrossReferences_Feature = 2
	// Declarations are mixed with related anchors.
	PagedCrossReferences_DECLARATIONS PagedCrossReferences_Feature = 3
)

var PagedCrossReferences_Feature_name = map[int32]string{
	0: "RELATED_NODES",
	1: "MARKED_SOURCE",
	2: "CALLERS",
	3: "DECLARATIONS",
}
var PagedCrossReferences_Feature_value = map[string]int32{
	"RELATED_NODES": 0,
	"MARKED_SOURCE": 1,
	"CALLERS":       2,
	"DECLARATIONS":  3,
}

func (x PagedCrossReferences_Feature) String() string {
	return proto.EnumName(PagedCrossReferences_Feature_name, int32(x))
}
func (PagedCrossReferences_Feature) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{14, 0}
}

// A derivative of xref.NodeInfo for serving.
type Node struct {
	Ticket string                     `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	Fact   []*kythe_proto_common.Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
	// This node's definition location (anchor).
	DefinitionLocation *ExpandedAnchor `protobuf:"bytes,3,opt,name=definition_location,json=definitionLocation" json:"definition_location,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{0} }

func (m *Node) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *Node) GetFact() []*kythe_proto_common.Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

func (m *Node) GetDefinitionLocation() *ExpandedAnchor {
	if m != nil {
		return m.DefinitionLocation
	}
	return nil
}

// Full representation of a Kythe edge; useful during post-processing.
type Edge struct {
	Source  *Node                      `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Kind    string                     `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Ordinal int32                      `protobuf:"varint,5,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	Target  *Node                      `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	Fact    []*kythe_proto_common.Fact `protobuf:"bytes,4,rep,name=fact" json:"fact,omitempty"`
}

func (m *Edge) Reset()                    { *m = Edge{} }
func (m *Edge) String() string            { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()               {}
func (*Edge) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{1} }

func (m *Edge) GetSource() *Node {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Edge) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Edge) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

func (m *Edge) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Edge) GetFact() []*kythe_proto_common.Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

// An EdgeGroup represents a set of edges with the same kind and source.
//
// Note: this is a derivative of xref.EdgeSet_Group
type EdgeGroup struct {
	Kind string            `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Edge []*EdgeGroup_Edge `protobuf:"bytes,2,rep,name=edge" json:"edge,omitempty"`
}

func (m *EdgeGroup) Reset()                    { *m = EdgeGroup{} }
func (m *EdgeGroup) String() string            { return proto.CompactTextString(m) }
func (*EdgeGroup) ProtoMessage()               {}
func (*EdgeGroup) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{2} }

func (m *EdgeGroup) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *EdgeGroup) GetEdge() []*EdgeGroup_Edge {
	if m != nil {
		return m.Edge
	}
	return nil
}

type EdgeGroup_Edge struct {
	Target  *Node `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	Ordinal int32 `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *EdgeGroup_Edge) Reset()                    { *m = EdgeGroup_Edge{} }
func (m *EdgeGroup_Edge) String() string            { return proto.CompactTextString(m) }
func (*EdgeGroup_Edge) ProtoMessage()               {}
func (*EdgeGroup_Edge) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{2, 0} }

func (m *EdgeGroup_Edge) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *EdgeGroup_Edge) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

// PagedEdgeSets are used for efficiently storing EdgeSets, all originating from
// the same source ticket, in order to handle pagination requests.
type PagedEdgeSet struct {
	// The source node for all the edges in the edge set.
	Source *Node `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Each group is a collection of outbound edges from source node sharing a
	// given kind.
	Group []*EdgeGroup `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
	// Total number of edges in all of the EdgePages, including this one.
	TotalEdges int32 `protobuf:"varint,3,opt,name=total_edges,json=totalEdges,proto3" json:"total_edges,omitempty"`
	// Page indices for other EdgePages, sorted by edge kind.
	PageIndex []*PageIndex `protobuf:"bytes,4,rep,name=page_index,json=pageIndex" json:"page_index,omitempty"`
}

func (m *PagedEdgeSet) Reset()                    { *m = PagedEdgeSet{} }
func (m *PagedEdgeSet) String() string            { return proto.CompactTextString(m) }
func (*PagedEdgeSet) ProtoMessage()               {}
func (*PagedEdgeSet) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{3} }

func (m *PagedEdgeSet) GetSource() *Node {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *PagedEdgeSet) GetGroup() []*EdgeGroup {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *PagedEdgeSet) GetTotalEdges() int32 {
	if m != nil {
		return m.TotalEdges
	}
	return 0
}

func (m *PagedEdgeSet) GetPageIndex() []*PageIndex {
	if m != nil {
		return m.PageIndex
	}
	return nil
}

// PageIndex is a pointer to an EdgePage.  In order to keep the PagedEdgeSet
// small, we don't store edges here.  We just store a key for looking up an
// EdgePage and the type of edge.
type PageIndex struct {
	// The kind of all edges on the referred EdgePage.
	EdgeKind string `protobuf:"bytes,1,opt,name=edge_kind,json=edgeKind,proto3" json:"edge_kind,omitempty"`
	// Total number of edges on the referred EdgePage.
	EdgeCount int32 `protobuf:"varint,2,opt,name=edge_count,json=edgeCount,proto3" json:"edge_count,omitempty"`
	// Key that can be used to lookup the referred EdgePage.
	PageKey string `protobuf:"bytes,3,opt,name=page_key,json=pageKey,proto3" json:"page_key,omitempty"`
}

func (m *PageIndex) Reset()                    { *m = PageIndex{} }
func (m *PageIndex) String() string            { return proto.CompactTextString(m) }
func (*PageIndex) ProtoMessage()               {}
func (*PageIndex) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{4} }

func (m *PageIndex) GetEdgeKind() string {
	if m != nil {
		return m.EdgeKind
	}
	return ""
}

func (m *PageIndex) GetEdgeCount() int32 {
	if m != nil {
		return m.EdgeCount
	}
	return 0
}

func (m *PageIndex) GetPageKey() string {
	if m != nil {
		return m.PageKey
	}
	return ""
}

// EdgePages are a group of edges for a particular edge kind and source ticket.
type EdgePage struct {
	// Corresponding PageIndex key that can be used to lookup this page.
	PageKey      string     `protobuf:"bytes,1,opt,name=page_key,json=pageKey,proto3" json:"page_key,omitempty"`
	SourceTicket string     `protobuf:"bytes,2,opt,name=source_ticket,json=sourceTicket,proto3" json:"source_ticket,omitempty"`
	EdgesGroup   *EdgeGroup `protobuf:"bytes,3,opt,name=edges_group,json=edgesGroup" json:"edges_group,omitempty"`
}

func (m *EdgePage) Reset()                    { *m = EdgePage{} }
func (m *EdgePage) String() string            { return proto.CompactTextString(m) }
func (*EdgePage) ProtoMessage()               {}
func (*EdgePage) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{5} }

func (m *EdgePage) GetPageKey() string {
	if m != nil {
		return m.PageKey
	}
	return ""
}

func (m *EdgePage) GetSourceTicket() string {
	if m != nil {
		return m.SourceTicket
	}
	return ""
}

func (m *EdgePage) GetEdgesGroup() *EdgeGroup {
	if m != nil {
		return m.EdgesGroup
	}
	return nil
}

// FileDirectory describes a virtual directory of file nodes.
type FileDirectory struct {
	// Set of URIs for each contained sub-directory's corpus, root, and full path.
	Subdirectory []string `protobuf:"bytes,1,rep,name=subdirectory" json:"subdirectory,omitempty"`
	// Set of file node tickets contained within this directory.
	FileTicket []string `protobuf:"bytes,2,rep,name=file_ticket,json=fileTicket" json:"file_ticket,omitempty"`
}

func (m *FileDirectory) Reset()                    { *m = FileDirectory{} }
func (m *FileDirectory) String() string            { return proto.CompactTextString(m) }
func (*FileDirectory) ProtoMessage()               {}
func (*FileDirectory) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{6} }

func (m *FileDirectory) GetSubdirectory() []string {
	if m != nil {
		return m.Subdirectory
	}
	return nil
}

func (m *FileDirectory) GetFileTicket() []string {
	if m != nil {
		return m.FileTicket
	}
	return nil
}

// CorpusRoots describes all of the known corpus/root pairs that contain file
// nodes.
type CorpusRoots struct {
	Corpus []*CorpusRoots_Corpus `protobuf:"bytes,1,rep,name=corpus" json:"corpus,omitempty"`
}

func (m *CorpusRoots) Reset()                    { *m = CorpusRoots{} }
func (m *CorpusRoots) String() string            { return proto.CompactTextString(m) }
func (*CorpusRoots) ProtoMessage()               {}
func (*CorpusRoots) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{7} }

func (m *CorpusRoots) GetCorpus() []*CorpusRoots_Corpus {
	if m != nil {
		return m.Corpus
	}
	return nil
}

type CorpusRoots_Corpus struct {
	Corpus string   `protobuf:"bytes,1,opt,name=corpus,proto3" json:"corpus,omitempty"`
	Root   []string `protobuf:"bytes,2,rep,name=root" json:"root,omitempty"`
}

func (m *CorpusRoots_Corpus) Reset()                    { *m = CorpusRoots_Corpus{} }
func (m *CorpusRoots_Corpus) String() string            { return proto.CompactTextString(m) }
func (*CorpusRoots_Corpus) ProtoMessage()               {}
func (*CorpusRoots_Corpus) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{7, 0} }

func (m *CorpusRoots_Corpus) GetCorpus() string {
	if m != nil {
		return m.Corpus
	}
	return ""
}

func (m *CorpusRoots_Corpus) GetRoot() []string {
	if m != nil {
		return m.Root
	}
	return nil
}

// A File is a specialized Node structure for file nodes.
type File struct {
	Ticket   string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	Text     []byte `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	Encoding string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{8} }

func (m *File) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *File) GetText() []byte {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *File) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

// A RawAnchor is a specialized Node structure for anchor nodes.
type RawAnchor struct {
	Ticket       string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	StartOffset  int32  `protobuf:"varint,2,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	EndOffset    int32  `protobuf:"varint,3,opt,name=end_offset,json=endOffset,proto3" json:"end_offset,omitempty"`
	SnippetStart int32  `protobuf:"varint,4,opt,name=snippet_start,json=snippetStart,proto3" json:"snippet_start,omitempty"`
	SnippetEnd   int32  `protobuf:"varint,5,opt,name=snippet_end,json=snippetEnd,proto3" json:"snippet_end,omitempty"`
}

func (m *RawAnchor) Reset()                    { *m = RawAnchor{} }
func (m *RawAnchor) String() string            { return proto.CompactTextString(m) }
func (*RawAnchor) ProtoMessage()               {}
func (*RawAnchor) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{9} }

func (m *RawAnchor) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *RawAnchor) GetStartOffset() int32 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *RawAnchor) GetEndOffset() int32 {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

func (m *RawAnchor) GetSnippetStart() int32 {
	if m != nil {
		return m.SnippetStart
	}
	return 0
}

func (m *RawAnchor) GetSnippetEnd() int32 {
	if m != nil {
		return m.SnippetEnd
	}
	return 0
}

// ExpandedAnchors are constructed from an RawAnchor and its associated File.
// They contain normalized Spans based on their parent file's text as well as
// the UTF8-encoded text for both the anchor's span and its snippet span.
type ExpandedAnchor struct {
	Ticket      string                   `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	Kind        string                   `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Text        string                   `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	Span        *kythe_proto_common.Span `protobuf:"bytes,5,opt,name=span" json:"span,omitempty"`
	Snippet     string                   `protobuf:"bytes,6,opt,name=snippet,proto3" json:"snippet,omitempty"`
	SnippetSpan *kythe_proto_common.Span `protobuf:"bytes,7,opt,name=snippet_span,json=snippetSpan" json:"snippet_span,omitempty"`
}

func (m *ExpandedAnchor) Reset()                    { *m = ExpandedAnchor{} }
func (m *ExpandedAnchor) String() string            { return proto.CompactTextString(m) }
func (*ExpandedAnchor) ProtoMessage()               {}
func (*ExpandedAnchor) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{10} }

func (m *ExpandedAnchor) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *ExpandedAnchor) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ExpandedAnchor) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ExpandedAnchor) GetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *ExpandedAnchor) GetSnippet() string {
	if m != nil {
		return m.Snippet
	}
	return ""
}

func (m *ExpandedAnchor) GetSnippetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.SnippetSpan
	}
	return nil
}

// Serving equivalent of kythe.proto.Link.
type Link struct {
	// Semantic tickets for DEFINITION links.
	Definition []string `protobuf:"bytes,1,rep,name=definition" json:"definition,omitempty"`
}

func (m *Link) Reset()                    { *m = Link{} }
func (m *Link) String() string            { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()               {}
func (*Link) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{11} }

func (m *Link) GetDefinition() []string {
	if m != nil {
		return m.Definition
	}
	return nil
}

// Marked up, source code-like text.
// Serving equivalent of kythe.proto.MarkedSource.
type MarkedSource struct {
	Kind MarkedSource_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=kythe.proto.serving.MarkedSource_Kind" json:"kind,omitempty"`
	// Nodes expect to be printed as:
	// pre_text + (child + post_child_text)* + post_text
	// where post_child_text is not included after the final child unless
	// add_final_list_token is asserted. post_child_text should never be
	// printed if there are no children.
	PreText       string          `protobuf:"bytes,2,opt,name=pre_text,json=preText,proto3" json:"pre_text,omitempty"`
	Child         []*MarkedSource `protobuf:"bytes,3,rep,name=child" json:"child,omitempty"`
	PostChildText string          `protobuf:"bytes,4,opt,name=post_child_text,json=postChildText,proto3" json:"post_child_text,omitempty"`
	PostText      string          `protobuf:"bytes,5,opt,name=post_text,json=postText,proto3" json:"post_text,omitempty"`
	LookupIndex   uint32          `protobuf:"varint,6,opt,name=lookup_index,json=lookupIndex,proto3" json:"lookup_index,omitempty"`
	// The default_children_count children at the end of the child list should
	// be considered as "default" or uninteresting.
	DefaultChildrenCount uint32 `protobuf:"varint,7,opt,name=default_children_count,json=defaultChildrenCount,proto3" json:"default_children_count,omitempty"`
	// `add_final_list_token` ensures that `post_child_text` will be
	// included after any nonempty list when that list is followed by additional
	// text.
	AddFinalListToken bool `protobuf:"varint,10,opt,name=add_final_list_token,json=addFinalListToken,proto3" json:"add_final_list_token,omitempty"`
	// Annotations covering this subtree's full span.
	Link []*Link `protobuf:"bytes,11,rep,name=link" json:"link,omitempty"`
}

func (m *MarkedSource) Reset()                    { *m = MarkedSource{} }
func (m *MarkedSource) String() string            { return proto.CompactTextString(m) }
func (*MarkedSource) ProtoMessage()               {}
func (*MarkedSource) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{12} }

func (m *MarkedSource) GetKind() MarkedSource_Kind {
	if m != nil {
		return m.Kind
	}
	return MarkedSource_BOX
}

func (m *MarkedSource) GetPreText() string {
	if m != nil {
		return m.PreText
	}
	return ""
}

func (m *MarkedSource) GetChild() []*MarkedSource {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *MarkedSource) GetPostChildText() string {
	if m != nil {
		return m.PostChildText
	}
	return ""
}

func (m *MarkedSource) GetPostText() string {
	if m != nil {
		return m.PostText
	}
	return ""
}

func (m *MarkedSource) GetLookupIndex() uint32 {
	if m != nil {
		return m.LookupIndex
	}
	return 0
}

func (m *MarkedSource) GetDefaultChildrenCount() uint32 {
	if m != nil {
		return m.DefaultChildrenCount
	}
	return 0
}

func (m *MarkedSource) GetAddFinalListToken() bool {
	if m != nil {
		return m.AddFinalListToken
	}
	return false
}

func (m *MarkedSource) GetLink() []*Link {
	if m != nil {
		return m.Link
	}
	return nil
}

// FileDecorations stores a file's contents and all contained anchor edges.
type FileDecorations struct {
	File *File `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	// The decorations located in the file, sorted by starting offset.
	Decoration []*FileDecorations_Decoration `protobuf:"bytes,2,rep,name=decoration" json:"decoration,omitempty"`
	// Set of nodes associated with each Decoration.target and
	// target_override.overridden.
	Target []*Node `protobuf:"bytes,4,rep,name=target" json:"target,omitempty"`
	// Set of definition locations for each Decoration.target and
	// target_override.overridden.
	TargetDefinitions []*ExpandedAnchor `protobuf:"bytes,3,rep,name=target_definitions,json=targetDefinitions" json:"target_definitions,omitempty"`
	// List of overrides for target semantic nodes.
	TargetOverride []*FileDecorations_Override `protobuf:"bytes,5,rep,name=target_override,json=targetOverride" json:"target_override,omitempty"`
}

func (m *FileDecorations) Reset()                    { *m = FileDecorations{} }
func (m *FileDecorations) String() string            { return proto.CompactTextString(m) }
func (*FileDecorations) ProtoMessage()               {}
func (*FileDecorations) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{13} }

func (m *FileDecorations) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileDecorations) GetDecoration() []*FileDecorations_Decoration {
	if m != nil {
		return m.Decoration
	}
	return nil
}

func (m *FileDecorations) GetTarget() []*Node {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *FileDecorations) GetTargetDefinitions() []*ExpandedAnchor {
	if m != nil {
		return m.TargetDefinitions
	}
	return nil
}

func (m *FileDecorations) GetTargetOverride() []*FileDecorations_Override {
	if m != nil {
		return m.TargetOverride
	}
	return nil
}

// Represents an edge from an anchor contained within the file to some target.
type FileDecorations_Decoration struct {
	Anchor           *RawAnchor `protobuf:"bytes,1,opt,name=anchor" json:"anchor,omitempty"`
	Kind             string     `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Target           string     `protobuf:"bytes,5,opt,name=target,proto3" json:"target,omitempty"`
	TargetDefinition string     `protobuf:"bytes,4,opt,name=target_definition,json=targetDefinition,proto3" json:"target_definition,omitempty"`
}

func (m *FileDecorations_Decoration) Reset()         { *m = FileDecorations_Decoration{} }
func (m *FileDecorations_Decoration) String() string { return proto.CompactTextString(m) }
func (*FileDecorations_Decoration) ProtoMessage()    {}
func (*FileDecorations_Decoration) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{13, 0}
}

func (m *FileDecorations_Decoration) GetAnchor() *RawAnchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *FileDecorations_Decoration) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *FileDecorations_Decoration) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *FileDecorations_Decoration) GetTargetDefinition() string {
	if m != nil {
		return m.TargetDefinition
	}
	return ""
}

// An overrides/extends for a defining Decoration's target.
//
// Example:
//   overriding:  "kythe:#java.lang.String"
//   kind:        EXTENDS
//   overridden:  "kythe:#java.lang.Object"
type FileDecorations_Override struct {
	// Ticket of overriding node (i.e. a Decoration target for a definition)
	Overriding string `protobuf:"bytes,1,opt,name=overriding,proto3" json:"overriding,omitempty"`
	// Ticket of node that is being overridden/extended.
	Overridden           string                        `protobuf:"bytes,2,opt,name=overridden,proto3" json:"overridden,omitempty"`
	OverriddenDefinition string                        `protobuf:"bytes,5,opt,name=overridden_definition,json=overriddenDefinition,proto3" json:"overridden_definition,omitempty"`
	Kind                 FileDecorations_Override_Kind `protobuf:"varint,3,opt,name=kind,proto3,enum=kythe.proto.serving.FileDecorations_Override_Kind" json:"kind,omitempty"`
	// MarkedSource for the node being overridden/extended (i.e. node whose
	// ticket is overridden).
	MarkedSource *MarkedSource `protobuf:"bytes,4,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
}

func (m *FileDecorations_Override) Reset()         { *m = FileDecorations_Override{} }
func (m *FileDecorations_Override) String() string { return proto.CompactTextString(m) }
func (*FileDecorations_Override) ProtoMessage()    {}
func (*FileDecorations_Override) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{13, 1}
}

func (m *FileDecorations_Override) GetOverriding() string {
	if m != nil {
		return m.Overriding
	}
	return ""
}

func (m *FileDecorations_Override) GetOverridden() string {
	if m != nil {
		return m.Overridden
	}
	return ""
}

func (m *FileDecorations_Override) GetOverriddenDefinition() string {
	if m != nil {
		return m.OverriddenDefinition
	}
	return ""
}

func (m *FileDecorations_Override) GetKind() FileDecorations_Override_Kind {
	if m != nil {
		return m.Kind
	}
	return FileDecorations_Override_OVERRIDES
}

func (m *FileDecorations_Override) GetMarkedSource() *MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

// PagedCrossReferences are used for efficiently storing pre-cached data for
// CrossReferencesReply.{definition,reference,documentation} anchors.  Related
// nodes can be retrieved from edge sets/pages.
type PagedCrossReferences struct {
	// Set of features implemented by this serving datum.  This tells the server
	// which data must be computed dynamically.
	Feature []PagedCrossReferences_Feature `protobuf:"varint,10,rep,packed,name=feature,enum=kythe.proto.serving.PagedCrossReferences_Feature" json:"feature,omitempty"`
	// Nodes with cross-references that should be merged into this node's set of
	// cross-references.  These are highly related nodes that share a definition.
	MergeWith       []string                          `protobuf:"bytes,7,rep,name=merge_with,json=mergeWith" json:"merge_with,omitempty"`
	SourceTicket    string                            `protobuf:"bytes,1,opt,name=source_ticket,json=sourceTicket,proto3" json:"source_ticket,omitempty"`
	Group           []*PagedCrossReferences_Group     `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
	PageIndex       []*PagedCrossReferences_PageIndex `protobuf:"bytes,3,rep,name=page_index,json=pageIndex" json:"page_index,omitempty"`
	TotalReferences int32                             `protobuf:"varint,4,opt,name=total_references,json=totalReferences,proto3" json:"total_references,omitempty"`
	// Whether the source node is incomplete.  This changes whether
	// /kythe/edge/defines edges are considered declarations or definitions.
	// /kythe/edge/completes edges are always grouped as definitions.
	Incomplete bool `protobuf:"varint,5,opt,name=incomplete,proto3" json:"incomplete,omitempty"`
	// The source node's MarkedSource.
	MarkedSource *MarkedSource `protobuf:"bytes,6,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
}

func (m *PagedCrossReferences) Reset()                    { *m = PagedCrossReferences{} }
func (m *PagedCrossReferences) String() string            { return proto.CompactTextString(m) }
func (*PagedCrossReferences) ProtoMessage()               {}
func (*PagedCrossReferences) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{14} }

func (m *PagedCrossReferences) GetFeature() []PagedCrossReferences_Feature {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *PagedCrossReferences) GetMergeWith() []string {
	if m != nil {
		return m.MergeWith
	}
	return nil
}

func (m *PagedCrossReferences) GetSourceTicket() string {
	if m != nil {
		return m.SourceTicket
	}
	return ""
}

func (m *PagedCrossReferences) GetGroup() []*PagedCrossReferences_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *PagedCrossReferences) GetPageIndex() []*PagedCrossReferences_PageIndex {
	if m != nil {
		return m.PageIndex
	}
	return nil
}

func (m *PagedCrossReferences) GetTotalReferences() int32 {
	if m != nil {
		return m.TotalReferences
	}
	return 0
}

func (m *PagedCrossReferences) GetIncomplete() bool {
	if m != nil {
		return m.Incomplete
	}
	return false
}

func (m *PagedCrossReferences) GetMarkedSource() *MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

// Node which is related to the source_ticket node.  The relation kind is
// stored in each Group.  See: kythe.proto.CrossReferencesReply.RelatedNode.
type PagedCrossReferences_RelatedNode struct {
	Node    *Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	Ordinal int32 `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *PagedCrossReferences_RelatedNode) Reset()         { *m = PagedCrossReferences_RelatedNode{} }
func (m *PagedCrossReferences_RelatedNode) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_RelatedNode) ProtoMessage()    {}
func (*PagedCrossReferences_RelatedNode) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{14, 0}
}

func (m *PagedCrossReferences_RelatedNode) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *PagedCrossReferences_RelatedNode) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

// Caller of the source node with all associated callsites within the caller.
type PagedCrossReferences_Caller struct {
	// The anchor covering the caller.
	Caller *ExpandedAnchor `protobuf:"bytes,1,opt,name=caller" json:"caller,omitempty"`
	// The relevant semantic ticket for the caller.
	SemanticCaller string `protobuf:"bytes,2,opt,name=semantic_caller,json=semanticCaller,proto3" json:"semantic_caller,omitempty"`
	// MarkedSource for the caller.
	MarkedSource *MarkedSource `protobuf:"bytes,3,opt,name=marked_source,json=markedSource" json:"marked_source,omitempty"`
	// Specific locations within the caller that caused the relationship to
	// exist.
	Callsite []*ExpandedAnchor `protobuf:"bytes,4,rep,name=callsite" json:"callsite,omitempty"`
}

func (m *PagedCrossReferences_Caller) Reset()         { *m = PagedCrossReferences_Caller{} }
func (m *PagedCrossReferences_Caller) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_Caller) ProtoMessage()    {}
func (*PagedCrossReferences_Caller) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{14, 1}
}

func (m *PagedCrossReferences_Caller) GetCaller() *ExpandedAnchor {
	if m != nil {
		return m.Caller
	}
	return nil
}

func (m *PagedCrossReferences_Caller) GetSemanticCaller() string {
	if m != nil {
		return m.SemanticCaller
	}
	return ""
}

func (m *PagedCrossReferences_Caller) GetMarkedSource() *MarkedSource {
	if m != nil {
		return m.MarkedSource
	}
	return nil
}

func (m *PagedCrossReferences_Caller) GetCallsite() []*ExpandedAnchor {
	if m != nil {
		return m.Callsite
	}
	return nil
}

type PagedCrossReferences_Group struct {
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// A group is composed entirely of anchors, related nodes, or callers.
	Anchor      []*ExpandedAnchor                   `protobuf:"bytes,2,rep,name=anchor" json:"anchor,omitempty"`
	RelatedNode []*PagedCrossReferences_RelatedNode `protobuf:"bytes,3,rep,name=related_node,json=relatedNode" json:"related_node,omitempty"`
	Caller      []*PagedCrossReferences_Caller      `protobuf:"bytes,4,rep,name=caller" json:"caller,omitempty"`
}

func (m *PagedCrossReferences_Group) Reset()         { *m = PagedCrossReferences_Group{} }
func (m *PagedCrossReferences_Group) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_Group) ProtoMessage()    {}
func (*PagedCrossReferences_Group) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{14, 2}
}

func (m *PagedCrossReferences_Group) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *PagedCrossReferences_Group) GetAnchor() []*ExpandedAnchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *PagedCrossReferences_Group) GetRelatedNode() []*PagedCrossReferences_RelatedNode {
	if m != nil {
		return m.RelatedNode
	}
	return nil
}

func (m *PagedCrossReferences_Group) GetCaller() []*PagedCrossReferences_Caller {
	if m != nil {
		return m.Caller
	}
	return nil
}

type PagedCrossReferences_Page struct {
	PageKey      string                      `protobuf:"bytes,1,opt,name=page_key,json=pageKey,proto3" json:"page_key,omitempty"`
	SourceTicket string                      `protobuf:"bytes,2,opt,name=source_ticket,json=sourceTicket,proto3" json:"source_ticket,omitempty"`
	Group        *PagedCrossReferences_Group `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
}

func (m *PagedCrossReferences_Page) Reset()         { *m = PagedCrossReferences_Page{} }
func (m *PagedCrossReferences_Page) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_Page) ProtoMessage()    {}
func (*PagedCrossReferences_Page) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{14, 3}
}

func (m *PagedCrossReferences_Page) GetPageKey() string {
	if m != nil {
		return m.PageKey
	}
	return ""
}

func (m *PagedCrossReferences_Page) GetSourceTicket() string {
	if m != nil {
		return m.SourceTicket
	}
	return ""
}

func (m *PagedCrossReferences_Page) GetGroup() *PagedCrossReferences_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

// A PageIndex is a reference to a Page.
type PagedCrossReferences_PageIndex struct {
	Kind    string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Count   int32  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	PageKey string `protobuf:"bytes,3,opt,name=page_key,json=pageKey,proto3" json:"page_key,omitempty"`
}

func (m *PagedCrossReferences_PageIndex) Reset()         { *m = PagedCrossReferences_PageIndex{} }
func (m *PagedCrossReferences_PageIndex) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_PageIndex) ProtoMessage()    {}
func (*PagedCrossReferences_PageIndex) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{14, 4}
}

func (m *PagedCrossReferences_PageIndex) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *PagedCrossReferences_PageIndex) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PagedCrossReferences_PageIndex) GetPageKey() string {
	if m != nil {
		return m.PageKey
	}
	return ""
}

func init() {
	proto.RegisterType((*Node)(nil), "kythe.proto.serving.Node")
	proto.RegisterType((*Edge)(nil), "kythe.proto.serving.Edge")
	proto.RegisterType((*EdgeGroup)(nil), "kythe.proto.serving.EdgeGroup")
	proto.RegisterType((*EdgeGroup_Edge)(nil), "kythe.proto.serving.EdgeGroup.Edge")
	proto.RegisterType((*PagedEdgeSet)(nil), "kythe.proto.serving.PagedEdgeSet")
	proto.RegisterType((*PageIndex)(nil), "kythe.proto.serving.PageIndex")
	proto.RegisterType((*EdgePage)(nil), "kythe.proto.serving.EdgePage")
	proto.RegisterType((*FileDirectory)(nil), "kythe.proto.serving.FileDirectory")
	proto.RegisterType((*CorpusRoots)(nil), "kythe.proto.serving.CorpusRoots")
	proto.RegisterType((*CorpusRoots_Corpus)(nil), "kythe.proto.serving.CorpusRoots.Corpus")
	proto.RegisterType((*File)(nil), "kythe.proto.serving.File")
	proto.RegisterType((*RawAnchor)(nil), "kythe.proto.serving.RawAnchor")
	proto.RegisterType((*ExpandedAnchor)(nil), "kythe.proto.serving.ExpandedAnchor")
	proto.RegisterType((*Link)(nil), "kythe.proto.serving.Link")
	proto.RegisterType((*MarkedSource)(nil), "kythe.proto.serving.MarkedSource")
	proto.RegisterType((*FileDecorations)(nil), "kythe.proto.serving.FileDecorations")
	proto.RegisterType((*FileDecorations_Decoration)(nil), "kythe.proto.serving.FileDecorations.Decoration")
	proto.RegisterType((*FileDecorations_Override)(nil), "kythe.proto.serving.FileDecorations.Override")
	proto.RegisterType((*PagedCrossReferences)(nil), "kythe.proto.serving.PagedCrossReferences")
	proto.RegisterType((*PagedCrossReferences_RelatedNode)(nil), "kythe.proto.serving.PagedCrossReferences.RelatedNode")
	proto.RegisterType((*PagedCrossReferences_Caller)(nil), "kythe.proto.serving.PagedCrossReferences.Caller")
	proto.RegisterType((*PagedCrossReferences_Group)(nil), "kythe.proto.serving.PagedCrossReferences.Group")
	proto.RegisterType((*PagedCrossReferences_Page)(nil), "kythe.proto.serving.PagedCrossReferences.Page")
	proto.RegisterType((*PagedCrossReferences_PageIndex)(nil), "kythe.proto.serving.PagedCrossReferences.PageIndex")
	proto.RegisterEnum("kythe.proto.serving.MarkedSource_Kind", MarkedSource_Kind_name, MarkedSource_Kind_value)
	proto.RegisterEnum("kythe.proto.serving.FileDecorations_Override_Kind", FileDecorations_Override_Kind_name, FileDecorations_Override_Kind_value)
	proto.RegisterEnum("kythe.proto.serving.PagedCrossReferences_Feature", PagedCrossReferences_Feature_name, PagedCrossReferences_Feature_value)
}
func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if len(m.Fact) > 0 {
		for _, msg := range m.Fact {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DefinitionLocation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.DefinitionLocation.Size()))
		n1, err := m.DefinitionLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Edge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if m.Target != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Target.Size()))
		n3, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Fact) > 0 {
		for _, msg := range m.Fact {
			dAtA[i] = 0x22
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *EdgeGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Edge) > 0 {
		for _, msg := range m.Edge {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EdgeGroup_Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeGroup_Edge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Target.Size()))
		n4, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *PagedEdgeSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedEdgeSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Source.Size()))
		n5, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Group) > 0 {
		for _, msg := range m.Group {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalEdges != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.TotalEdges))
	}
	if len(m.PageIndex) > 0 {
		for _, msg := range m.PageIndex {
			dAtA[i] = 0x22
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PageIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeKind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.EdgeKind)))
		i += copy(dAtA[i:], m.EdgeKind)
	}
	if m.EdgeCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.EdgeCount))
	}
	if len(m.PageKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PageKey)))
		i += copy(dAtA[i:], m.PageKey)
	}
	return i, nil
}

func (m *EdgePage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgePage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PageKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PageKey)))
		i += copy(dAtA[i:], m.PageKey)
	}
	if len(m.SourceTicket) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.SourceTicket)))
		i += copy(dAtA[i:], m.SourceTicket)
	}
	if m.EdgesGroup != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.EdgesGroup.Size()))
		n6, err := m.EdgesGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *FileDirectory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDirectory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subdirectory) > 0 {
		for _, s := range m.Subdirectory {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.FileTicket) > 0 {
		for _, s := range m.FileTicket {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CorpusRoots) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorpusRoots) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Corpus) > 0 {
		for _, msg := range m.Corpus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CorpusRoots_Corpus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorpusRoots_Corpus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Corpus) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Corpus)))
		i += copy(dAtA[i:], m.Corpus)
	}
	if len(m.Root) > 0 {
		for _, s := range m.Root {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Encoding) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Encoding)))
		i += copy(dAtA[i:], m.Encoding)
	}
	return i, nil
}

func (m *RawAnchor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawAnchor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if m.StartOffset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.StartOffset))
	}
	if m.EndOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.EndOffset))
	}
	if m.SnippetStart != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.SnippetStart))
	}
	if m.SnippetEnd != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.SnippetEnd))
	}
	return i, nil
}

func (m *ExpandedAnchor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpandedAnchor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Span != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Span.Size()))
		n7, err := m.Span.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Snippet) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Snippet)))
		i += copy(dAtA[i:], m.Snippet)
	}
	if m.SnippetSpan != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.SnippetSpan.Size()))
		n8, err := m.SnippetSpan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Definition) > 0 {
		for _, s := range m.Definition {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MarkedSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkedSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Kind))
	}
	if len(m.PreText) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PreText)))
		i += copy(dAtA[i:], m.PreText)
	}
	if len(m.Child) > 0 {
		for _, msg := range m.Child {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PostChildText) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PostChildText)))
		i += copy(dAtA[i:], m.PostChildText)
	}
	if len(m.PostText) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PostText)))
		i += copy(dAtA[i:], m.PostText)
	}
	if m.LookupIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.LookupIndex))
	}
	if m.DefaultChildrenCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.DefaultChildrenCount))
	}
	if m.AddFinalListToken {
		dAtA[i] = 0x50
		i++
		if m.AddFinalListToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Link) > 0 {
		for _, msg := range m.Link {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileDecorations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDecorations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.File.Size()))
		n9, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Decoration) > 0 {
		for _, msg := range m.Decoration {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TargetDefinitions) > 0 {
		for _, msg := range m.TargetDefinitions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Target) > 0 {
		for _, msg := range m.Target {
			dAtA[i] = 0x22
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TargetOverride) > 0 {
		for _, msg := range m.TargetOverride {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileDecorations_Decoration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDecorations_Decoration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Anchor.Size()))
		n10, err := m.Anchor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.TargetDefinition) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.TargetDefinition)))
		i += copy(dAtA[i:], m.TargetDefinition)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	return i, nil
}

func (m *FileDecorations_Override) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDecorations_Override) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Overriding) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Overriding)))
		i += copy(dAtA[i:], m.Overriding)
	}
	if len(m.Overridden) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Overridden)))
		i += copy(dAtA[i:], m.Overridden)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Kind))
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.MarkedSource.Size()))
		n11, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.OverriddenDefinition) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.OverriddenDefinition)))
		i += copy(dAtA[i:], m.OverriddenDefinition)
	}
	return i, nil
}

func (m *PagedCrossReferences) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedCrossReferences) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTicket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.SourceTicket)))
		i += copy(dAtA[i:], m.SourceTicket)
	}
	if len(m.Group) > 0 {
		for _, msg := range m.Group {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PageIndex) > 0 {
		for _, msg := range m.PageIndex {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalReferences != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.TotalReferences))
	}
	if m.Incomplete {
		dAtA[i] = 0x28
		i++
		if m.Incomplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.MarkedSource.Size()))
		n12, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.MergeWith) > 0 {
		for _, s := range m.MergeWith {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Feature) > 0 {
		dAtA14 := make([]byte, len(m.Feature)*10)
		var j13 int
		for _, num := range m.Feature {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintServing(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *PagedCrossReferences_RelatedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedCrossReferences_RelatedNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Node.Size()))
		n15, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *PagedCrossReferences_Caller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedCrossReferences_Caller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Caller != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Caller.Size()))
		n16, err := m.Caller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.SemanticCaller) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.SemanticCaller)))
		i += copy(dAtA[i:], m.SemanticCaller)
	}
	if m.MarkedSource != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.MarkedSource.Size()))
		n17, err := m.MarkedSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Callsite) > 0 {
		for _, msg := range m.Callsite {
			dAtA[i] = 0x22
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PagedCrossReferences_Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedCrossReferences_Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Anchor) > 0 {
		for _, msg := range m.Anchor {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RelatedNode) > 0 {
		for _, msg := range m.RelatedNode {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Caller) > 0 {
		for _, msg := range m.Caller {
			dAtA[i] = 0x22
			i++
			i = encodeVarintServing(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PagedCrossReferences_Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedCrossReferences_Page) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PageKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PageKey)))
		i += copy(dAtA[i:], m.PageKey)
	}
	if len(m.SourceTicket) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.SourceTicket)))
		i += copy(dAtA[i:], m.SourceTicket)
	}
	if m.Group != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Group.Size()))
		n18, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *PagedCrossReferences_PageIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PagedCrossReferences_PageIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServing(dAtA, i, uint64(m.Count))
	}
	if len(m.PageKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServing(dAtA, i, uint64(len(m.PageKey)))
		i += copy(dAtA[i:], m.PageKey)
	}
	return i, nil
}

func encodeFixed64Serving(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Serving(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintServing(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Fact) > 0 {
		for _, e := range m.Fact {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.DefinitionLocation != nil {
		l = m.DefinitionLocation.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *Edge) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Fact) > 0 {
		for _, e := range m.Fact {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.Ordinal != 0 {
		n += 1 + sovServing(uint64(m.Ordinal))
	}
	return n
}

func (m *EdgeGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Edge) > 0 {
		for _, e := range m.Edge {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *EdgeGroup_Edge) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovServing(uint64(m.Ordinal))
	}
	return n
}

func (m *PagedEdgeSet) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.TotalEdges != 0 {
		n += 1 + sovServing(uint64(m.TotalEdges))
	}
	if len(m.PageIndex) > 0 {
		for _, e := range m.PageIndex {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *PageIndex) Size() (n int) {
	var l int
	_ = l
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.EdgeCount != 0 {
		n += 1 + sovServing(uint64(m.EdgeCount))
	}
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *EdgePage) Size() (n int) {
	var l int
	_ = l
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.EdgesGroup != nil {
		l = m.EdgesGroup.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *FileDirectory) Size() (n int) {
	var l int
	_ = l
	if len(m.Subdirectory) > 0 {
		for _, s := range m.Subdirectory {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.FileTicket) > 0 {
		for _, s := range m.FileTicket {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *CorpusRoots) Size() (n int) {
	var l int
	_ = l
	if len(m.Corpus) > 0 {
		for _, e := range m.Corpus {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *CorpusRoots_Corpus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Corpus)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Root) > 0 {
		for _, s := range m.Root {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *RawAnchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.StartOffset != 0 {
		n += 1 + sovServing(uint64(m.StartOffset))
	}
	if m.EndOffset != 0 {
		n += 1 + sovServing(uint64(m.EndOffset))
	}
	if m.SnippetStart != 0 {
		n += 1 + sovServing(uint64(m.SnippetStart))
	}
	if m.SnippetEnd != 0 {
		n += 1 + sovServing(uint64(m.SnippetEnd))
	}
	return n
}

func (m *ExpandedAnchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Snippet)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.SnippetSpan != nil {
		l = m.SnippetSpan.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *Link) Size() (n int) {
	var l int
	_ = l
	if len(m.Definition) > 0 {
		for _, s := range m.Definition {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *MarkedSource) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovServing(uint64(m.Kind))
	}
	l = len(m.PreText)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Child) > 0 {
		for _, e := range m.Child {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	l = len(m.PostChildText)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.PostText)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.LookupIndex != 0 {
		n += 1 + sovServing(uint64(m.LookupIndex))
	}
	if m.DefaultChildrenCount != 0 {
		n += 1 + sovServing(uint64(m.DefaultChildrenCount))
	}
	if m.AddFinalListToken {
		n += 2
	}
	if len(m.Link) > 0 {
		for _, e := range m.Link {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *FileDecorations) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Decoration) > 0 {
		for _, e := range m.Decoration {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.TargetDefinitions) > 0 {
		for _, e := range m.TargetDefinitions {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.Target) > 0 {
		for _, e := range m.Target {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.TargetOverride) > 0 {
		for _, e := range m.TargetOverride {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *FileDecorations_Decoration) Size() (n int) {
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.TargetDefinition)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *FileDecorations_Override) Size() (n int) {
	var l int
	_ = l
	l = len(m.Overriding)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Overridden)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovServing(uint64(m.Kind))
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.OverriddenDefinition)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *PagedCrossReferences) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.PageIndex) > 0 {
		for _, e := range m.PageIndex {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.TotalReferences != 0 {
		n += 1 + sovServing(uint64(m.TotalReferences))
	}
	if m.Incomplete {
		n += 2
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.MergeWith) > 0 {
		for _, s := range m.MergeWith {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.Feature) > 0 {
		l = 0
		for _, e := range m.Feature {
			l += sovServing(uint64(e))
		}
		n += 1 + sovServing(uint64(l)) + l
	}
	return n
}

func (m *PagedCrossReferences_RelatedNode) Size() (n int) {
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovServing(uint64(m.Ordinal))
	}
	return n
}

func (m *PagedCrossReferences_Caller) Size() (n int) {
	var l int
	_ = l
	if m.Caller != nil {
		l = m.Caller.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.SemanticCaller)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.MarkedSource != nil {
		l = m.MarkedSource.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Callsite) > 0 {
		for _, e := range m.Callsite {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *PagedCrossReferences_Group) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Anchor) > 0 {
		for _, e := range m.Anchor {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.RelatedNode) > 0 {
		for _, e := range m.RelatedNode {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.Caller) > 0 {
		for _, e := range m.Caller {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *PagedCrossReferences_Page) Size() (n int) {
	var l int
	_ = l
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *PagedCrossReferences_PageIndex) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovServing(uint64(m.Count))
	}
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func sovServing(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozServing(x uint64) (n int) {
	return sovServing(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fact = append(m.Fact, &kythe_proto_common.Fact{})
			if err := m.Fact[len(m.Fact)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinitionLocation == nil {
				m.DefinitionLocation = &ExpandedAnchor{}
			}
			if err := m.DefinitionLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Node{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Node{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fact = append(m.Fact, &kythe_proto_common.Fact{})
			if err := m.Fact[len(m.Fact)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edge = append(m.Edge, &EdgeGroup_Edge{})
			if err := m.Edge[len(m.Edge)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeGroup_Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Node{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedEdgeSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PagedEdgeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PagedEdgeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Node{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &EdgeGroup{})
			if err := m.Group[len(m.Group)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEdges", wireType)
			}
			m.TotalEdges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalEdges |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageIndex = append(m.PageIndex, &PageIndex{})
			if err := m.PageIndex[len(m.PageIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeCount", wireType)
			}
			m.EdgeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgePage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgePage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgePage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgesGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EdgesGroup == nil {
				m.EdgesGroup = &EdgeGroup{}
			}
			if err := m.EdgesGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDirectory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDirectory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDirectory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdirectory = append(m.Subdirectory, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileTicket = append(m.FileTicket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorpusRoots) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorpusRoots: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorpusRoots: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Corpus = append(m.Corpus, &CorpusRoots_Corpus{})
			if err := m.Corpus[len(m.Corpus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorpusRoots_Corpus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Corpus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Corpus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Corpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text[:0], dAtA[iNdEx:postIndex]...)
			if m.Text == nil {
				m.Text = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawAnchor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawAnchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawAnchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOffset", wireType)
			}
			m.StartOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetStart", wireType)
			}
			m.SnippetStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnippetStart |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetEnd", wireType)
			}
			m.SnippetEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnippetEnd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpandedAnchor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpandedAnchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpandedAnchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Span == nil {
				m.Span = &kythe_proto_common.Span{}
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snippet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetSpan == nil {
				m.SnippetSpan = &kythe_proto_common.Span{}
			}
			if err := m.SnippetSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkedSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkedSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkedSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (MarkedSource_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Child = append(m.Child, &MarkedSource{})
			if err := m.Child[len(m.Child)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostChildText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostChildText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupIndex", wireType)
			}
			m.LookupIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookupIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultChildrenCount", wireType)
			}
			m.DefaultChildrenCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultChildrenCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFinalListToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddFinalListToken = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = append(m.Link, &Link{})
			if err := m.Link[len(m.Link)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDecorations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDecorations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDecorations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decoration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Decoration = append(m.Decoration, &FileDecorations_Decoration{})
			if err := m.Decoration[len(m.Decoration)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetDefinitions = append(m.TargetDefinitions, &ExpandedAnchor{})
			if err := m.TargetDefinitions[len(m.TargetDefinitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target, &Node{})
			if err := m.Target[len(m.Target)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetOverride = append(m.TargetOverride, &FileDecorations_Override{})
			if err := m.TargetOverride[len(m.TargetOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDecorations_Decoration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decoration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decoration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &RawAnchor{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetDefinition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDecorations_Override) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Override: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Override: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overriding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overriding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overridden", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overridden = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (FileDecorations_Override_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverriddenDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverriddenDefinition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PagedCrossReferences: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PagedCrossReferences: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &PagedCrossReferences_Group{})
			if err := m.Group[len(m.Group)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageIndex = append(m.PageIndex, &PagedCrossReferences_PageIndex{})
			if err := m.PageIndex[len(m.PageIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReferences", wireType)
			}
			m.TotalReferences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalReferences |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incomplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incomplete = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MergeWith = append(m.MergeWith, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v PagedCrossReferences_Feature
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServing
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (PagedCrossReferences_Feature(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Feature = append(m.Feature, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServing
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServing
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v PagedCrossReferences_Feature
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServing
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (PagedCrossReferences_Feature(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Feature = append(m.Feature, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_RelatedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_Caller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Caller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Caller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Caller == nil {
				m.Caller = &ExpandedAnchor{}
			}
			if err := m.Caller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticCaller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticCaller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkedSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkedSource == nil {
				m.MarkedSource = &MarkedSource{}
			}
			if err := m.MarkedSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callsite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callsite = append(m.Callsite, &ExpandedAnchor{})
			if err := m.Callsite[len(m.Callsite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Anchor = append(m.Anchor, &ExpandedAnchor{})
			if err := m.Anchor[len(m.Anchor)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedNode = append(m.RelatedNode, &PagedCrossReferences_RelatedNode{})
			if err := m.RelatedNode[len(m.RelatedNode)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = append(m.Caller, &PagedCrossReferences_Caller{})
			if err := m.Caller[len(m.Caller)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &PagedCrossReferences_Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_PageIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServing(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServing
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthServing
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowServing
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipServing(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthServing = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServing   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kythe/proto/serving.proto", fileDescriptorServing) }

var fileDescriptorServing = []byte{
	// 1710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x0f, 0x2d, 0xea, 0xdf, 0x93, 0x64, 0xd3, 0x13, 0x77, 0xc1, 0x68, 0x11, 0xaf, 0xc3, 0x05,
	0x12, 0x17, 0xbb, 0x91, 0x1b, 0x27, 0xed, 0x02, 0x0d, 0x8a, 0x40, 0x91, 0xa8, 0xae, 0x6a, 0x45,
	0x32, 0x46, 0x4c, 0x36, 0xdb, 0x0b, 0xc1, 0x90, 0x23, 0x99, 0x10, 0xc5, 0x11, 0x48, 0x2a, 0x9b,
	0xdc, 0x7b, 0x2b, 0x7a, 0xef, 0xa5, 0x97, 0x5e, 0x8b, 0x9e, 0x7a, 0xe8, 0x37, 0x28, 0x72, 0xec,
	0xa9, 0x2d, 0xd0, 0x4b, 0x91, 0x7e, 0x88, 0x5e, 0x7a, 0x28, 0xe6, 0x0f, 0x25, 0x2a, 0x96, 0x1c,
	0xd5, 0xd8, 0x13, 0x67, 0xde, 0xbc, 0xf7, 0xe6, 0xbd, 0xdf, 0x9b, 0xf9, 0xcd, 0x23, 0xdc, 0x9a,
	0xbc, 0x4d, 0x2e, 0xc8, 0xc9, 0x2c, 0xa2, 0x09, 0x3d, 0x89, 0x49, 0xf4, 0xda, 0x0f, 0xc7, 0x0d,
	0x3e, 0x43, 0x37, 0xf9, 0x92, 0x98, 0x34, 0xe4, 0x52, 0x5d, 0xcf, 0xea, 0xbb, 0x74, 0x3a, 0xa5,
	0xa1, 0xd0, 0x30, 0x7e, 0xaf, 0x80, 0xda, 0xa7, 0x1e, 0x41, 0x9f, 0x40, 0x21, 0xf1, 0xdd, 0x09,
	0x49, 0x74, 0xe5, 0x48, 0x39, 0x2e, 0x63, 0x39, 0x43, 0x5f, 0x82, 0x3a, 0x72, 0xdc, 0x44, 0xdf,
	0x39, 0xca, 0x1d, 0x57, 0x4e, 0xf5, 0x46, 0xd6, 0xbd, 0xf4, 0xd4, 0x71, 0xdc, 0x04, 0x73, 0x2d,
	0x64, 0xc1, 0x4d, 0x8f, 0x8c, 0xfc, 0xd0, 0x4f, 0x7c, 0x1a, 0xda, 0x01, 0x75, 0x1d, 0x36, 0xd0,
	0x73, 0x47, 0xca, 0x71, 0xe5, 0xf4, 0xf3, 0xc6, 0x9a, 0xd8, 0x1a, 0xe6, 0x9b, 0x99, 0x13, 0x7a,
	0xc4, 0x6b, 0x86, 0xee, 0x05, 0x8d, 0x30, 0x5a, 0xda, 0xf7, 0xa4, 0xb9, 0xf1, 0x4e, 0x01, 0xd5,
	0xf4, 0xc6, 0x04, 0x3d, 0x80, 0x42, 0x4c, 0xe7, 0x91, 0x4b, 0x78, 0x90, 0x95, 0xd3, 0x5b, 0x6b,
	0x3d, 0xb2, 0x7c, 0xb0, 0x54, 0x44, 0x08, 0xd4, 0x89, 0x1f, 0x7a, 0xfa, 0x0e, 0xcf, 0x8a, 0x8f,
	0x99, 0x9b, 0xc4, 0x89, 0xc6, 0x24, 0x91, 0x81, 0x5d, 0xe5, 0x46, 0x28, 0x2e, 0x60, 0x50, 0xb7,
	0x82, 0x41, 0x87, 0x22, 0x8d, 0x3c, 0x3f, 0x74, 0x02, 0x3d, 0x7f, 0xa4, 0x1c, 0xe7, 0x71, 0x3a,
	0x35, 0xfe, 0xa8, 0x40, 0x99, 0xa5, 0xf2, 0xf3, 0x88, 0xce, 0x67, 0x8b, 0xe0, 0x94, 0x4c, 0x70,
	0x5f, 0x81, 0x4a, 0xbc, 0x31, 0x91, 0x80, 0x6f, 0xc0, 0x2c, 0xf5, 0xc0, 0x47, 0x98, 0x1b, 0xd4,
	0x87, 0x4b, 0x90, 0x64, 0x76, 0xca, 0xb6, 0xd9, 0x65, 0xe2, 0xdd, 0x59, 0x8d, 0xf7, 0xef, 0x0a,
	0x54, 0xcf, 0x9d, 0x31, 0xf1, 0x98, 0xeb, 0x21, 0x49, 0xae, 0x53, 0x82, 0x47, 0x90, 0x1f, 0xb3,
	0x60, 0x65, 0x4a, 0x87, 0x57, 0xa7, 0x84, 0x85, 0x32, 0xfa, 0x0c, 0x2a, 0x09, 0x4d, 0x9c, 0xc0,
	0x66, 0xc9, 0xc5, 0xbc, 0x52, 0x79, 0x0c, 0x5c, 0xc4, 0x74, 0x63, 0xf4, 0x33, 0x80, 0x99, 0x33,
	0x26, 0xb6, 0x1f, 0x7a, 0xe4, 0x8d, 0x2c, 0xcc, 0x7a, 0xdf, 0x2c, 0x81, 0x2e, 0xd3, 0xc2, 0xe5,
	0x59, 0x3a, 0x34, 0x5e, 0x41, 0x79, 0x21, 0x47, 0x9f, 0x42, 0x99, 0x6d, 0x63, 0x67, 0xaa, 0x51,
	0x62, 0x82, 0x33, 0x56, 0x91, 0xdb, 0x00, 0x7c, 0xd1, 0xa5, 0xf3, 0x30, 0x91, 0x00, 0x71, 0xf5,
	0x16, 0x13, 0xa0, 0x5b, 0x50, 0xe2, 0x71, 0x4c, 0xc8, 0x5b, 0x1e, 0x65, 0x19, 0x17, 0xd9, 0xfc,
	0x8c, 0xbc, 0x35, 0x7e, 0xad, 0x40, 0x89, 0x05, 0xcb, 0x36, 0x5a, 0xd1, 0x53, 0x56, 0xf4, 0xd0,
	0xe7, 0x50, 0x13, 0x58, 0xd9, 0xf2, 0x0e, 0x8a, 0xd3, 0x5a, 0x15, 0x42, 0x4b, 0xdc, 0xc4, 0x27,
	0x50, 0xe1, 0x50, 0xd8, 0x02, 0x4c, 0x71, 0x74, 0x3f, 0x06, 0x26, 0x8f, 0x3c, 0xe6, 0x63, 0xc3,
	0x82, 0x5a, 0xc7, 0x0f, 0x48, 0xdb, 0x8f, 0x88, 0x9b, 0xd0, 0xe8, 0x2d, 0x32, 0xa0, 0x1a, 0xcf,
	0x5f, 0x79, 0xe9, 0x5c, 0x57, 0x8e, 0x72, 0x7c, 0xd7, 0x8c, 0x8c, 0x95, 0x61, 0xe4, 0x07, 0x99,
	0xc0, 0x98, 0x0a, 0x30, 0x91, 0x08, 0xcb, 0xf8, 0x95, 0x02, 0x95, 0x16, 0x8d, 0x66, 0xf3, 0x18,
	0x53, 0x9a, 0xc4, 0xe8, 0x09, 0x14, 0x5c, 0x3e, 0xe5, 0xee, 0x2a, 0xa7, 0xf7, 0xd6, 0x46, 0x98,
	0xb1, 0x48, 0xc7, 0xd2, 0xac, 0xfe, 0x08, 0x0a, 0x42, 0xc2, 0x38, 0x69, 0xe1, 0x8a, 0x73, 0x92,
	0x98, 0xb1, 0x6b, 0x13, 0x51, 0x9a, 0x06, 0xc3, 0xc7, 0x46, 0x1f, 0x54, 0x96, 0xdc, 0x46, 0x1e,
	0x43, 0xa0, 0x26, 0xe4, 0x8d, 0x40, 0xb6, 0x8a, 0xf9, 0x18, 0xd5, 0xa1, 0x44, 0x42, 0x97, 0x7a,
	0x7e, 0x38, 0x96, 0x95, 0x5b, 0xcc, 0x8d, 0x3f, 0x28, 0x50, 0xc6, 0xce, 0x77, 0x82, 0x95, 0x36,
	0x7a, 0xbd, 0x03, 0xd5, 0x38, 0x71, 0xa2, 0xc4, 0xa6, 0xa3, 0x51, 0x4c, 0xd2, 0xc3, 0x51, 0xe1,
	0xb2, 0x01, 0x17, 0xf1, 0xd3, 0x13, 0x7a, 0xa9, 0x42, 0x4e, 0x9e, 0x9e, 0xd0, 0x93, 0xcb, 0xac,
	0xf4, 0xa1, 0x3f, 0x9b, 0x91, 0xc4, 0xe6, 0x56, 0xba, 0xca, 0x35, 0xaa, 0x52, 0x38, 0x64, 0x32,
	0x56, 0x84, 0x54, 0x89, 0x84, 0x9e, 0xe4, 0x14, 0x90, 0x22, 0x33, 0xf4, 0x8c, 0x7f, 0x2a, 0xb0,
	0xbb, 0x4a, 0xa4, 0x57, 0x01, 0x71, 0x89, 0x10, 0x53, 0x70, 0x54, 0x21, 0xe3, 0xe0, 0x7c, 0x09,
	0x6a, 0x3c, 0x73, 0x42, 0xbe, 0xd9, 0x06, 0xc6, 0x1b, 0xce, 0x9c, 0x10, 0x73, 0x2d, 0xc6, 0x20,
	0x32, 0x1c, 0xbd, 0x20, 0xce, 0xb6, 0x9c, 0xa2, 0xc7, 0x50, 0x5d, 0x24, 0xc8, 0xfc, 0x15, 0x3f,
	0xe2, 0x2f, 0xcd, 0x94, 0x4d, 0x7e, 0xa1, 0x96, 0x72, 0x9a, 0x6a, 0xdc, 0x05, 0xb5, 0xe7, 0x87,
	0x13, 0x74, 0x08, 0xb0, 0x7c, 0x1d, 0xe4, 0x69, 0xcd, 0x48, 0x8c, 0xbf, 0xa9, 0x50, 0x7d, 0xe6,
	0x44, 0x13, 0xe2, 0x0d, 0x05, 0xf3, 0xfc, 0x34, 0xc3, 0xaf, 0xbb, 0xa7, 0x77, 0xd7, 0x9e, 0xc4,
	0xac, 0x41, 0x83, 0xdd, 0x77, 0x89, 0x09, 0xbb, 0xae, 0x11, 0xb1, 0x17, 0x87, 0x86, 0x5d, 0xd7,
	0x88, 0x58, 0x0c, 0x9a, 0xaf, 0x20, 0xef, 0x5e, 0xf8, 0x81, 0xa7, 0xe7, 0xf8, 0x09, 0xbf, 0xf3,
	0x51, 0xbf, 0x58, 0xe8, 0xa3, 0xbb, 0xb0, 0x37, 0xa3, 0x71, 0x62, 0xf3, 0x99, 0x9d, 0x81, 0xbc,
	0xc6, 0xc4, 0x2d, 0x26, 0xe5, 0x1b, 0x7c, 0x0a, 0x65, 0xae, 0xc7, 0x35, 0xf2, 0xe2, 0x64, 0x32,
	0x01, 0x5f, 0xbc, 0x03, 0xd5, 0x80, 0xd2, 0xc9, 0x7c, 0x26, 0x99, 0x8f, 0xe1, 0x5d, 0xc3, 0x15,
	0x21, 0x13, 0x74, 0xf6, 0x08, 0x3e, 0xf1, 0xc8, 0xc8, 0x99, 0x07, 0x72, 0xab, 0x88, 0x84, 0x92,
	0xbd, 0x8a, 0x5c, 0xf9, 0x40, 0xae, 0xb6, 0xe4, 0xa2, 0x20, 0xb2, 0x13, 0x38, 0x70, 0x3c, 0xcf,
	0x1e, 0x31, 0xe2, 0xb7, 0x03, 0x9f, 0xed, 0x4f, 0x27, 0x24, 0xd4, 0xe1, 0x48, 0x39, 0x2e, 0xe1,
	0x7d, 0xc7, 0xf3, 0x3a, 0x6c, 0xa9, 0xe7, 0xc7, 0x89, 0xc5, 0x16, 0xd0, 0x7d, 0x50, 0x03, 0x3f,
	0x9c, 0xe8, 0x15, 0x0e, 0xc3, 0xfa, 0x97, 0x80, 0x15, 0x0e, 0x73, 0x35, 0xe3, 0xcf, 0x0a, 0xa8,
	0x9c, 0x50, 0x8b, 0x90, 0x7b, 0x3a, 0x78, 0xa9, 0xdd, 0x40, 0x25, 0x50, 0xad, 0x6f, 0xcf, 0x4d,
	0x4d, 0x41, 0x35, 0x28, 0x9f, 0x37, 0x71, 0xf3, 0x99, 0x69, 0x99, 0x58, 0xdb, 0x41, 0xbb, 0x00,
	0xdd, 0xb6, 0xd9, 0xb7, 0xba, 0x9d, 0xae, 0x89, 0xb5, 0x1c, 0xaa, 0x40, 0xb1, 0x35, 0xe8, 0x5b,
	0xe6, 0x4b, 0x4b, 0x53, 0xd1, 0x1e, 0x54, 0xba, 0xfd, 0xae, 0xd5, 0x6d, 0xf6, 0xba, 0xbf, 0x34,
	0xb1, 0x96, 0x47, 0xb7, 0xe1, 0xd6, 0xc2, 0xd8, 0xee, 0x0d, 0x06, 0x67, 0xcf, 0xcf, 0xed, 0xa7,
	0xdf, 0xda, 0x5c, 0xa6, 0x15, 0xd0, 0x4d, 0xd8, 0xfb, 0x50, 0x58, 0x44, 0x5f, 0xc0, 0xbd, 0x8d,
	0x36, 0xf6, 0x37, 0x5d, 0xeb, 0x6b, 0xbb, 0x6d, 0x76, 0x9a, 0xcf, 0x7b, 0xd6, 0x50, 0x2b, 0x19,
	0x7f, 0x29, 0xc0, 0x1e, 0xa7, 0x4e, 0xe2, 0xd2, 0x88, 0xf7, 0x24, 0x31, 0x4b, 0x9e, 0xb1, 0xe0,
	0x95, 0xcf, 0x20, 0xb3, 0xc1, 0x5c, 0x0d, 0x0d, 0xd8, 0xd9, 0x4d, 0xad, 0xe5, 0x4b, 0x78, 0xb2,
	0xd1, 0x28, 0xb3, 0x51, 0x63, 0x39, 0xc6, 0x19, 0x17, 0x08, 0x03, 0x12, 0xaf, 0xb7, 0xbd, 0xbc,
	0x01, 0xb1, 0x3c, 0x91, 0x5b, 0x75, 0x5a, 0xfb, 0xc2, 0xbc, 0xbd, 0xb4, 0xce, 0xb4, 0x0e, 0xea,
	0x15, 0x25, 0x5d, 0x69, 0x1d, 0x5e, 0xc0, 0x9e, 0x0c, 0x83, 0xbe, 0x26, 0x51, 0xe4, 0x7b, 0x44,
	0xcf, 0x73, 0xdb, 0xfb, 0x5b, 0x25, 0x37, 0x90, 0x46, 0x78, 0x57, 0x78, 0x49, 0xe7, 0xf5, 0xdf,
	0x29, 0x00, 0x4b, 0x45, 0xf4, 0x13, 0x28, 0x38, 0x3c, 0x6c, 0x89, 0xf7, 0xfa, 0x77, 0x6f, 0x41,
	0xd8, 0x58, 0x6a, 0xaf, 0x65, 0xbb, 0x2f, 0x60, 0xff, 0x12, 0x72, 0xf2, 0x1e, 0x6a, 0x1f, 0x62,
	0xc2, 0x69, 0x54, 0x40, 0x92, 0x97, 0x34, 0xca, 0x67, 0xf5, 0x3f, 0xed, 0x40, 0x29, 0x0d, 0x96,
	0x11, 0x93, 0xcc, 0x9e, 0x3d, 0x25, 0x82, 0x6f, 0x33, 0x92, 0xcc, 0xba, 0x47, 0x42, 0x19, 0x4b,
	0x46, 0x82, 0x3a, 0x32, 0xca, 0x1c, 0xe7, 0xa9, 0xd3, 0xff, 0x0b, 0xb9, 0x2c, 0x67, 0x75, 0xa0,
	0x36, 0xe5, 0xb4, 0x63, 0xcb, 0x1e, 0x4d, 0xe5, 0x60, 0x6d, 0x41, 0x50, 0xd5, 0x69, 0x96, 0x37,
	0x1f, 0xc2, 0x0f, 0x96, 0xd1, 0x65, 0x51, 0x12, 0x18, 0x1c, 0x2c, 0x17, 0x97, 0x48, 0x19, 0x86,
	0xbc, 0xdd, 0x35, 0x28, 0x0f, 0x5e, 0x98, 0x18, 0x77, 0xdb, 0xe6, 0x50, 0xbb, 0xc1, 0xae, 0xae,
	0xf9, 0xd2, 0x32, 0xfb, 0xed, 0xa1, 0xa6, 0x18, 0xff, 0x00, 0x38, 0xe0, 0xed, 0x64, 0x2b, 0xa2,
	0x71, 0x8c, 0xc9, 0x88, 0x44, 0x24, 0x74, 0x49, 0x7c, 0xb9, 0x03, 0x52, 0xd6, 0x74, 0x40, 0xe6,
	0x6a, 0x23, 0x79, 0xb2, 0xb1, 0xd9, 0xfb, 0xd0, 0x7d, 0x63, 0xa5, 0xb3, 0xc4, 0x2b, 0x8d, 0xa3,
	0xb8, 0x31, 0x0f, 0xb7, 0xf7, 0xb5, 0xae, 0x9b, 0x44, 0x3f, 0x04, 0x4d, 0x74, 0xab, 0xd1, 0x42,
	0x51, 0xbe, 0xe4, 0x7b, 0x5c, 0x9e, 0x49, 0xf5, 0x10, 0xc0, 0x0f, 0x5d, 0x3a, 0x9d, 0x05, 0x24,
	0x21, 0x1c, 0xd1, 0x12, 0xce, 0x48, 0x2e, 0x17, 0xb1, 0x70, 0xbd, 0x22, 0xde, 0x06, 0x98, 0x92,
	0x68, 0x4c, 0xec, 0xef, 0xfc, 0xe4, 0x42, 0x2f, 0xf2, 0xd7, 0xb2, 0xcc, 0x25, 0xdf, 0xf8, 0xc9,
	0x05, 0x3a, 0x83, 0xe2, 0x88, 0x38, 0xc9, 0x3c, 0x22, 0x3a, 0x1c, 0xe5, 0x8e, 0x77, 0x4f, 0x1f,
	0x6c, 0x0f, 0x41, 0x47, 0x18, 0xe2, 0xd4, 0x43, 0xfd, 0x05, 0x54, 0x30, 0x09, 0x9c, 0x84, 0x78,
	0xfc, 0x67, 0xf2, 0x3e, 0xa8, 0x21, 0xf5, 0xb6, 0xf8, 0x45, 0xe0, 0x6a, 0x9b, 0x7f, 0x3f, 0xea,
	0xff, 0x51, 0xa0, 0xd0, 0x72, 0x82, 0x80, 0x44, 0xe8, 0x31, 0x14, 0x5c, 0x3e, 0x92, 0x5e, 0xb7,
	0xe2, 0x38, 0x69, 0x82, 0xee, 0xc1, 0x5e, 0x4c, 0xa6, 0x4e, 0x98, 0xf8, 0xae, 0x2d, 0xbd, 0x88,
	0x5b, 0xb8, 0x9b, 0x8a, 0xe5, 0x2e, 0x97, 0xc0, 0xcf, 0x5d, 0x0f, 0xfc, 0x27, 0x50, 0x62, 0xfb,
	0xc4, 0x7e, 0x42, 0x24, 0x97, 0x6e, 0x15, 0xef, 0xc2, 0xa8, 0xfe, 0x5f, 0x05, 0xf2, 0x9b, 0x7f,
	0x12, 0x1f, 0x2f, 0xe8, 0x70, 0x67, 0x7b, 0xe7, 0x29, 0x27, 0xbe, 0x84, 0x6a, 0x24, 0x8a, 0x65,
	0xf3, 0x2a, 0x89, 0x1b, 0xf0, 0xe3, 0xed, 0xcb, 0x9f, 0x29, 0x35, 0xae, 0x44, 0x99, 0xba, 0x7f,
	0xbd, 0xa8, 0x91, 0xc8, 0xf9, 0x47, 0xdb, 0xfb, 0x14, 0xf8, 0xa7, 0x05, 0xab, 0xff, 0x46, 0x01,
	0xf5, 0x7b, 0xf9, 0x6b, 0x5a, 0x70, 0x86, 0x28, 0xe4, 0x35, 0x39, 0xa3, 0x7e, 0x9e, 0xfd, 0x5b,
	0x5c, 0x57, 0x91, 0x03, 0xc8, 0x67, 0xff, 0x0f, 0xc5, 0xe4, 0xaa, 0x7f, 0xc3, 0x3e, 0x14, 0xe5,
	0x35, 0x42, 0xfb, 0x50, 0xc3, 0x66, 0xaf, 0x69, 0x99, 0x6d, 0xbb, 0x3f, 0x10, 0xac, 0xb9, 0x0f,
	0xb5, 0x67, 0x4d, 0x7c, 0x66, 0xb6, 0xed, 0xe1, 0xe0, 0x39, 0x6e, 0xb1, 0x16, 0x89, 0xf5, 0x40,
	0xcd, 0x5e, 0xcf, 0xc4, 0x43, 0x6d, 0x07, 0x69, 0x50, 0x6d, 0x9b, 0xad, 0x5e, 0x13, 0x37, 0xad,
	0xee, 0xa0, 0x3f, 0xd4, 0x72, 0x4f, 0x1f, 0xbc, 0x7b, 0x7f, 0xa8, 0xfc, 0xf5, 0xfd, 0xa1, 0xf2,
	0xaf, 0xf7, 0x87, 0xca, 0x6f, 0xff, 0x7d, 0x78, 0x03, 0x3e, 0x73, 0xe9, 0xb4, 0x31, 0xa6, 0x74,
	0x1c, 0x90, 0x86, 0x47, 0x5e, 0x27, 0x94, 0x06, 0x71, 0x36, 0xfd, 0x57, 0x05, 0xfe, 0x79, 0xf8,
	0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2d, 0x8a, 0xc0, 0x08, 0x4f, 0x12, 0x00, 0x00,
}
