// Code generated by protoc-gen-go.
// source: kythe/proto/storage.proto
// DO NOT EDIT!

/*
Package storage_proto is a generated protocol buffer package.

It is generated from these files:
	kythe/proto/storage.proto

It has these top-level messages:
	VName
	Entry
	Entries
	ReadRequest
	WriteRequest
	WriteReply
	ScanRequest
	CountRequest
	CountReply
	ShardRequest
	SearchRequest
	SearchReply
*/
package storage_proto

import proto "github.com/golang/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

// VName is a proto representation of a vector name.
//
// Rules:
//  - All fields must be optional, and must have default values.
//  - No field may ever be removed.  If a field is deprecated, it may be
//    renamed or marked with a comment, but must not be deleted.
//  - New fields are always added to the end of the message.
//  - All fields must be strings, not messages.
//
// One of the key principles is that we want as few fields as possible in a
// vname.  We're not trying to exhaust the possible dimensions along which a
// name could vary, but to find a minimal basis. Be conservative.
type VName struct {
	// A language-specific signature assigned by the analyzer.
	// e.g., "com.google.common.collect.Lists.newLinkedList<#1>()"
	Signature string `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
	// The corpus this name belongs to.
	// e.g., "kythe", "chromium", "github.com/creachadair/imath", "aosp"
	// The corpus label "kythe" is reserved for internal use.
	Corpus string `protobuf:"bytes,2,opt,name=corpus" json:"corpus,omitempty"`
	// A corpus-specific root label, designating a subordinate collection within
	// the corpus.  If a corpus stores files in unrelated directory structures,
	// for example, the root can be used to distinguish them.  Or, of a corpus
	// incorporates subprojects, the root can be a project ID that it governs.
	// This may also be used to distinguish virtual subgroups of a corpus such as
	// generated files.
	Root string `protobuf:"bytes,3,opt,name=root" json:"root,omitempty"`
	// A path-structured label describing the location of this object relative to
	// the corpus and the root.  For code, this will generally be the relative
	// path to the file containing the code, e.g., "storage/service.go" in kythe.
	//
	// However, this need not be a true file path; virtual objects like figments
	// can assign an ad-hoc abstract ID, or omit it entirely.
	//
	// Examples:
	//   "devools/kythe/platform/go/datastore.go" (a file)
	//   "type/cpp/void.cc" (a type figment)
	Path string `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// The language this name belongs to.
	// e.g., "c++", "python", "elisp", "haskell", "java"
	//
	// The schema will define specific labels for each supported language, so we
	// don't wind up with a confusion of names like "cxx", "cpp", "C++", etc.
	// Prototype: Official language name converted to lowercase.  If a version
	// number is necessary, include it, e.g., "python3".
	Language string `protobuf:"bytes,5,opt,name=language" json:"language,omitempty"`
}

func (m *VName) Reset()         { *m = VName{} }
func (m *VName) String() string { return proto.CompactTextString(m) }
func (*VName) ProtoMessage()    {}

// An Entry associates a fact with a graph object (node or edge).  This is the
// the primary unit of storage.
type Entry struct {
	Source *VName `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// The following two fields must either be both empty, or both nonempty.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind" json:"edge_kind,omitempty"`
	Target   *VName `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	// The grammar for fact_name:
	//  name   = "/" | 1*path
	//  path   = "/" word
	//  word   = 1*{LETTER|DIGIT|PUNCT}
	//  LETTER = [A-Za-z]
	//  DIGIT  = [0-9]
	//  PUNCT  = [-.@#$%&_+:()]
	FactName  string `protobuf:"bytes,4,opt,name=fact_name" json:"fact_name,omitempty"`
	FactValue []byte `protobuf:"bytes,5,opt,name=fact_value,proto3" json:"fact_value,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}

func (m *Entry) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Entry) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

// A collection of Entry instances.
type Entries struct {
	Entries []*Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *Entries) Reset()         { *m = Entries{} }
func (m *Entries) String() string { return proto.CompactTextString(m) }
func (*Entries) ProtoMessage()    {}

func (m *Entries) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Request for a stream of Entry objects from a GraphStore.  Read operations
// should be implemented with time complexity proportional to the size of the
// return set.
type ReadRequest struct {
	// Return entries having this source VName, which may not be empty.
	Source *VName `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Return entries having this edge kind; if empty, only entries with an empty
	// edge kind are returned; if "*", entries of any edge kind are returned.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind" json:"edge_kind,omitempty"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}

func (m *ReadRequest) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

// Request to write Entry objects to a GraphStore
type WriteRequest struct {
	Source *VName                 `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Update []*WriteRequest_Update `protobuf:"bytes,2,rep,name=update" json:"update,omitempty"`
}

func (m *WriteRequest) Reset()         { *m = WriteRequest{} }
func (m *WriteRequest) String() string { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()    {}

func (m *WriteRequest) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *WriteRequest) GetUpdate() []*WriteRequest_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

type WriteRequest_Update struct {
	EdgeKind  string `protobuf:"bytes,1,opt,name=edge_kind" json:"edge_kind,omitempty"`
	Target    *VName `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	FactName  string `protobuf:"bytes,3,opt,name=fact_name" json:"fact_name,omitempty"`
	FactValue []byte `protobuf:"bytes,4,opt,name=fact_value,proto3" json:"fact_value,omitempty"`
}

func (m *WriteRequest_Update) Reset()         { *m = WriteRequest_Update{} }
func (m *WriteRequest_Update) String() string { return proto.CompactTextString(m) }
func (*WriteRequest_Update) ProtoMessage()    {}

func (m *WriteRequest_Update) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

// Response to a WriteRequest
type WriteReply struct {
}

func (m *WriteReply) Reset()         { *m = WriteReply{} }
func (m *WriteReply) String() string { return proto.CompactTextString(m) }
func (*WriteReply) ProtoMessage()    {}

// Request for a stream of Entry objects resulting from a full scan of a
// GraphStore.
type ScanRequest struct {
	// Return entries having this target VName; if empty, any target field is
	// matched, including empty.
	Target *VName `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// Return entries having this kind; if empty, any kind is matched, including
	// empty.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind" json:"edge_kind,omitempty"`
	// Return entries having fact labels with this prefix; if empty, any fact
	// label is matched,
	FactPrefix string `protobuf:"bytes,3,opt,name=fact_prefix" json:"fact_prefix,omitempty"`
}

func (m *ScanRequest) Reset()         { *m = ScanRequest{} }
func (m *ScanRequest) String() string { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()    {}

func (m *ScanRequest) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

// Request for the size of the shard at the given index.
type CountRequest struct {
	Index  int64 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Shards int64 `protobuf:"varint,2,opt,name=shards" json:"shards,omitempty"`
}

func (m *CountRequest) Reset()         { *m = CountRequest{} }
func (m *CountRequest) String() string { return proto.CompactTextString(m) }
func (*CountRequest) ProtoMessage()    {}

// Response for a CountRequest
type CountReply struct {
	// Total number of entries in the specified shard.
	Entries int64 `protobuf:"varint,1,opt,name=entries" json:"entries,omitempty"`
}

func (m *CountReply) Reset()         { *m = CountReply{} }
func (m *CountReply) String() string { return proto.CompactTextString(m) }
func (*CountReply) ProtoMessage()    {}

// Request for a stream of Entry objects in the given shard.
type ShardRequest struct {
	Index  int64 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Shards int64 `protobuf:"varint,2,opt,name=shards" json:"shards,omitempty"`
}

func (m *ShardRequest) Reset()         { *m = ShardRequest{} }
func (m *ShardRequest) String() string { return proto.CompactTextString(m) }
func (*ShardRequest) ProtoMessage()    {}

// Request for the set of node tickets matching a partial VName and collection
// of known facts.
type SearchRequest struct {
	// partial VName to match against nodes.  Each non-empty field
	// becomes a constraint (i.e. the signature/corpus/etc. must be exactly
	// case-sensitively equal to the given string) on the set of returned nodes.
	Partial *VName `protobuf:"bytes,1,opt,name=partial" json:"partial,omitempty"`
	// Facts that a node must have to be matched.
	Fact []*SearchRequest_Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
}

func (m *SearchRequest) Reset()         { *m = SearchRequest{} }
func (m *SearchRequest) String() string { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()    {}

func (m *SearchRequest) GetPartial() *VName {
	if m != nil {
		return m.Partial
	}
	return nil
}

func (m *SearchRequest) GetFact() []*SearchRequest_Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

type SearchRequest_Fact struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SearchRequest_Fact) Reset()         { *m = SearchRequest_Fact{} }
func (m *SearchRequest_Fact) String() string { return proto.CompactTextString(m) }
func (*SearchRequest_Fact) ProtoMessage()    {}

// Response for a SearchRequest.
type SearchReply struct {
	// Set of node tickets matching a given SearchRequest.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
}

func (m *SearchReply) Reset()         { *m = SearchReply{} }
func (m *SearchReply) String() string { return proto.CompactTextString(m) }
func (*SearchReply) ProtoMessage()    {}

func init() {
}
